{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Exploring Enterprise Linux","text":""},{"location":"#exploring-enterprise-linux","title":"Exploring Enterprise Linux","text":"<p>From nervous SSH login to confident system administration.</p> <p>A subsection of BradPenney.io, this site teaches practical Linux skills for developers and system administrators. It emphasizes real-world scenarios, production safety, and the \"why\" behind every command.</p>"},{"location":"#learning-path","title":"Learning Path","text":"<ul> <li> <p> Day One - Getting Started</p> <p>Getting Access \u2014 SSH connection, local setup (WSL2, VirtualBox, Cloud)</p> <p>Orientation \u2014 First 60 seconds on a new server, system reconnaissance</p> <p>Understanding Your Permissions \u2014 Access levels, <code>sudo</code>, and file permission basics</p> <p>Safe Exploration \u2014 Read-only reconnaissance without breaking things</p> <p>Reading Logs Like a Pro \u2014 <code>tail</code>, <code>grep</code>, and <code>journalctl</code> for production debugging</p> <p>Finding Documentation, First Tasks, Safety Guide \u2014 (coming soon)</p> </li> <li> <p> Level 1 - Everyday Navigation (Coming Soon)</p> <p>Moving Around \u2014 <code>ls</code>, <code>cd</code>, <code>pwd</code>, directory navigation</p> <p>File Management \u2014 <code>cp</code>, <code>mv</code>, <code>rm</code>, <code>mkdir</code>, creating and organizing</p> <p>Viewing Files \u2014 <code>cat</code>, <code>less</code>, <code>head</code>, <code>tail</code>, reading file contents</p> </li> <li> <p> Level 2 - Finding &amp; Filtering (Coming Soon)</p> <p>Searching \u2014 <code>find</code>, <code>locate</code>, searching the filesystem</p> <p>Text Processing \u2014 <code>grep</code>, <code>awk</code>, <code>sed</code>, pattern matching</p> <p>Pipes &amp; Redirection \u2014 Combining commands, shaping output</p> </li> <li> <p> Level 3 - Processes &amp; Permissions (Coming Soon)</p> <p>Processes \u2014 <code>ps</code>, <code>top</code>, <code>kill</code>, managing running programs</p> <p>Permissions \u2014 <code>chmod</code>, <code>chown</code>, file and directory access control</p> <p>Users &amp; Groups \u2014 User management, sudo, access levels</p> </li> <li> <p> Level 4 - System Management (Coming Soon)</p> <p>Services \u2014 <code>systemd</code>, <code>systemctl</code>, <code>journalctl</code>, service management</p> <p>Networking \u2014 IP configuration, DNS, SSH, firewall basics</p> <p>Storage \u2014 Filesystems, mounting, LVM, disk management</p> </li> <li> <p> Level 5 - Under the Hood (Coming Soon)</p> <p>Boot Process \u2014 GRUB, initramfs, systemd startup sequence</p> <p>Kernel &amp; /proc \u2014 Understanding <code>/proc</code>, <code>/sys</code>, kernel parameters</p> <p>Advanced Concepts \u2014 Namespaces, cgroups, memory management</p> </li> <li> <p> Level 6 - Special Topics (Coming Soon)</p> <p>Shell Scripting \u2014 Bash scripts, automation, best practices</p> <p>Containers \u2014 Podman, Docker, rootless containers as services</p> <p>Advanced Tools \u2014 <code>tmux</code>, text editors, dotfiles, cron jobs</p> </li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>This site teaches Linux with production safety in mind. Every article emphasizes:</p> <ul> <li>Real-world scenarios you'll encounter on actual servers</li> <li>Safety-first approach \u2014 when commands are dangerous and why</li> <li>Purpose-driven learning \u2014 understanding the \"why,\" not just memorizing syntax</li> <li>Progressive complexity \u2014 from Day One orientation to system internals</li> </ul> <p>Whether you just received SSH credentials to your first production server or you're deepening your Linux expertise, this site meets you where you are.</p>"},{"location":"#connect","title":"Connect","text":"<ul> <li>Main site: bradpenney.io</li> <li>Source code: GitHub</li> </ul>"},{"location":"administering_linux/accessing_network_storage/","title":"Accessing Network Storage","text":"<p>One of the cornerstones of enterprise computing is letting systems share data seamlessly. Enter NFS (Network File System): it lets clients pull from or write to storage on a server as if it were local.</p> <p>Classic use cases include: - Applications writing logs to a central share - Database servers sharing data files - User home directories in large organizations</p> <p>Whatever the use case, NFS makes life a lot easier.</p> Client-Side NFS Setup <p>This article covers accessing an existing NFS export. If you need to set up the server side first, see Serving Up Network Storage.</p>"},{"location":"administering_linux/accessing_network_storage/#finding-an-nfs-share","title":"Finding an NFS Share","text":"<p>To see what a server is sharing, run: Show NFS Exports<pre><code># showmount -e &lt;Name_of_NFS_Server&gt; or &lt;IP_of_NFS_Server&gt;\nshowmount -e homeServer # OR\nshowmount -e 192.168.250.250\n</code></pre></p> <p>The result should resemble: Sample NFS Export List<pre><code>Export list for homeServer:\n/sharedSpace *\n</code></pre></p> <p>Once you know what\u2019s available, you have two main choices for mounting it: permanently or on-demand with automount.</p>"},{"location":"administering_linux/accessing_network_storage/#option-1-permanently-mounted","title":"Option 1: Permanently Mounted","text":"<p>A permanent mount means the NFS share is always present in the Linux File System Hierarchy. To the client, it just looks like another directory.</p> <ul> <li>\ud83d\udc4d Pros: always there, seamless for apps and users</li> <li>\ud83d\udc4e Cons: if the NFS server is down, your client may hang or fail to boot</li> </ul> <p>For enterprise systems with \u201cfive-nines\u201d uptime, that tradeoff is usually fine.</p>"},{"location":"administering_linux/accessing_network_storage/#install-client-packages","title":"Install Client Packages","text":"Install NFS Client Package<pre><code>dnf install nfs-utils # RHEL Family\napt install nfs-common # Debian Family\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#add-to-etcfstab","title":"Add to <code>/etc/fstab</code>","text":"<p>Always back it up first:</p> Backup /etc/fstab<pre><code>cp /etc/fstab /etc/fstab_bkup\n</code></pre> <p>Then add:</p> Edit /etc/fstab<pre><code># &lt;NFS_Server_Name&gt;:/&lt;share_name&gt;   /&lt;mountPoint&gt;   nfs     sync    0 0\nhomeServer:/                        /share          nfs     sync    0 0\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#validate-the-mount","title":"Validate the Mount","text":"<pre><code>mount -a # check if error thrown\nmount | grep homeServer # should return some lines\nfindmnt --verify # should return no issues\n</code></pre> <p>If all looks good, reboot and confirm it mounts automatically.</p>"},{"location":"administering_linux/accessing_network_storage/#option-2-automount","title":"Option 2: Automount","text":"<p>Automounting makes shares available on demand \u2014 they appear only when accessed, and disappear when idle.</p> <p>This is great for:</p> <ul> <li>User home directories (only mount them when someone logs in)</li> <li>Occasional writes (e.g., daily log dumps)</li> <li>Reducing overhead when constant connectivity isn\u2019t needed</li> </ul> <p>From a user\u2019s perspective: it \u201cjust works\u201d when they need it, but doesn\u2019t clutter the system otherwise.</p>"},{"location":"administering_linux/accessing_network_storage/#install-and-enable-autofs","title":"Install and enable <code>autofs</code>","text":"<pre><code>dnf install autofs # RHEL Family\napt install autofs # Debian Family\n\n# Enable the service\nsystemctl enable --now autofs\n</code></pre> Restart Required After Config Changes <p>Remember: restart autofs every time you change its config:</p> Restart autofs<pre><code>systemctl restart autofs\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#configure-automount","title":"Configure Automount","text":"<p>Automount uses at least two files: - <code>/etc/auto.master</code> \u2192 defines the mount point and its map file - <code>/etc/auto.&lt;shortName&gt;</code> \u2192 the specific config for that share</p> <p>Example:</p> <p><code>/etc/auto.master</code>:</p> Sample /etc/auto.master<pre><code># /etc/auto.master\n# /&lt;mountPoint&gt; /etc/auto.&lt;configFile&gt;\n/share  /etc/auto.share\n</code></pre> <p><code>/etc/auto.share</code>:</p> Sample /etc/auto.share<pre><code># /etc/auto.share\n# &lt;wildcard&gt; &lt;read/write&gt; &lt;location&gt;\n*   -rw     homeServer:/sharedSpace/&amp;\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#how-it-works","title":"How it Works","text":"<ul> <li>The server homeServer shares <code>/sharedSpace</code>.</li> <li>Clients don\u2019t see subdirectories until they\u2019re accessed (i.e. <code>/share/backups</code>).</li> </ul>"},{"location":"administering_linux/accessing_network_storage/#conclusion","title":"Conclusion","text":"<p>Whether you go with permanent mounts or automount, NFS is a fundamental tool for enterprise admins. It extends the filesystem across machines, making your infrastructure far more flexible and powerful.</p> Need the Server Side? <p>In case you missed it above, Serving Up Network Storage contains the details on how to set up the share drive.</p>"},{"location":"administering_linux/adding_storage/","title":"Adding a Storage Disk To Linux","text":"<p>Adding extra storage in Linux is one of those everyday sysadmin tasks \u2014 especially in virtual machines. In big enterprise setups, you\u2019d normally use LVM (Logical Volume Management), but sometimes you just need to drop in a simple disk and make it usable.</p> <p>That\u2019s what we\u2019ll do here: add a plain disk, partition it, format it, and mount it so Linux can use it.</p>"},{"location":"administering_linux/adding_storage/#connect-a-new-disk","title":"Connect a New Disk","text":"<p>How you attach a disk depends on your setup:</p> <ul> <li>Physical server \u2192 crack open the case/rack and plug it in (not covered here).</li> <li>Virtual machine \u2192 add one through your hypervisor.</li> </ul> <p>In this demo we\u2019re using Virtual Machine Manager (a front-end for KVM/QEMU). The process is similar if you\u2019re on VMware, VirtualBox, or Hyper-V.</p> <p>Open the VM details, hit Add Hardware, and create a new disk:</p> <p></p> <p>We\u2019ll add a couple of 10GiB virtual disks:</p> <p></p> <p>They\u2019ll then show up as hardware for the VM:</p> <p></p>"},{"location":"administering_linux/adding_storage/#find-the-added-disks-with-lsblk","title":"Find the Added Disks with <code>lsblk</code>","text":"<p>Boot the VM, log in, become <code>root</code>, and run <code>lsblk</code>. You\u2019ll see your new disks \u2014 the names depend on the hypervisor (<code>sdb</code>, <code>vdb</code>, etc.):</p> <p></p> <p>Here they\u2019re <code>vdb</code> and <code>vdc</code>, which live in <code>/dev/</code>:</p> <p></p> <p>\u26a0\ufe0f Heads-up: storage management is root-level work. Don\u2019t try this as a normal user.</p>"},{"location":"administering_linux/adding_storage/#create-a-partition-table-with-fdisk","title":"Create a Partition Table with <code>fdisk</code>","text":"<p>Fresh disks are blank slates \u2014 no partition table, no use. - MBR = old style (limited, mostly legacy now). - GPT = modern, flexible, and what we\u2019ll use.</p> <p>Run fdisk on the new disk:</p> <p></p> <p>Inside fdisk: - <code>g</code> \u2192 create a GPT partition table - <code>n</code> \u2192 create a new Partition - <code>p</code> \u2192 print the partition table - <code>m</code> \u2192 print the help menu - <code>w</code> \u2192 write changes and exit</p> <code>fdisk</code> Help <p>Help inside <code>fdisk</code> can be found with <code>m</code> (some think of it as <code>m</code> for Menu)</p>"},{"location":"administering_linux/adding_storage/#use-fdisk-to-create-partitions","title":"Use <code>fdisk</code> to Create Partitions","text":"<p>Reopen fdisk on /dev/vdb and create a partition: - <code>n</code> \u2192 new partition - choose number, start, and size (or just hit Enter for defaults)</p> <p>Here\u2019s an example making a 1GiB partition:</p> <p></p> Note <p>Pressing Enter at the prompts usually accepts sensible defaults</p>"},{"location":"administering_linux/adding_storage/#validate-partition-and-write-to-disk","title":"Validate Partition and Write to Disk","text":"<p>Still in <code>fdisk</code>: - <code>p</code> \u2192 print the partition table (double-check your work) - <code>w</code> \u2192 write to disk</p> <p></p> <p>Repeat these steps to create another partition on the disk that was created. Once both partitions are created, a simple <code>lsblk</code> should show both disks with partitions, ready for the next steps:</p> <p></p>"},{"location":"administering_linux/adding_storage/#make-a-file-system-on-the-created-partitions","title":"Make a File System On the Created Partitions","text":"<p>Partitions are just containers. To actually use them, format with a filesystem:</p> <p></p> File System Types <p>Just for fun, we created two different types of file systems, one <code>xfs</code> and the other <code>ext4</code>.  File system types are a big topic, but these are two very important types.</p>"},{"location":"administering_linux/adding_storage/#create-a-directory-for-the-file-systems","title":"Create a Directory for the File Systems","text":"<p>In Linux, new storage doesn\u2019t show up as a drive letter. You need to 'attach' it somewhere in the filesystem.</p> <p>For this demo: - <code>/app</code> \u2192 XFS disk - <code>/db</code> \u2192 ext4 disk</p> <p>Make Mount Points<pre><code>sudo mkdir /app /db\n</code></pre> As below (using <code>root</code>, therefore no <code>sudo</code>):</p> <p></p>"},{"location":"administering_linux/adding_storage/#make-a-backup-of-etcfstab","title":"Make a Backup of <code>/etc/fstab</code>","text":"<p>The <code>/etc/fstab</code> file controls which filesystems get mounted at boot. It\u2019s powerful but unforgiving: one bad entry can prevent the system from starting.</p> <p>Make a backup first:</p> <p></p>"},{"location":"administering_linux/adding_storage/#make-the-mounts-automatic-and-permanent","title":"Make the Mounts Automatic and Permanent","text":"<p>Best practice is to mount by UUID (unique ID) instead of device name. Grab it with:</p> Get UUID of New Partition<pre><code>blkid | grep vdb1 | awk ' { print $2 } '\n</code></pre> <p>Append it to <code>/etc/fstab</code>:</p> Append the UUID to fstab<pre><code>blkid | grep vdb1 | awk ' { print $2 } ' &gt;&gt; /etc/fstab\n</code></pre> <p></p> Append, Don't Overwrite! <p>Note that this APPENDS (<code>&gt;&gt;</code>) to <code>/etc/fstab</code>.  Do not overwrite <code>/etc/fstab</code>! (But if that happens, simply revert using the backup taken above!) It is highly recommended to confirm the output of the command is as expected BEFORE appending it to <code>/etc/fstab</code>.  This kind of \"trust but verify\" mentality will save many blunders in the command-line.</p> <p>Then check that <code>/etc/fstab</code> has this line:</p> Check fstab<pre><code>UUID=\"&lt;yourUUID&gt;\"     /app    xfs     defaults        0 0\n</code></pre> <p>In our example, <code>/etc/fstab</code> now looks like this:</p> <p></p> <p>Repeat for the other disk.  The final <code>/etc/fstab</code> should look like this:</p> <p></p>"},{"location":"administering_linux/adding_storage/#mount-validate-the-new-storage","title":"Mount &amp; Validate the New Storage","text":"<p>Apply the changes with:</p> Mount All Filesystems in fstab<pre><code>mount -a\n</code></pre> <p>Verify both disks are showing up and that there are no issues with:</p> Validate the New Mounts<pre><code>mount | grep vd[bc] # will vary depending on setup/hypervisor\nfindmnt --verify\n</code></pre> <p>For example:</p> <p></p> <p>A couple other checks could be:</p> <p></p> <p>Test them by creating files, then reboot to make sure mounts survive.</p> <p>If the system won\u2019t boot, don\u2019t panic \u2014 drop to root shell and restore your backup:</p> Restore fstab from Backup<pre><code>cp /etc/fstab_bkup /etc/fstab\n</code></pre> <p>Go add some storage to a Linux system! Enjoy!</p> Using <code>parted</code> <p>As mentioned above, there is also a <code>parted</code> utility which works with storage disks.</p>"},{"location":"administering_linux/lvm_basics/","title":"Logical Volume Management Basics","text":"<p>While adding a disk directly works fine, that approach doesn\u2019t scale well in enterprise environments. Big systems need flexibility: adding, resizing, moving, or even migrating storage without reformatting everything.</p> <p>That\u2019s where Logical Volume Management (LVM) shines. At its core, LVM is built around three building blocks:</p> <ol> <li>Physical Volumes (PVs) \u2192 actual disks (or partitions) you feed into    LVM</li> <li>Volume Groups (VGs) \u2192 pools of storage made from PVs</li> <li>Logical Volumes (LVs) \u2192 slices of the pool, presented to Linux as    usable disks</li> </ol> <p>Think LEGO bricks: PVs are the raw bricks, VGs are the big bucket you dump them into, and LVs are the custom shapes you build from that bucket. Quality engineering, not fast-food assembly. \ud83e\uddf1</p> Demo OS: Rocky Linux <p>This demo uses Rocky Linux (RHEL9 downstream). Everything here is done as <code>root</code> \u2014 which is typical for storage work.</p>"},{"location":"administering_linux/lvm_basics/#add-new-disks","title":"Add New Disks","text":"<p>The setup is the same as in Adding Storage. The only difference: LVM makes the most sense when you\u2019ve got multiple disks to play with.</p> <p>In this demo, we\u2019ll use four 5GiB disks, combined with RAID5 for redundancy (RAID is its own big topic, but redundancy means \u201csafer data\u201d \ud83d\udc4d).</p> <p></p>"},{"location":"administering_linux/lvm_basics/#create-a-new-physical-volumes-pvs","title":"Create a New Physical Volumes (PVs)","text":"<p>Our four new disks (<code>vdb</code>, <code>vdc</code>, <code>vdd</code>, <code>vde</code>) show up in <code>lsblk</code>. Before LVM can use them, we convert them into physical volumes:</p> Create Physical Volumes<pre><code>#pvcreate &lt;disks to add&gt;\npvcreate /dev/vdb /dev/vdc /dev/vdd /dev/vde\n</code></pre> <p></p> <p>You could run <code>pvcreate</code> once per disk, but batching them is faster. Check what PVs exist:</p> <p></p> <p>Or inspect details for one:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#create-a-volume-group-vg","title":"Create a Volume Group (VG)","text":"<p>Now, we pool those PVs into a volume group. This becomes our central storage bucket.</p> Create Volume Group<pre><code># vgcreate &lt;nameOfVolumeGroup&gt; &lt;disksToAdd&gt;\nvgcreate vg_demo /dev/vdb /dev/vdc /dev/vdd /dev/vde\n</code></pre> <p></p> <p>From here: - Add/remove disks as PVs - Create/remove logical volumes from the pool</p> <p>Some useful VG commands:</p> Explore Volume Groups<pre><code>vgscan          # scan for groups\nvgs             # list groups\nvgdisplay vg_demo   # show details\n</code></pre> <p></p> <p>List volume groups with <code>vgs</code>:</p> <p></p> <p>List information about a specific volume group with <code>vgdisplay &lt;volumeGroup&gt;</code>:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#create-a-logical-volume-lv","title":"Create a Logical Volume (LV)","text":"<p>Now for the fun part: carve out an LV from the VG.</p> <p>In this demo, we\u2019ll: -  Use RAID5 - Allocate 50% of the VG\u2019s free space - Name it <code>lv_demo</code></p> <p>Create Logical Volume<pre><code>#lvcreate --type &lt;asRequired&gt; -l &lt;size&gt; -n &lt;lvName&gt; &lt;vgName&gt;\nlvcreate --type raid5 -l 50%FREE -n lv_demo vg_demo\n</code></pre> </p> <p>Explore existing LVs with <code>lvs</code>:</p> <p></p> <p>And <code>lvdisplay</code>:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#make-a-file-system-on-the-logical-volume","title":"Make a File System on the Logical volume","text":"<p>Logical volumes are block devices, just like disks. They need a filesystem before use.</p> <p>By default, they live under <code>/dev/&lt;VG&gt;/&lt;LV&gt;</code>. Format with <code>mkfs</code>:</p> Make a File System on the Logical Volume<pre><code>#mkfs.&lt;fstype&gt; &lt;location&gt;\nmkfs.xfs /dev/vg_demo/lv_demo\n</code></pre> <p></p> <p>Then create a mount point - <code>mkdir /lvmDemo</code>.</p>"},{"location":"administering_linux/lvm_basics/#permanently-mount-the-logical-volume","title":"Permanently Mount the Logical Volume","text":"<p>Check the UUID of the LV: </p> <p>Append its UUID to <code>/etc/fstab</code> safely:</p> <p>Send LVM UUID to /etc/fstab<pre><code>#blkid -s UUID -o value &lt;location of LVM under /dev/mapper&gt;\nblkid -s UUID -o value /dev/mapper/vg_demo-lv_demo &gt;&gt; /etc/fstab\n</code></pre> </p> Append, Don't Overwrite! <p>Always back up <code>/etc/fstab</code> before editing. And double-check the output before appending.</p> <p>The new line in /etc/fstab should look like:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#validate","title":"Validate","text":"<p>Run:</p> Validate LVM Mount<pre><code>mount -a\nmount | grep lv_demo\nfindmnt --verify\n</code></pre> <p></p> <p>Test it by creating files:</p> <p></p> Set Permissions <p>Right now, the LV is owned by <code>root</code>. Adjust ownership/permissions so  other users can use it \u2014 see  Basic Linux Permissions.</p> <p>Finally, reboot to confirm everything survives startup.</p> <p>\ud83c\udf89 Congrats \u2014 you\u2019ve just built a flexible, enterprise-grade storage setup with LVM.</p>"},{"location":"administering_linux/network_file_share_server/","title":"Serving Up Network Storage","text":"<p>One of the coolest perks of running a server is sharing storage across your network. Enter NFS (Network File System) \u2014 a way to let client machines access storage as if it were local.</p> <p>Why is this handy? A few classic use cases: - Centralized home directories (often paired with LDAP) - Applications needing a shared data store - Multiple servers writing logs to one place</p> <p>Honestly, the use cases are endless \u2014 and the setup is refreshingly simple.</p> Server-Side NFS Setup <p>This article covers setting up the server side. See Accessing Network Storage for how to mount NFS shares on clients.  \u26a0\ufe0f You\u2019ll need <code>root</code> for all of this. Storage and networking are not \u201cnormal user\u201d territory.</p>"},{"location":"administering_linux/network_file_share_server/#step-1-install-the-nfs-server-package","title":"Step 1: Install the NFS Server Package","text":"<p>First, add the NFS service. Package names differ by distro:</p> Install NFS Server Package<pre><code>dnf install nfs-utils # RHEL Family\napt install nfs-kernel-server # Debian Family\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#step-2-create-an-export-listing","title":"Step 2: Create an Export Listing","text":"<p>Exports tell NFS which directories you want to share. You almost never share the whole filesystem \u2014 it\u2019s much safer (and saner) to create a dedicated share, e.g. <code>/share</code> or <code>/logs</code>.</p> <p>Edit <code>/etc/exports</code> and define your shares:</p> Sample /etc/exports File<pre><code>/sharedSpace *(rw,no_root_squash)\n/sharedLogs *(rw, no_root_squash)\n</code></pre> <ul> <li><code>rw</code> \u2192 read/write</li> <li><code>no_root_squash</code> \u2192 allows client <code>root</code> to act as <code>root</code> on the share    (use with caution!)</li> </ul>"},{"location":"administering_linux/network_file_share_server/#step-3-enable-the-service-and-adjust-permissions","title":"Step 3: Enable the Service and Adjust Permissions","text":"<p>Turn on the NFS service:</p> Enable NFS Service<pre><code>systemctl enable --now nfs-server # RHEL Family\nsystemctl enable --now nfs-kernel-server # Debian Family\n</code></pre> <p>If you\u2019re running firewalld, allow NFS-related services:</p> Adjust Firewall for NFS<pre><code>firewall-cmd --add-service=nfs\nfirewall-cmd --add-service=rpc-bind\nfirewall-cmd --add-service=mountd\nfirewall-cmd --runtime-to-permanent\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#step-4-validate-with-a-client-system","title":"Step 4: Validate with a Client System","text":"<p>On a client system, check that the server is actually exporting its shares:</p> Find an NFS Share<pre><code># showmount -e &lt;Name_of_NFS_Server&gt; or &lt;IP_of_NFS_Server&gt;\nshowmount -e homeServer # OR\nshowmount -e 192.168.250.250\n</code></pre> <p>Expected output looks like this:</p> Sample Output from showmount<pre><code>Export list for homeServer:\n/sharedSpace *\n/sharedLogs *\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#enterprise-best-practices-for-nfs","title":"Enterprise Best Practices for NFS","text":"<p>A basic NFS setup works fine at home or in a lab, but in Production you\u2019ll want to tighten things up. Here are some smart defaults:</p>"},{"location":"administering_linux/network_file_share_server/#use-root_squash-not-no_root_squash","title":"Use <code>root_squash</code> (not <code>no_root_squash</code>)","text":"<ul> <li>By default, NFS maps remote <code>root</code> users to a harmless local user (usually <code>nfsnobody</code>).</li> <li>This prevents a compromised client from owning your NFS server.</li> <li>Only use <code>no_root_squash</code> for very specific, controlled use cases.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#restrict-access-by-host-or-subnet","title":"Restrict access by host or subnet","text":"<ul> <li>Instead of <code>*</code> (any host), use IPs or CIDR blocks:</li> </ul> Restrict NFS Access by Subnet<pre><code>/sharedSpace 192.168.250.0/24(rw,sync,root_squash)\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#enable-sync-writes","title":"Enable <code>sync</code> writes","text":"<ul> <li>Forces writes to hit disk before returning \u201csuccess.\u201d</li> <li>Safer (though slower) than <code>async</code>.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#set-appropriate-filesystem-permissions","title":"Set appropriate filesystem permissions","text":"<ul> <li>NFS exports don\u2019t override Linux permissions.</li> <li>Make sure your shared directories have correct ownership and mode bits.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#watch-selinux","title":"Watch SELinux","text":"<ul> <li>On RHEL-family systems, SELinux may block NFS exports by default.</li> <li>Enable with:</li> </ul> Enable NFS in SELinux<pre><code>setsebool -P nfs_export_all_rw 1\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#monitor-with-showmount-and-exportfs","title":"Monitor with <code>showmount</code> and <code>exportfs</code>","text":"<ul> <li><code>exportfs -v</code> shows exactly what\u2019s being shared and with what options.</li> <li>Run it after changes to confirm settings are live.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#consider-nfsv4","title":"Consider NFSv4","text":"<ul> <li>Newer, cleaner protocol with better performance and security.</li> <li>Reduces port juggling (everything runs over TCP/2049).</li> </ul> <p>Bottom line: keep it tight. Don\u2019t export wide-open shares unless you\u2019re in a safe lab environment.</p>"},{"location":"automation/caseStatements/","title":"BASH Case Statements","text":"<p>One of the very nice options available in shell scripting is the <code>case</code> statement.  The case statement allows the script to test many different conditionals much more efficiently (in terms of lines of code) than an <code>if/elif/else</code> statement (see Decision Making - <code>if/else</code> Statements for further details).</p> <p>Shell's <code>case</code> statement is similar to the <code>switch</code> statement found in other programming languages (both of which are missing entirely from Python!)</p> <p>As an example, a recent version of Manjaro running i3wm includes the following case statement in its <code>.bashrc</code> file; it decides how to correctly handle compressed files:</p> <p></p>"},{"location":"automation/caseStatements/#case-statement-syntax-and-basic-usage","title":"Case Statement Syntax and Basic Usage","text":"<p>The syntax of the case statement is as follows:</p> <pre><code>case variable in\n    pattern1)\n        command1\n        ;;\n    pattern2)\n        command2\n        ;;\n    pattern3)\n        command3\n        ;;\n    *)\n        default_command\n        ;;\nesac\n</code></pre> <p>Here, <code>variable</code> is the value to check, and <code>pattern1</code>, <code>pattern2</code>, <code>pattern3</code> are the possible values to match. <code>command1</code>, <code>command2</code>, and <code>command3</code> are the commands to be executed a match is found.  The <code>default_command</code> will be executed if none of the patterns match.</p> <p>A very simple example to understand the case statement is as follows:</p> <pre><code>#!/bin/bash\n\n# User is prompted to provide input\necho \"Enter a number between 1 and 3: \"\n# Input is taken from the user\nread num\n\n# Case Statement Evaluates the Response and Responds\ncase $num in\n    1)\n        echo \"You entered one.\"\n        ;;\n    2)\n        echo \"You entered two.\"\n        ;;\n    3)\n        echo \"You entered three.\"\n        ;;\n    *)\n        echo \"Invalid number.\"\n        ;;\nesac\n</code></pre>"},{"location":"automation/caseStatements/#best-practices-for-using-case-statements","title":"Best Practices for Using Case Statements","text":"<p>While case statements can be powerful tools for shell scripting, they can also be tricky to use correctly. Here are some best practices to keep in mind when using case statements:</p> <ol> <li> <p>Use the correct syntax: Make sure that your case statement follows the correct syntax. Any mistakes in the syntax can cause your script to fail.</p> </li> <li> <p>Use meaningful variable names: Choose variable names that are meaningful and descriptive. This will make it easier to understand the purpose of the case statement.</p> </li> <li> <p>Use consistent indentation: Use consistent indentation for each case statement block. This will make it easier to read and understand the code.</p> </li> <li> <p>Use comments: Use comments to explain the purpose of the case statement and each block of code. This will make it easier for others to understand your code.</p> </li> <li> <p>Use patterns wisely: Choose patterns that are easy to understand and maintain. Avoid using complex regular expressions that can be difficult to read and understand.</p> </li> <li> <p>Use a default block: Always include a default block in your case statement. This will ensure that your script handles unexpected values correctly.</p> </li> <li> <p>Keep it simple: Use the case statement only when it is necessary. If a simple if statement can accomplish the same task, use it instead.</p> </li> </ol> <p>Case statements are powerful tools for shell scripting that allow checking the value of a variable and executing different blocks of code based on its value. Enjoy!</p>"},{"location":"automation/ifElseStatements/","title":"BASH If/Else Statements","text":"<p>Shell scripting comes fully equipped with <code>if/else</code> statement capabilities.  This is commonly used to evaluate conditions such as input from parameters, ensure files exist, ensure that processes are running, and there are several other use cases.  The syntax is a little different than some other languages, but for the most part BASH <code>if/else</code> statements are easy, even for those who haven't used other programming languages.</p> <p>In this demo, we'll write a simple script to check if a file exists on the system.  The finished product will work like this:</p> <p></p>"},{"location":"automation/ifElseStatements/#step-1-determine-the-condition","title":"Step 1: Determine the Condition","text":"<p>One of the really fantastic things about shell scripting is that it will run most anything that will run in the standard CLI.  This can make testing conditionals very simple - check the output of any command with the server is running in the desired state, then use that same command in a script.  For example, if checking to see if the SSH service is running, issue this command:</p> <pre><code># Check to see if SSH is mentioned in a PID, removing the grep results, and counting the number of lines in the result\nps aux | grep ssh | grep -v grep | wc -l\n</code></pre> <p>Which results in:</p> <p></p> <p>So, as there is one line returned, there is one SSH process running.  This command could be embedded in any shell script as <code>echo $(ps aux | grep ssh | grep -v grep | wc -l)</code>.  Or, as we'll see below, it could be used as a conditional in an <code>if/else</code> statement.</p> <p>Tip: If the above command is unclear, reverse engineer it by removing the piped sections one-by-one and figure out how this command works.</p> <p>For the script we're about to write, we're going to check if a file exists.  This is a very useful check for scripts that rely on parameter files or logs to exist before they can run correctly.  Its also a useful example to illustrate the versatility and diversity of BASH scripting - it's a conditional that can't be used directly in command-line usage.</p>"},{"location":"automation/ifElseStatements/#step-2-create-the-file","title":"Step 2: Create the File","text":"<p>Before creating any file, it is a smart idea to check and see where the BASH shell is located.  This is standardized to <code>/bin/bash</code>, however, a quick <code>which bash</code> will make sure that BASH is where it is expected</p> <p>Creating the file is as simple as <code>vim testMyFile.sh</code>.  This is the file in which we'll check to see if \"myFile.txt\" exists or not.  After jumping into <code>INSERT</code> mode, add the \"shebang\" line:</p> <pre><code>#!/bin/bash\n</code></pre> <p>This tells the kernel that the contents of the file should be interpreted using the BASH program.  If the \"shebang\" is missing, the file won't run correctly.</p> <p>Note - this also works for other programming languages.  For example, when writing a Python script, the \"shebang\" might be <code>#!/bin/python3</code>, and the kernel will interpret the program using Python</p>"},{"location":"automation/ifElseStatements/#step-3-write-the-ifelse-statement","title":"Step 3: Write the If/Else Statement","text":"<p>Now on to the fun part - writing the <code>if/else</code> statement. \u2728 The finished product looks like this:</p> <p></p> <p>Before just copy/pasting this, lets break it down and explain it a little.</p>"},{"location":"automation/ifElseStatements/#the-if-statement","title":"The \"If\" Statement","text":"<p>Any <code>if/else</code> statement starts with <code>if [ &lt;condition&gt; ]; then</code>.  In pseudo-code, this translates to \"if this condition is met, do the following\":</p> <pre><code># If myFile.txt exists, do the following:\nif [ -f myFile.txt ]; then\n    # Write in the terminal that the file exists\n    echo \"The file exists!\"\nfi\n</code></pre> <p>Notice the <code>fi</code> at the end of the statement - this is how an <code>if</code> statement is closed in BASH.  Its just the reverse of <code>if</code>.</p> <p>Note that single square brackets may not work on UNIX operating systems such as AIX and Solaris.  For these systems, use double square-brackets.  Also, the checks for equality are a little unique - for example <code>-gt</code> (greater than) or <code>-le</code> (less than or equal) - rather than more standard <code>&gt;=</code> used by most programming languages.</p>"},{"location":"automation/ifElseStatements/#add-the-catch-all-else","title":"Add the Catch-All \"Else\"","text":"<p>An <code>if</code> statement is plenty useful just by itself.  Adding an <code>else</code> to perform a different action if the condition IS NOT met increases the versatility exponentially.  In our example, if a file exists, we tell the user, \"The file exists!\".  But if the file doesn't exist, we tell them \"Not there!\":</p> <pre><code>if [ -f myFile.txt ]; then\n    echo \"The file exists!\"\n# Catch-all else statement, if file doesn't exist, do this:\nelse\n    # Write to the terminal that the file isn't there\n    echo \"Not there!\"\n    # Write an exit code for the script that shows a generic \"1\" error\n    exit 1\nfi\n</code></pre> <p>Note the <code>exit 1</code> line within the <code>else</code> section.  This is not strictly necessary, but is a good example of what could happen if a condition isn't met.  Having a script exit if conditions for it success are not met is very common in Enterprise Linux scripting.</p> <p>This is a small and simple example with all the unnecessary complexity stripped out.  It would be much more useful if this <code>else</code> statement actually sent an alert or an email to an administrator saying \"The critical file needed for this process is missing!\" - but that might muddle the examination of the <code>else</code> statement.</p>"},{"location":"automation/ifElseStatements/#how-about-multiple-possibilities","title":"How About Multiple Possibilities?","text":"<p>BASH <code>if/else</code> statements also handle multiple possibilities with the <code>elif</code> statement.  It is used in the exact same ways as the <code>if</code> statement.  For example, our script above could be expanded to check if a different file exists instead:</p> <pre><code>if [ -f myFile.txt ]; then\n    echo \"The file exists!\"\nelif [ -f myOtherFile.txt ]; then\n    echo \"The other file exists, using that instead.\"\nelse\n    echo \"Not there!\"\n    exit 1\nfi\n</code></pre>"},{"location":"automation/testingNumberOfParameters/","title":"Testing the Number Of Parameters Passed to a Shell Script","text":"<p>More often than not, custom shell scripts accept parameters supplied by the command-line user.  In case you're wondering what sort of things commonly get passed to custom shell scripts, here are some examples:</p> <ol> <li>Which Process ID (PID) to perform an action on</li> <li>Custom location for a log file</li> <li>Desired location for the output</li> <li>Which database or application to perform an action on</li> <li>Anything else that could be changed on each run of the script.</li> </ol> <p>In situations like these, it may be CRITICAL that the correct number of parameters are supplied (otherwise the script will run incorrectly!).  Writing a quick check to confirm that the correct number of parameters was supplied is a step in the right direction for error checking.  Here's an example:</p> <pre><code>#!/bin/bash\n\nNUM_REQUIRED_PARAMS=2\nnum_params=$#\n\n# Were 2 parameters supplied?\nif [[ num_params -lt $NUM_REQUIRED_PARAMS ]] ; then\n  echo \"Not enough parameters.  This script requires ${NUM_REQUIRED_PARAMS}.\"\n  sleep 2\n  exit 1\nfi\n\n# OPTIONAL - useful for sending parameters to logs\n# for loop showing how many parameters\necho \"You ran this program with ${num_prams} parameters. Here they are:\"\nfor param in \"$@\":\ndo\n   echo \"$param\"\ndone\n</code></pre> <p>Note that this doesn't guarantee that the parameters are in the correct order or have appropriate values supplied.  These conditions should be checked as well.  In a robust script, this would just be the first check of several.</p>"},{"location":"basic_toolset/BASH_shortcuts/","title":"Essential Bash Keyboard Shortcuts","text":"<p>BASH has a ton of shortcuts, but you don\u2019t need to know them all right away. Start with these \u2014 they\u2019ll save you a ton of keystrokes and make life at the command line way smoother.</p> Shortcut What it Does <code>TAB</code> Autocompletes a partially typed command. If there\u2019s more than one match, Bash shows you the options. <code>\u2191 / \u2193</code> Scroll back/forward through your command history. <code>Ctrl+e</code> Jump to the end of the current line. (e = end) <code>Ctrl+a</code> Jump to the start of the current line. (a = alphabet\u2019s start) <code>Ctrl+u</code> Delete everything from the cursor back to the start of the line. <code>Ctrl+k</code> Delete everything from the cursor to the end of the line. <code>Ctrl+w</code> Delete the word just before the cursor. <code>Ctrl+y</code> Paste back (yank) the last thing you deleted with <code>Ctrl+u</code>, <code>Ctrl+k</code>, or <code>Ctrl+w</code>. <code>Ctrl+l</code> Clear the screen (like the <code>clear</code> command). <code>Ctrl+c</code> Cancel/kill the currently running command or process. <code>Ctrl+z</code> Pause the current job (suspends it in the background). <code>fg</code> Resume the most recent job that was paused with <code>Ctrl+z</code>. <code>bg</code> Resume the paused job, but keep it running in the background. <code>Ctrl+d</code> Log out of the current shell (or send an EOF if in a prompt). <code>Ctrl+r</code> Reverse search through your command history. Type part of a command and Bash will find it. (Game-changer!) <code>!!</code> Run the last command again. (<code>sudo !!</code> is a classic trick.) <p>\ud83d\udc49 Pro tip: Start with <code>TAB</code>, <code>Ctrl+r</code>, and <code>Ctrl+c</code>. Those three alone will change your Bash life.</p>"},{"location":"basic_toolset/file_pagers/","title":"File Pagers","text":"<p>When you\u2019re poking around in Linux and want to peek inside a file, you\u2019ve got a handful of handy pager commands at your disposal. Here are some of the ones you can use, plus a few tips for each.</p>"},{"location":"basic_toolset/file_pagers/#more","title":"<code>more</code>","text":"<p>Think of <code>more</code> as the classic, old-school pager. Press Space to keep moving through the file. You can also search with <code>/</code>, just like in <code>man</code> pages or <code>vim</code>.</p> <pre><code>more myFile.txt\ncat myFile.txt | more\n</code></pre>"},{"location":"basic_toolset/file_pagers/#less","title":"<code>less</code>","text":"<p>This is the pager most folks actually use day-to-day. (The name is a joke \u2014 \"less is more.\" \ud83d\ude04) It fixes a bunch of <code>more</code>'s limitations: you can scroll with the arrow keys or Space, and <code>/</code> search works here too. Once you try it, you'll rarely go back.</p> <pre><code>less myFile.txt\ncat myFile.txt | less\n</code></pre>"},{"location":"basic_toolset/file_pagers/#view","title":"<code>view</code>","text":"<p>This one\u2019s basically <code>vim</code> in read-only mode. You get all the movement and search powers of <code>vim</code>, but by default you can\u2019t save changes \u2014 unless you really mean it with a <code>!</code> (and have write permissions).</p> <pre><code>view myFile.txt\n</code></pre>"},{"location":"basic_toolset/file_pagers/#cat","title":"<code>cat</code>","text":"<p>Not technically a pager, but worth mentioning. <code>cat</code> just dumps the whole file to your terminal in one go. Perfect for tiny files, less fun for giant log monsters. It\u2019s also a common building block when you\u2019re piping output to other commands.</p> <pre><code>cat myFile.txt\ncat myFile.txt | grep -v 'notLinesWithThisText'\n</code></pre> Not sure which to use? <p>If you\u2019re not sure which to use, start with <code>less</code>. It\u2019s faster, friendlier, and more flexible than the others. Happy paging! \ud83c\udf89</p>"},{"location":"basic_toolset/shell_history/","title":"Using Shell History","text":"<p>Most Command Line Shells have a built-in feature to record commands you've run. This is handy for two reasons: it keeps a record of what you've done, and it makes it super easy to repeat commands without retyping them. (Your shell remembers that gnarly <code>find</code> command so you don't have to. \ud83e\udde0) We'll focus on BASH here, since it's the most common shell in enterprise Linux.</p> <p>To see your command history, just type:</p> <pre><code>history\n</code></pre> <p>These commands are stored in your <code>~/.bash_history</code> file.</p> <p></p> <p>The size of your history is controlled by two environment variables: <code>HISTSIZE</code> and <code>HISTFILESIZE</code>. Where these are set depends on your Linux distribution. On RHEL-family systems, <code>/etc/profile</code> sets a default <code>HISTSIZE</code> of 1,000. On Debian-based systems, each user inherits a <code>HISTFILESIZE</code> of 2,000 and a <code>HISTSIZE</code> of 1,000 from <code>/etc/skel/.bashrc</code>.</p> <p>If you want to keep more (or fewer) commands in your history, you can change these values in your own <code>~/.bashrc</code> file.</p>"},{"location":"basic_toolset/shells/","title":"Enterprise Command Line Shells","text":"<p>In UNIX and Linux, a shell is the basic program you use at the command line. Some folks say the name is a metaphor for a snail \u2014 the shell wraps around the kernel. Like most things in Linux, there are lots of different shells, often building on each other and fixing the quirks of earlier versions. Examples include ZSH, FISH, and plenty more.</p> Graphical vs Command-Line Shells <p>Technically, shells can be graphical too \u2014 <code>GNOME</code> and <code>KDE</code> are popular examples. These are rarely (if ever) used on servers.</p> <p>In Enterprise Linux, only a few command-line shells are widely used:</p>"},{"location":"basic_toolset/shells/#bash-bourne-again-shell","title":"BASH (Bourne-Again Shell)","text":"<ul> <li>By far the most common shell in Enterprise Linux. Like a good cup of coffee, \u2615 it's always there when you need it. All Linux distributions have BASH available, even if it's not the default. Not all UNIX systems include BASH.</li> <li>Standard file location: <code>/bin/bash</code> or <code>/usr/bin/bash</code></li> <li><code>#!/bin/bash</code> is usually at the top of shell scripts so the kernel   knows which interpreter to use.</li> </ul>"},{"location":"basic_toolset/shells/#ksh-korn-shell","title":"KSH (Korn Shell)","text":"<ul> <li>Still popular on some UNIX systems like AIX.</li> <li>Lacks some features standard in BASH, like tab-completion and   \"up-arrow\" history.</li> </ul>"},{"location":"basic_toolset/shells/#sh-shell","title":"SH (Shell)**","text":"<ul> <li>The original shell interface used in UNIX.</li> <li>Still exists in modern Linux distributions.</li> <li>Standard file location: <code>/bin/sh</code> or <code>/usr/bin/sh</code></li> </ul>"},{"location":"basic_toolset/text_editors/","title":"Text editors","text":"<p>Command Line Text Editors</p> <p>If you spend any time on the command line, you\u2019ll eventually need to edit text files. Configs, scripts, logs \u2014 they all come up sooner or later. Having a good text editor at your fingertips isn\u2019t just handy, it\u2019s essential.</p> <p>Here are the usual suspects you\u2019ll run into:</p>"},{"location":"basic_toolset/text_editors/#nano","title":"Nano \ud83c\udf7c","text":"<ul> <li>Super beginner-friendly. You can open a file and start typing \u2014 no weird   key combos required.</li> <li>Great for quick edits, but pretty limited compared to the big players.</li> <li>Old-school sysadmins sometimes roll their eyes when they see someone using   Nano (\u201crookie move!\u201d).</li> <li>Installed by default on basically every Linux distro, so it\u2019s always there   as a fallback.</li> </ul> <p>Think of Nano as the training wheels of text editors \u2014 nothing wrong with it, but you\u2019ll probably outgrow it.</p>"},{"location":"basic_toolset/text_editors/#vi-vim","title":"Vi / Vim \u26a1","text":"<ul> <li>The industry standard for editing files in Linux. If you\u2019re serious about   command line work, Vim is the one to know.</li> <li>On most modern systems, typing <code>vi</code> actually launches <code>vim</code> (a supercharged   version of the original <code>vi</code>).</li> <li>Some older UNIX systems still use the plain <code>vi</code>, so it\u2019s worth knowing the   basics.</li> <li>Always available \u2014 it\u2019s installed on every Linux system by default.</li> </ul> <p>Yes, Vim has a bit of a learning curve. Yes, you will forget how to quit at least once. But once you learn the ropes, it\u2019s incredibly powerful and fast. (Your future self will thank you.)</p>"},{"location":"basic_toolset/text_editors/#emacs","title":"Emacs \ud83e\udde0","text":"<ul> <li>Another legendary editor, though not nearly as common in Enterprise Linux   land.</li> <li>Developers tend to love it more than sysadmins.</li> <li>Learning curve? Steep. But the documentation is fantastic.</li> <li>Usually not installed by default, so you\u2019ll have to add it yourself if you   want to give it a spin.</li> </ul> <p>Emacs isn\u2019t just an editor \u2014 some folks basically live inside it. (Email, calendar, games\u2026 you name it.) It\u2019s a rabbit hole, but a fun one if you\u2019re curious.</p>"},{"location":"basic_toolset/text_editors/#bottom-line","title":"\ud83d\udc49 Bottom Line","text":"<ul> <li>Nano is the quick and easy option.</li> <li>Vim is the go-to tool every sysadmin is expected to know.</li> <li>Emacs is powerful but niche, especially on enterprise systems.</li> </ul>"},{"location":"day_one/finding_docs/","title":"Finding Documentation","text":"<p>Part of Day One</p> <p>This is the sixth article in the Day One: Getting Started series. You should have already completed Getting Access, Orientation, Understanding Your Permissions, Safe Exploration, and Reading Logs.</p> <p>You're on a server, you've explored around, and now you have questions:</p> <ul> <li>\"What application runs here?\"</li> <li>\"How do I deploy changes?\"</li> <li>\"Who do I contact if something breaks?\"</li> </ul> <p>The answers exist somewhere. Your team has documentation \u2014 it might just be scattered across wikis, README files, and the brains of senior engineers.</p> <p>Let's find it.</p>"},{"location":"day_one/finding_docs/#start-on-the-server-itself","title":"Start on the Server Itself","text":"<p>Before digging through wikis, check if there's documentation right on the server.</p>"},{"location":"day_one/finding_docs/#check-for-readme-files","title":"Check for README Files","text":"<p>Developers often leave breadcrumbs:</p> Find README Files<pre><code>find /var/www -name \"README*\" 2&gt;/dev/null\nfind /opt -name \"README*\" 2&gt;/dev/null\nfind /home -name \"README*\" 2&gt;/dev/null\n</code></pre> Read the README<pre><code>cat /var/www/app/README.md\n</code></pre>"},{"location":"day_one/finding_docs/#check-the-motd-message-of-the-day","title":"Check the MOTD (Message of the Day)","text":"<p>Some teams put important info in the login message:</p> View Login Message<pre><code>cat /etc/motd\n</code></pre> <p>You probably saw this when you logged in \u2014 it might contain server purpose, contact info, or important warnings.</p>"},{"location":"day_one/finding_docs/#look-for-documentation-directories","title":"Look for Documentation Directories","text":"Common Documentation Locations<pre><code>ls -la /opt/*/docs/ 2&gt;/dev/null\nls -la /var/www/*/docs/ 2&gt;/dev/null\nls -la /usr/local/share/doc/ 2&gt;/dev/null\n</code></pre>"},{"location":"day_one/finding_docs/#check-for-deployment-scripts","title":"Check for Deployment Scripts","text":"<p>Deployment scripts often explain how things work:</p> Find Deployment Scripts<pre><code>find /var /opt /home /usr/local -name \"deploy*\" -type f 2&gt;/dev/null | head -20\nfind /var /opt /home /usr/local -name \"*.sh\" -path \"*/scripts/*\" 2&gt;/dev/null | head -20\n</code></pre> <p>Scope Your Searches</p> <p>Searching from <code>/</code> can take minutes on a large server and puts unnecessary load on the disk. Always scope searches to likely directories like <code>/var</code>, <code>/opt</code>, <code>/home</code>, and <code>/usr/local</code>.</p> <p>Read them (don't run them!) to understand the deployment process:</p> Read Deploy Script<pre><code>cat /opt/app/scripts/deploy.sh\n</code></pre>"},{"location":"day_one/finding_docs/#find-the-team-wiki","title":"Find the Team Wiki","text":"<p>Almost every team has a wiki. The challenge is finding it.</p>"},{"location":"day_one/finding_docs/#ask-these-questions","title":"Ask These Questions","text":"<p>When you join a team or get access to a new server, ask:</p> <ol> <li>\"Where's the documentation for this system?\"</li> <li>\"Is there a runbook for common tasks?\"</li> <li>\"What wiki/Confluence/Notion do you use?\"</li> </ol>"},{"location":"day_one/finding_docs/#common-wiki-platforms","title":"Common Wiki Platforms","text":"<p>Your team probably uses one of these:</p> Platform What to Search Confluence Search for server hostname, application name Notion Check shared workspaces GitHub/GitLab Wiki Look in the repository for the app Google Docs Search your company Drive SharePoint Search the team site Internal Wiki Ask for the URL"},{"location":"day_one/finding_docs/#search-tips","title":"Search Tips","text":"<p>Once you find the wiki, search for:</p> <ul> <li>Server hostname (<code>prod-web-01</code>)</li> <li>Application name</li> <li>\"Runbook\" + application name</li> <li>\"Architecture\" + application name</li> <li>\"On-call\" + application name</li> </ul>"},{"location":"day_one/finding_docs/#find-the-code-repository","title":"Find the Code Repository","text":"<p>The code often has the best documentation.</p>"},{"location":"day_one/finding_docs/#check-for-git-on-the-server","title":"Check for Git on the Server","text":"Find Git Repositories<pre><code>find /var /opt /home -name \".git\" -type d 2&gt;/dev/null | head -10\n</code></pre> Check Git Remote<pre><code>cd /var/www/app\ngit remote -v\n# origin  git@github.com:company/app.git (fetch)\n</code></pre> <p>Now you know where the code lives. Go read the repository's README, wiki, and docs folder.</p>"},{"location":"day_one/finding_docs/#readme-files-in-repos","title":"README Files in Repos","text":"<p>Most repos have documentation:</p> <ul> <li><code>README.md</code> \u2014 Project overview</li> <li><code>docs/</code> \u2014 Detailed documentation</li> <li><code>CONTRIBUTING.md</code> \u2014 How to make changes</li> <li><code>.env.example</code> \u2014 Configuration options</li> <li><code>docker-compose.yml</code> \u2014 How things connect</li> </ul>"},{"location":"day_one/finding_docs/#find-the-runbooks","title":"Find the Runbooks","text":"<p>Runbooks are step-by-step guides for common tasks. They're gold.</p> <p>Runbooks typically cover:</p> <ul> <li>How to deploy</li> <li>How to rollback</li> <li>What to do when alerts fire</li> <li>How to restart services</li> <li>How to check health</li> <li>Who to escalate to</li> </ul>"},{"location":"day_one/finding_docs/#where-runbooks-live","title":"Where Runbooks Live","text":"<ul> <li>Team wiki (Confluence, Notion)</li> <li>Git repository (<code>/docs/runbooks/</code>)</li> <li>On-call documentation</li> <li>PagerDuty/OpsGenie notes</li> </ul>"},{"location":"day_one/finding_docs/#ask-for-them","title":"Ask For Them","text":"<p>\"Is there a runbook for this application?\" \"What's the rollback procedure if something goes wrong?\" \"Where's the on-call documentation?\"</p>"},{"location":"day_one/finding_docs/#find-who-to-ask","title":"Find Who to Ask","text":"<p>Documentation is incomplete. People fill the gaps.</p>"},{"location":"day_one/finding_docs/#check-code-ownership","title":"Check Code Ownership","text":"Git Blame - Who Wrote This?<pre><code>cd /var/www/app\ngit log --oneline -10\n</code></pre> <pre><code>a1b2c3d Fix database connection timeout (Jane Smith)\ne4f5g6h Update config for new API (Bob Johnson)\n...\n</code></pre> <p>These are people who know this code.</p>"},{"location":"day_one/finding_docs/#check-git-blame","title":"Check Git Blame","text":"<p>Who last modified a specific file?</p> Who Changed This File?<pre><code>git blame config/database.yml | head -20\n</code></pre>"},{"location":"day_one/finding_docs/#find-the-on-call","title":"Find the On-Call","text":"<p>Most teams have an on-call rotation. Find out who's currently on-call:</p> <ul> <li>Check PagerDuty/OpsGenie</li> <li>Check Slack (there's usually an on-call channel)</li> <li>Ask: \"Who's on-call for [application name]?\"</li> </ul>"},{"location":"day_one/finding_docs/#team-slack-channels","title":"Team Slack Channels","text":"<p>Most applications have associated Slack channels:</p> <ul> <li><code>#app-name</code> \u2014 General discussion</li> <li><code>#app-name-alerts</code> \u2014 Automated alerts</li> <li><code>#app-name-deploys</code> \u2014 Deployment notifications</li> <li><code>#team-name</code> \u2014 The team that owns it</li> </ul> <p>Search Slack for the server hostname or application name to find relevant channels.</p>"},{"location":"day_one/finding_docs/#documenting-what-you-learn","title":"Documenting What You Learn","text":"<p>Here's a secret: if you can't find documentation, you're the perfect person to write it.</p> <p>As you figure things out:</p> <ol> <li>Take notes</li> <li>Ask your team where to put documentation</li> <li>Write up what you learned</li> <li>Future-you (and teammates) will thank you</li> </ol>"},{"location":"day_one/finding_docs/#what-to-document","title":"What to Document","text":"<ul> <li>How to access the server</li> <li>What the server does</li> <li>Where logs live</li> <li>Common commands you need</li> <li>Who to contact for help</li> <li>Troubleshooting steps you discovered</li> </ul>"},{"location":"day_one/finding_docs/#the-questions-checklist","title":"The Questions Checklist","text":"<p>When you get access to a new server, get answers to these:</p> Question Why It Matters What application runs here? Understand the purpose Where's the code repository? Find detailed docs, make changes Where's the team wiki? Find runbooks and context What's the deployment process? Know how changes go out Who owns this application? Know who to ask What's the on-call rotation? Know who to escalate to Where are the logs? Debug problems What monitoring exists? See dashboards and alerts What's the rollback procedure? Recover from mistakes"},{"location":"day_one/finding_docs/#quick-reference","title":"Quick Reference","text":""},{"location":"day_one/finding_docs/#finding-docs-on-the-server","title":"Finding Docs on the Server","text":"Documentation Hunt<pre><code># README files\nfind /var/www /opt /home -name \"README*\" 2&gt;/dev/null\n\n# Git repos\nfind /var /opt /home -name \".git\" -type d 2&gt;/dev/null | head -10\n\n# Scripts that explain things\nfind /var /opt /home /usr/local -name \"*.sh\" -path \"*/scripts/*\" 2&gt;/dev/null | head -20\n\n# Login message\ncat /etc/motd\n</code></pre>"},{"location":"day_one/finding_docs/#finding-docs-off-the-server","title":"Finding Docs Off the Server","text":"Source What to Search For Team wiki Server hostname, app name Git repo README, docs/, wiki Slack <code>#app-name</code>, hostname Monitoring Dashboards with app name"},{"location":"day_one/finding_docs/#finding-people","title":"Finding People","text":"Method How Git log Who committed recently Git blame Who modified specific files On-call schedule PagerDuty/OpsGenie Slack App/team channels"},{"location":"day_one/finding_docs/#practice-exercises","title":"Practice Exercises","text":"Exercise 1: Hunt for Documentation on the Server <p>You've just been given access to a new server running an app called <code>webapp</code>. Without touching anything, find every README file under <code>/var</code>, <code>/opt</code>, and <code>/home</code>, and check whether there's a message of the day with useful context.</p> <p>Hint: Use <code>find</code> scoped to specific directories, and <code>cat /etc/motd</code>.</p> Solution Find README Files<pre><code>find /var /opt /home -name \"README*\" 2&gt;/dev/null\n</code></pre> Check the Message of the Day<pre><code>cat /etc/motd\n</code></pre> <p>If a README exists, read it with <code>cat</code> or <code>less</code>. It often contains the application name, deployment notes, or contact information.</p> Exercise 2: Find the Git Repository and Who to Call <p>You need to find who last modified the application's configuration files. Find git repositories under <code>/var</code>, <code>/opt</code>, and <code>/home</code>, then \u2014 once you're in one \u2014 check the last 10 commits.</p> <p>Hint: Use <code>find</code> to locate <code>.git</code> directories, then <code>git log</code>.</p> Solution Find Git Repos<pre><code>find /var /opt /home -name \".git\" -type d 2&gt;/dev/null | head -10\n</code></pre> Recent Commits<pre><code>cd /var/www/app\ngit log --oneline -10\n</code></pre> <p>The commit authors are the people who know the code. Their names and the commit messages give you context on what changed recently.</p>"},{"location":"day_one/finding_docs/#quick-recap","title":"Quick Recap","text":"<p>Start on the server:</p> <ul> <li>Look for README files</li> <li>Check the MOTD</li> <li>Find git repositories</li> </ul> <p>Find team resources:</p> <ul> <li>Ask for wiki location</li> <li>Search for runbooks</li> <li>Find Slack channels</li> </ul> <p>Find people:</p> <ul> <li>Check git history for recent contributors</li> <li>Find the on-call rotation</li> <li>Ask in team channels</li> </ul> <p>Give back:</p> <ul> <li>Document what you learn</li> <li>Help the next person</li> </ul>"},{"location":"day_one/finding_docs/#further-reading","title":"Further Reading","text":""},{"location":"day_one/finding_docs/#command-references","title":"Command References","text":"<ul> <li><code>man find</code> \u2014 Full <code>find</code> options; <code>-maxdepth</code> limits search scope to avoid runaway searches</li> <li><code>man git-log</code> \u2014 Git history options for understanding what changed and when</li> <li><code>man git-blame</code> \u2014 Track down who last modified specific lines of a file</li> </ul>"},{"location":"day_one/finding_docs/#official-documentation","title":"Official Documentation","text":"<ul> <li>Git Documentation \u2014 Comprehensive Git reference; the <code>git log</code> formatting options are especially useful</li> <li>The Linux Documentation Project \u2014 Broad Linux reference including filesystem layout guides</li> </ul>"},{"location":"day_one/finding_docs/#related-articles","title":"Related Articles","text":"<ul> <li>Orientation \u2014 Initial server orientation covers how to identify what's running on an unfamiliar system</li> <li>Reading Logs \u2014 Once you find the logs, learn to read them effectively</li> </ul>"},{"location":"day_one/finding_docs/#whats-next","title":"What's Next?","text":"<p>You know how to find documentation and who to ask. Now let's put it into practice with Common First Tasks \u2014 the actual things you'll probably be asked to do on your first day with a new server.</p> <p>The Best Documentation Is a Conversation</p> <p>Don't be afraid to ask questions. Every senior engineer was once the new person who didn't know where anything was. Most people are happy to help.</p>"},{"location":"day_one/first_tasks/","title":"Common First Tasks","text":"<p>Part of Day One</p> <p>This is the seventh article in the Day One: Getting Started series. You should have already completed Getting Access, Orientation, Understanding Your Permissions, Safe Exploration, Reading Logs, and Finding Documentation.</p> <p>Your team lead sends you a message: \"Can you check if the API service is running?\"</p> <p>Or: \"The logs should show what's wrong.\"</p> <p>Or: \"Just verify the config looks correct.\"</p> <p>These are the tasks you'll actually be asked to do on your first day with a new server. Let's walk through them.</p>"},{"location":"day_one/first_tasks/#checking-if-a-service-is-running","title":"Checking If a Service Is Running","text":"<p>The ask: \"Is nginx running?\" / \"Can you check if the app is up?\"</p>"},{"location":"day_one/first_tasks/#using-systemctl-modern-linux","title":"Using systemctl (Modern Linux)","text":"Check Service Status<pre><code>systemctl status nginx\n</code></pre> <p>What to look for:</p> <pre><code>\u25cf nginx.service - A high performance web server\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled)\n   Active: active (running) since Mon 2024-01-15 10:00:00 UTC; 5 days ago\n   Main PID: 1234 (nginx)\n</code></pre> <ul> <li><code>Active: active (running)</code> \u2014 It's running \u2705</li> <li><code>Active: inactive (dead)</code> \u2014 It's stopped \u274c</li> <li><code>Active: failed</code> \u2014 It crashed \u274c</li> </ul>"},{"location":"day_one/first_tasks/#check-multiple-services","title":"Check Multiple Services","text":"Check Common Services<pre><code>systemctl status nginx\nsystemctl status mysql\nsystemctl status redis\nsystemctl status docker\n</code></pre>"},{"location":"day_one/first_tasks/#is-it-listening-on-the-expected-port","title":"Is It Listening on the Expected Port?","text":"<p>A service can be \"running\" but not actually accepting connections:</p> Check Listening Ports<pre><code>ss -tlnp | grep nginx\n# or\nnetstat -tlnp | grep :80\n</code></pre> <p>What you want to see:</p> <pre><code>LISTEN  0  511  0.0.0.0:80  0.0.0.0:*  users:((\"nginx\",pid=1234,fd=6))\n</code></pre> <p>If nothing shows up, the service isn't listening.</p>"},{"location":"day_one/first_tasks/#tailing-application-logs","title":"Tailing Application Logs","text":"<p>The ask: \"Check the logs and see what's happening\"</p> <p>Log reading is covered in depth in Reading Logs Like a Pro. Here are the quick commands for checking logs as part of a task:</p> Follow Logs in Real-Time<pre><code>tail -f /var/log/nginx/error.log\n</code></pre> <p>Reproduce the problem and watch for new entries. Press <code>Ctrl+C</code> to stop.</p> Service Logs with journalctl<pre><code>journalctl -u nginx -f\njournalctl -u app-name --since \"10 minutes ago\"\n</code></pre> <p>For time-windowed searches, common log formats, and error pattern analysis, see Reading Logs Like a Pro.</p>"},{"location":"day_one/first_tasks/#finding-configuration-files","title":"Finding Configuration Files","text":"<p>The ask: \"Can you check the config for [setting]?\"</p>"},{"location":"day_one/first_tasks/#common-config-locations","title":"Common Config Locations","text":"Application Config Location Nginx <code>/etc/nginx/nginx.conf</code>, <code>/etc/nginx/sites-enabled/</code> Apache <code>/etc/apache2/apache2.conf</code>, <code>/etc/apache2/sites-enabled/</code> MySQL <code>/etc/mysql/my.cnf</code> PostgreSQL <code>/etc/postgresql/*/main/postgresql.conf</code> SSH <code>/etc/ssh/sshd_config</code> System <code>/etc/</code> (most things) Applications <code>/opt/app-name/config/</code>, <code>/var/www/app/config/</code>"},{"location":"day_one/first_tasks/#read-a-config-file","title":"Read a Config File","text":"View Config<pre><code>cat /etc/nginx/nginx.conf\n# or for large files\nless /etc/nginx/nginx.conf\n</code></pre>"},{"location":"day_one/first_tasks/#search-for-a-specific-setting","title":"Search for a Specific Setting","text":"Find Setting in Config<pre><code>grep -r \"worker_processes\" /etc/nginx/\ngrep -r \"database\" /var/www/app/config/\n</code></pre>"},{"location":"day_one/first_tasks/#check-config-syntax-before-changes","title":"Check Config Syntax (Before Changes)","text":"<p>Many services can validate their config:</p> Validate Config (Read-Only)<pre><code>nginx -t\n# nginx: configuration file /etc/nginx/nginx.conf syntax is ok\n# nginx: configuration file /etc/nginx/nginx.conf test is successful\n\napache2ctl configtest\nmysql --help --verbose | grep \"Default options\"\n</code></pre>"},{"location":"day_one/first_tasks/#checking-whats-using-resources","title":"Checking What's Using Resources","text":"<p>The ask: \"The server is slow, can you see what's happening?\"</p>"},{"location":"day_one/first_tasks/#cpu-and-memory-overview","title":"CPU and Memory Overview","text":"Live System Monitor<pre><code>top\n</code></pre> <p>Quick reads:</p> <ul> <li>Look at the top processes \u2014 are any using 100% CPU?</li> <li>Check memory (Mem line) \u2014 is it nearly full?</li> <li>Check load average \u2014 above 1.0 per core means busy</li> </ul> <p>Press <code>q</code> to exit.</p>"},{"location":"day_one/first_tasks/#find-the-hungry-processes","title":"Find the Hungry Processes","text":"Top CPU Consumers<pre><code>ps aux --sort=-%cpu | head -10\n</code></pre> Top Memory Consumers<pre><code>ps aux --sort=-%mem | head -10\n</code></pre>"},{"location":"day_one/first_tasks/#check-disk-space","title":"Check Disk Space","text":"Disk Usage<pre><code>df -h\n</code></pre> <p>Red flag: Any filesystem at 90%+ usage.</p>"},{"location":"day_one/first_tasks/#whats-using-all-the-disk","title":"What's Using All the Disk?","text":"Find Large Directories<pre><code>du -sh /* 2&gt;/dev/null | sort -hr | head -10\n</code></pre> <p>Then drill down:</p> Drill Into Large Directory<pre><code>du -sh /var/* 2&gt;/dev/null | sort -hr | head -10\n</code></pre>"},{"location":"day_one/first_tasks/#checking-database-connectivity","title":"Checking Database Connectivity","text":"<p>The ask: \"Is the app connecting to the database?\"</p>"},{"location":"day_one/first_tasks/#test-mysqlmariadb-connection","title":"Test MySQL/MariaDB Connection","text":"Test MySQL Connection<pre><code>mysql -h localhost -u appuser -p -e \"SELECT 1;\"\n</code></pre> <p>If it connects, the database is accessible.</p>"},{"location":"day_one/first_tasks/#test-postgresql-connection","title":"Test PostgreSQL Connection","text":"Test PostgreSQL Connection<pre><code>psql -h localhost -U appuser -d dbname -c \"SELECT 1;\"\n</code></pre>"},{"location":"day_one/first_tasks/#check-from-application-perspective","title":"Check from Application Perspective","text":"<p>Look in the app logs for database errors:</p> Find Database Errors in Logs<pre><code>grep -i \"database\\|mysql\\|postgres\\|connection\" /var/log/app/error.log\n</code></pre> <p>Common errors:</p> <ul> <li>\"Connection refused\" \u2014 Database isn't running or wrong port</li> <li>\"Access denied\" \u2014 Wrong credentials</li> <li>\"Too many connections\" \u2014 Database overwhelmed</li> </ul>"},{"location":"day_one/first_tasks/#checking-external-connectivity","title":"Checking External Connectivity","text":"<p>The ask: \"Can the server reach [external service]?\"</p>"},{"location":"day_one/first_tasks/#basic-connectivity-test","title":"Basic Connectivity Test","text":"Ping External Host<pre><code>ping -c 4 google.com\nping -c 4 api.example.com\n</code></pre>"},{"location":"day_one/first_tasks/#test-http-endpoints","title":"Test HTTP Endpoints","text":"Test HTTP Connection<pre><code>curl -I https://api.example.com/health\n</code></pre> <p>What to look for:</p> <ul> <li><code>HTTP/1.1 200 OK</code> \u2014 It's working</li> <li><code>Connection refused</code> \u2014 Service is down or blocked</li> <li><code>Connection timed out</code> \u2014 Network issue or firewall</li> </ul>"},{"location":"day_one/first_tasks/#check-dns-resolution","title":"Check DNS Resolution","text":"Verify DNS Works<pre><code>nslookup api.example.com\n# or\ndig api.example.com\n</code></pre>"},{"location":"day_one/first_tasks/#test-specific-port","title":"Test Specific Port","text":"Test Port Connectivity<pre><code>nc -zv api.example.com 443\n# Connection to api.example.com 443 port [tcp/https] succeeded!\n</code></pre>"},{"location":"day_one/first_tasks/#checking-recent-deployments","title":"Checking Recent Deployments","text":"<p>The ask: \"When was the last deploy? What changed?\"</p>"},{"location":"day_one/first_tasks/#check-git-history","title":"Check Git History","text":"Recent Git Commits<pre><code>cd /var/www/app\ngit log --oneline -10\n</code></pre> What Changed Recently<pre><code>git log --since=\"24 hours ago\" --oneline\n</code></pre>"},{"location":"day_one/first_tasks/#check-file-modification-times","title":"Check File Modification Times","text":"Recently Modified Files<pre><code>find /var/www/app -type f -mtime -1 | head -20\n</code></pre>"},{"location":"day_one/first_tasks/#check-deployment-logs","title":"Check Deployment Logs","text":"Deployment Logs<pre><code>ls -la /var/log/deploy/\ntail -100 /var/log/deploy/deploy.log\n</code></pre>"},{"location":"day_one/first_tasks/#verifying-a-fix-worked","title":"Verifying a Fix Worked","text":"<p>The ask: \"Can you verify the fix worked?\"</p>"},{"location":"day_one/first_tasks/#check-service-status","title":"Check Service Status","text":"Verify Service Running<pre><code>systemctl status nginx\n</code></pre>"},{"location":"day_one/first_tasks/#check-logs-for-errors","title":"Check Logs for Errors","text":"Check for New Errors<pre><code>tail -f /var/log/nginx/error.log\n</code></pre> <p>Wait a minute, trigger some traffic, see if errors appear.</p>"},{"location":"day_one/first_tasks/#test-the-endpoint","title":"Test the Endpoint","text":"Test Application<pre><code>curl -s http://localhost/health | head -20\ncurl -I https://app.example.com/api/status\n</code></pre>"},{"location":"day_one/first_tasks/#monitor-for-a-few-minutes","title":"Monitor for a Few Minutes","text":"Watch Logs After Fix<pre><code>journalctl -u nginx -f\n</code></pre> <p>Watch for a few minutes. No errors? The fix probably worked.</p>"},{"location":"day_one/first_tasks/#task-quick-reference","title":"Task Quick Reference","text":"Task Command Check if service running <code>systemctl status servicename</code> Check listening ports <code>ss -tlnp</code> or <code>netstat -tlnp</code> Follow logs <code>tail -f /var/log/app/error.log</code> Find errors in logs <code>grep -i error /var/log/app/*.log</code> Check config file <code>cat /etc/nginx/nginx.conf</code> Find config setting <code>grep -r \"setting\" /etc/nginx/</code> Check CPU/memory <code>top</code> or <code>htop</code> Check disk space <code>df -h</code> Find large files <code>du -sh /* \\| sort -hr \\| head</code> Test connectivity <code>ping</code>, <code>curl</code>, <code>nc -zv</code> Recent deployments <code>git log --oneline -10</code>"},{"location":"day_one/first_tasks/#practice-exercises","title":"Practice Exercises","text":"Exercise 1: Check Whether a Service Is Healthy <p>Your team lead asks: \"Is nginx running and actually accepting connections?\" Check the service status AND verify it's listening on port 80.</p> <p>Hint: You need two commands \u2014 <code>systemctl</code> and <code>ss</code>.</p> Solution Check nginx Status and Port<pre><code>systemctl status nginx\nss -tlnp | grep :80\n</code></pre> <p>You want to see <code>Active: active (running)</code> from the first command, and a <code>LISTEN</code> entry on port 80 from the second. If the service is running but not listening, something is wrong with its configuration.</p> Exercise 2: Find What's Eating Disk Space <p><code>df -h</code> shows that <code>/var</code> is at 91% usage. Find the top 10 largest directories inside <code>/var</code>.</p> <p>Hint: Use <code>du</code> with appropriate flags, then sort.</p> Solution Find Large Directories in /var<pre><code>du -sh /var/* 2&gt;/dev/null | sort -hr | head -10\n</code></pre> <p><code>/var/log</code> is the usual culprit on busy servers. From there, drill deeper: Drill Into /var/log<pre><code>du -sh /var/log/* 2&gt;/dev/null | sort -hr | head -10\n</code></pre></p> Exercise 3: Verify a Fix Worked <p>After a colleague restarts a service, you're asked to confirm it's working. What's your verification process for nginx?</p> <p>Hint: Three steps \u2014 service status, port listening, no new errors in logs.</p> Solution Full nginx Health Check<pre><code># 1. Service is running\nsystemctl status nginx\n\n# 2. Listening on expected ports\nss -tlnp | grep nginx\n\n# 3. No new errors in last 50 lines\ntail -50 /var/log/nginx/error.log\n</code></pre> <p>Watch the logs for 30\u201360 seconds after the restart. A clean log with no new errors is a good sign.</p>"},{"location":"day_one/first_tasks/#quick-recap","title":"Quick Recap","text":"<p>Service checks:</p> <ol> <li><code>systemctl status</code> \u2014 Is it running?</li> <li><code>ss -tlnp</code> \u2014 Is it listening?</li> <li><code>tail -f</code> logs \u2014 Any errors?</li> </ol> <p>Resource checks:</p> <ol> <li><code>top</code> \u2014 CPU/memory overview</li> <li><code>df -h</code> \u2014 Disk space</li> <li><code>du -sh</code> \u2014 What's using space</li> </ol> <p>Connectivity checks:</p> <ol> <li><code>ping</code> \u2014 Basic reachability</li> <li><code>curl</code> \u2014 HTTP endpoints</li> <li><code>nc -zv</code> \u2014 Port connectivity</li> </ol>"},{"location":"day_one/first_tasks/#further-reading","title":"Further Reading","text":""},{"location":"day_one/first_tasks/#command-references","title":"Command References","text":"<ul> <li><code>man systemctl</code> \u2014 Full systemctl documentation including all unit states and sub-commands</li> <li><code>man ss</code> \u2014 Socket statistics; replaces the deprecated <code>netstat</code> on modern systems</li> <li><code>man top</code> \u2014 Interactive process viewer; press <code>h</code> inside <code>top</code> for a keyboard shortcut reference</li> <li><code>man df</code> \u2014 Disk free space; <code>-i</code> shows inode usage (a different way a filesystem can \"fill up\")</li> <li><code>man du</code> \u2014 Disk usage; <code>--max-depth</code> controls how many levels deep to report</li> <li><code>man curl</code> \u2014 HTTP client with extensive options for testing endpoints and APIs</li> </ul>"},{"location":"day_one/first_tasks/#official-documentation","title":"Official Documentation","text":"<ul> <li>systemd documentation \u2014 Comprehensive systemd and systemctl reference</li> <li>Red Hat: Managing Services with systemd \u2014 Practical systemd service management guide</li> </ul>"},{"location":"day_one/first_tasks/#related-articles","title":"Related Articles","text":"<ul> <li>Reading Logs \u2014 In-depth guide to log analysis; covers everything in the Tailing Logs section above and much more</li> <li>Safe Exploration \u2014 Reminder of which commands are safe to run on production without permission</li> </ul>"},{"location":"day_one/first_tasks/#whats-next","title":"What's Next?","text":"<p>You've learned what to do. Now let's cover what NOT to do. Head to The \"Don't Do This\" Guide for production safety rules that will keep you out of trouble.</p> <p>Write Down Your Findings</p> <p>When someone asks you to check something, report back with specifics:</p> <p>\"Nginx is running (PID 1234, up for 5 days). It's listening on port 80 and 443. The last error in the logs was 2 hours ago and looks like a client timeout, not a server issue.\"</p> <p>Much better than \"Yeah, it's fine.\"</p>"},{"location":"day_one/getting_access/","title":"Getting Access to Linux","text":"<p>Part of Day One</p> <p>This is the first practical article in the Day One: Getting Started series. If you're new to Linux, start there for the full roadmap.</p> <p>Before you can explore Linux, you need access to a Linux environment. There are two main scenarios:</p> <ul> <li>Scenario A: Someone gave you SSH credentials to an existing server</li> <li>Scenario B: You need to set up your own Linux environment for learning</li> </ul> <p>Pick your scenario below, complete the setup, then meet us at the validation checkpoint.</p> Scenario A: SSH to Existing ServerScenario B: Set Up Your Own Environment"},{"location":"day_one/getting_access/#connecting-via-ssh","title":"Connecting via SSH","text":"<p>Someone just handed you SSH credentials to a Linux server. Maybe it's an IP address scrawled on a sticky note, maybe it's in a Slack message, maybe it's buried in your onboarding docs. Let's get you connected.</p> <p>SSH (Secure Shell) is how you connect to remote Linux servers. It's encrypted, it's standard, and once you've done it a few times, it becomes second nature.</p>"},{"location":"day_one/getting_access/#what-youll-need","title":"What You'll Need","text":"<p>Before you connect, make sure you have:</p> <ul> <li>Hostname or IP address - Where's the server? (<code>192.168.1.100</code> or <code>server.example.com</code>)</li> <li>Username - Who are you logging in as? (often your company username)</li> <li>Password - Your login password</li> </ul>"},{"location":"day_one/getting_access/#choose-your-platform","title":"Choose Your Platform","text":"Linux / macOSWindows <p>Good news: SSH comes pre-installed on every Linux distribution and macOS. Open your terminal and you're ready to go.</p> SSH Connection Command<pre><code>ssh username@hostname\n</code></pre> <p>Real example:</p> Connecting to a Server<pre><code>ssh jsmith@192.168.1.100\n# or\nssh jsmith@staging.example.com\n</code></pre> <p>What happens next:</p> <ol> <li>First time connecting? You'll see a fingerprint warning (this is normal - type <code>yes</code>)</li> <li>Enter your password when prompted</li> <li>You're in! You should see the server's command prompt</li> </ol> Your Password Won't Show When You Type <p>When Linux asks for your password, nothing appears on screen - no characters, no asterisks, nothing.</p> <p>Don't panic. Your keyboard is working. Just type your password and press Enter. This is normal Linux behavior for security - it's not showing anything to prevent others from seeing how long your password is.</p> <p>Server Requires SSH Keys?</p> <p>If you're getting \"Permission Denied (Publickey)\" errors, see the Troubleshooting section below. SSH key setup will be covered in a future article.</p> <p>Windows has a few options for SSH. Pick the one that matches your setup:</p> Windows Terminal (Recommended)PuTTYWSL <p>Windows 10/11 includes OpenSSH by default. This is the easiest and most modern approach.</p> <p>Open Windows Terminal (or PowerShell) and use the same SSH commands:</p> SSH from Windows Terminal<pre><code>ssh username@hostname\n</code></pre> <p>Real example:</p> Connecting to a Server<pre><code>ssh jsmith@192.168.1.100\n# or\nssh jsmith@staging.example.com\n</code></pre> <p>What happens next:</p> <ol> <li>First time connecting? You'll see a fingerprint warning (type <code>yes</code>)</li> <li>Enter your password when prompted</li> <li>You're in! You should see the server's command prompt</li> </ol> Your Password Won't Show When You Type <p>When Linux asks for your password, nothing appears on screen - no characters, no asterisks, nothing.</p> <p>Don't panic. Your keyboard is working. Just type your password and press Enter. This is normal Linux behavior for security - it's not showing anything to prevent others from seeing how long your password is.</p> <p>That's it! Same syntax and behavior as Linux/Mac.</p> <p>PuTTY has been the Windows SSH client for decades. It's GUI-based and still popular.</p> <p>Download: PuTTY official site</p> <p>How to connect:</p> <ol> <li>Open PuTTY</li> <li>Enter your hostname or IP address</li> <li>Set port to 22 (or your custom port)</li> <li>Set connection type to \"SSH\"</li> <li>Click \"Open\"</li> <li>Enter your username when prompted</li> <li>Enter your password when prompted</li> </ol> Your Password Won't Show When You Type <p>When Linux asks for your password, nothing appears on screen - no characters, no asterisks, nothing.</p> <p>Don't panic. Your keyboard is working. Just type your password and press Enter. This is normal Linux behavior for security - it's not showing anything to prevent others from seeing how long your password is.</p> <p>Server Requires SSH Keys?</p> <p>If you're getting \"Permission Denied (Publickey)\" errors, see the Troubleshooting section below. SSH key setup for PuTTY will be covered in a future article.</p> <p>If you've installed Windows Subsystem for Linux, you've got full native SSH capabilities.</p> <p>Just open your WSL terminal (Ubuntu, Debian, etc.) and follow the Linux / macOS tab instructions above.</p> <p>This gives you the same experience as Linux users - SSH comes pre-installed and works identically.</p>"},{"location":"day_one/getting_access/#first-connection-the-fingerprint-warning","title":"First Connection - The Fingerprint Warning","text":"<p>The first time you connect to a server (regardless of platform), you'll see something scary:</p> <pre><code>The authenticity of host '192.168.1.100 (192.168.1.100)' can't be established.\nED25519 key fingerprint is SHA256:abc123def456...\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n</code></pre> <p>Don't panic. This is SSH asking \"Is this really the server you meant to connect to?\"</p> <p>Type <code>yes</code> and press Enter. SSH will remember this server and won't ask again (unless the server's key changes, which could indicate a security issue).</p>"},{"location":"day_one/getting_access/#ssh-with-a-specific-port","title":"SSH with a Specific Port","text":"<p>Most SSH servers listen on port 22, but some use custom ports for security. If your server uses a different port:</p> SSH on Custom Port<pre><code>ssh -p 2222 username@hostname\n</code></pre>"},{"location":"day_one/getting_access/#troubleshooting-common-ssh-issues","title":"Troubleshooting Common SSH Issues","text":"<p>Running into connection problems? Expand the issue you're seeing:</p> Connection Refused <p>What it means: SSH can't reach the server at all.</p> <p>Possible causes:</p> <ul> <li>Server might be down or unreachable</li> <li>Firewall blocking port 22</li> <li>Wrong IP address or hostname</li> <li>Not connected to VPN (if required)</li> </ul> <p>What to try:</p> Test Basic Connectivity<pre><code>ping hostname\n# or\nping 192.168.1.100\n</code></pre> <p>If ping fails, you have a network issue. Ask your team:</p> <ul> <li>Is the server running?</li> <li>Do I need VPN access?</li> <li>Is this the correct hostname/IP?</li> </ul> Connection Timeout <p>What it means: SSH is trying to connect but getting no response.</p> <p>Possible causes:</p> <ul> <li>Network issue - you might need to be on VPN</li> <li>Server is on a private network you don't have access to</li> <li>Firewall silently dropping packets</li> </ul> <p>What to try:</p> <ul> <li>Check if you need to connect to VPN first</li> <li>Verify you're on the correct network</li> <li>Ask your team about network access requirements</li> </ul> Permission Denied (Publickey) <p>What it means: Server requires SSH key authentication instead of password.</p> <p>Why this happens:</p> <ul> <li>Server is configured to only accept SSH keys (no password login)</li> <li>Your public key hasn't been added to the server yet</li> </ul> <p>What to do:</p> <p>Contact your team - they'll either:</p> <ul> <li>Enable password authentication for your account, or</li> <li>Tell you their process for getting SSH access (ticket system, send public key to team lead, etc.)</li> </ul> <p>Note: SSH key setup is covered in a future article. For now, work with your team to get initial access.</p> Host Key Verification Failed <p>What it means: The server's fingerprint has changed since you last connected.</p> <p>Why this happens:</p> <ul> <li>Server was rebuilt or reinstalled</li> <li>Server's SSH keys were regenerated</li> <li>Someone is trying to intercept your connection (rare but possible)</li> </ul> <p>What to try:</p> <p>\u26a0\ufe0f First, verify with your team that the server was recently rebuilt or changed. Don't ignore this warning!</p> <p>If confirmed safe, remove the old fingerprint:</p> Remove Old Fingerprint<pre><code>ssh-keygen -R hostname\n# or\nssh-keygen -R 192.168.1.100\n</code></pre> <p>Then try connecting again. You'll see the fingerprint warning (as if it's your first connection).</p>"},{"location":"day_one/getting_access/#setting-up-your-own-linux-environment","title":"Setting Up Your Own Linux Environment","text":"<p>You want to learn Linux but don't have a server to practice on? No problem. Pick the setup that matches your situation:</p> VirtualBox/VMware (Recommended)WSL2 (Windows Quick Start)Cloud ProviderPhysical Install <p>Best for: The best learning experience - full Linux with snapshots</p> <p>Why this is recommended: You get a complete Linux installation that you can break and restore in seconds. Perfect for learning.</p> <p>How it works: Linux runs in a virtual machine on your current OS (Windows, Mac, or Linux)</p> <p>Setup time: 30-60 minutes</p> <p>Get started:</p> <ol> <li>Download and install VirtualBox (free)</li> <li>Download Ubuntu Desktop ISO</li> <li>Follow Ubuntu's VM installation tutorial</li> </ol> Pros Cons Snapshots! Break something? Roll back in seconds Requires decent hardware (4GB+ RAM) Complete isolation from your main OS Takes disk space (20GB+ for VM) Works on Windows, Mac, or Linux Slightly longer initial setup Full Linux experience (desktop + terminal) Safe environment to experiment <p>Hardware requirements:</p> <ul> <li>4GB RAM minimum (8GB+ recommended)</li> <li>25GB free disk space</li> <li>CPU with virtualization support (most modern CPUs)</li> </ul> <p>Best for: Windows users who want Linux immediately</p> <p>How it works: Linux runs inside Windows - full Linux terminal, native speed</p> <p>Setup time: 5-10 minutes</p> <p>Get started: Microsoft's official WSL2 installation guide</p> Pros Cons Fastest setup - one command Windows 10/11 only No separate VM needed Not a complete server environment Access Windows and Linux files seamlessly No desktop environment (terminal only) Perfect for development work <p>When to choose this:</p> <ul> <li>You're on Windows and want to start immediately</li> <li>You primarily need the Linux command line</li> <li>You don't need a full GUI desktop</li> </ul> <p>Best for: Real server experience, accessible from anywhere</p> <p>How it works: Cloud provider gives you a small Linux server for free (with limitations and time restrictions)</p> <p>Setup time: 15-30 minutes</p> <p>Get started: Most major cloud providers offer free tiers - search for \"free tier\" at your preferred provider. You'll create an account, launch an instance, and SSH to it.</p> Pros Cons Real server environment Requires credit card (even for free tier) Access from anywhere Watch for costs after free period Learn cloud concepts Requires internet connection No hardware requirements SSH access only (no desktop GUI) <p>Important: Set up billing alerts immediately to avoid surprise charges when free period ends.</p> <p>Best for: People with a spare machine or ready to commit to dual-boot</p> <p>How it works: Install Linux directly on hardware (dedicated machine or dual-boot)</p> <p>Setup time: 1-2 hours</p> <p>Get started: Ubuntu installation guide</p> Pros Cons Full native performance Dual-boot can be tricky (backup first!) Complete Linux experience No easy rollback if you break something No virtualization overhead Requires compatible hardware Can repurpose old hardware More commitment than other options <p>Best use case: You have an old laptop/desktop you can dedicate to Linux learning.</p> <p>Have a Raspberry Pi?</p> <p>If you already own a Raspberry Pi, that's a great learning platform! Affordable (~$50-100), low power, and perfect for hands-on Linux learning.</p> <ul> <li>Raspberry Pi official documentation</li> <li>Note: Pi uses ARM architecture, which differs from typical x86 servers \u2014 though ARM is increasingly common in enterprise environments (AWS Graviton, Ampere cloud instances), so skills learned here transfer directly to modern production work</li> <li>Great for projects beyond just learning Linux</li> </ul>"},{"location":"day_one/getting_access/#why-we-recommend-vms","title":"Why We Recommend VMs","text":"<p>Virtual machines (VirtualBox/VMware) offer the best learning experience because:</p> <ul> <li>Snapshots - Take a snapshot before trying something risky, roll back if needed</li> <li>Safe experimentation - Break things without consequences</li> <li>Full Linux - Desktop + terminal, complete experience</li> <li>Professional relevance - Many professionals use VMs for testing</li> </ul> <p>All options will get you to the same Linux command line. Pick what fits your situation.</p>"},{"location":"day_one/getting_access/#validation-checkpoint","title":"Validation Checkpoint","text":"<p>Regardless of which path you took (SSH into a server or set up your own environment), let's verify you're ready to continue.</p> <p>Open your Linux terminal and run these commands:</p> Validation Test<pre><code>whoami\n# jsmith\n\npwd\n# /home/jsmith\n\nls\n# Documents  Downloads  projects\n</code></pre> <p>What these commands tell you:</p> <ul> <li><code>whoami</code> - Confirms your username (here: <code>jsmith</code>). This is your identity on the system.</li> <li><code>pwd</code> - Shows your current location in the filesystem (here: your home directory <code>/home/jsmith</code>). You start here when you log in.</li> <li><code>ls</code> - Lists what's in your current directory. An empty result is fine - it just means your home directory is empty.</li> </ul> <p>If all three commands work, you're ready!</p> <p>You have a working Linux environment. Time to learn what to do with it.</p>"},{"location":"day_one/getting_access/#practice-exercises","title":"Practice Exercises","text":"<p>Now that you're connected, let's reinforce what you've learned.</p> Exercise 1: Test Your Connection <p>Practice connecting to your Linux environment using the method you chose.</p> <p>Goal: Successfully connect and run <code>whoami</code> to verify you're logged in.</p> <p>For SSH users: Try connecting, then disconnecting, then reconnecting to build familiarity.</p> Solution <p>SSH users:</p> Connect to Your Server<pre><code>ssh username@hostname\n# Enter your password when prompted\n</code></pre> <p>Once connected:</p> Verify You're Logged In<pre><code>whoami\n# Should show your username\n</code></pre> <p>Local setup users:</p> <p>Just open your terminal (WSL, VirtualBox terminal, etc.) and run:</p> Verify Your Environment<pre><code>whoami\n# Should show your username\n</code></pre> Exercise 2: Understand Your Environment <p>Run the validation commands and interpret what each one tells you about your system.</p> <p>Tasks:</p> <ol> <li>Run <code>whoami</code> - What username are you using?</li> <li>Run <code>pwd</code> - Where in the filesystem are you?</li> <li>Run <code>ls -la</code> - What hidden files are in your home directory?</li> </ol> Solution Explore Your Environment<pre><code>whoami\n# Shows your current username\n\npwd\n# Shows your current working directory (usually /home/yourusername)\n\nls -la\n# Lists ALL files including hidden ones (starting with .)\n# You might see .bashrc, .profile, .ssh directory\n</code></pre> <p>What you learned: The <code>-la</code> flags mean \"long format\" and \"all files (including hidden)\". Hidden files in Linux start with a dot.</p>"},{"location":"day_one/getting_access/#further-reading","title":"Further Reading","text":""},{"location":"day_one/getting_access/#command-references","title":"Command References","text":"<ul> <li><code>man ssh</code> - Complete SSH manual; covers all connection options and flags</li> <li><code>man ssh_config</code> - Configuration file format for persistent SSH connection settings</li> </ul>"},{"location":"day_one/getting_access/#official-documentation","title":"Official Documentation","text":"<ul> <li>OpenSSH official documentation - Comprehensive SSH reference</li> <li>SSH Academy - SSH concepts and best practices</li> </ul>"},{"location":"day_one/getting_access/#related-articles","title":"Related Articles","text":"<ul> <li>Orientation - What to do immediately after you've connected</li> <li>Understanding Your Permissions - Know what you're allowed to do on the server</li> </ul>"},{"location":"day_one/getting_access/#whats-next","title":"What's Next?","text":"<p>You're in. You've got a Linux terminal in front of you. Now what?</p> <p>Head to First 60 Seconds: Orientation to learn what to do immediately after logging in\u2014checking who you are, what server you're on, and what resources are available.</p> <p>The next articles in Day One will also cover:</p> <ul> <li>Understanding Your Permissions - Know what you're allowed to do on the server</li> <li>Safe Exploration - How to look around without breaking things</li> <li>Reading Logs Like a Pro - Using <code>tail</code>, <code>grep</code>, and <code>journalctl</code> to understand what the system is telling you</li> </ul> <p>For now, try the Practice Exercises above to build familiarity with your new Linux environment.</p> <p>Bookmark This Page</p> <p>If you're using SSH or cloud instances, you might need to reconnect frequently. Bookmark this page so you can quickly reference connection commands.</p>"},{"location":"day_one/orientation/","title":"First 60 Seconds: Orientation","text":"<p>Part of Day One</p> <p>This is the second article in the Day One: Getting Started series. If you just got Linux access, start with Getting Access first.</p> <p>You're in. The SSH connection worked, and now you're staring at a blinking cursor on some Linux server. Maybe it looks like this:</p> <pre><code>[jsmith@prod-web-01 ~]$\n</code></pre> <p>Or maybe it's more cryptic. Either way, you're probably wondering: Where am I? What is this server? What do I do now?</p> <p>Let's orient ourselves.</p> <p>These first 60 seconds are about understanding your environment before you start poking around. Think of it like walking into a new office \u2014 you want to know where the exits are before you start moving furniture.</p>"},{"location":"day_one/orientation/#the-orientation-workflow","title":"The Orientation Workflow","text":"<p>Here's your path from login to confident exploration:</p> <pre><code>graph TD\n    A[\ud83d\udd10 Login] --&gt; B[\ud83d\udc64 Check Identity]\n    B --&gt; C[\ud83d\udda5\ufe0f Check Server Info]\n    C --&gt; D[\ud83d\udcbe Check Resources]\n    D --&gt; E[\ud83d\udc65 Check Other Users]\n    E --&gt; F[\u2705 Ready to Explore]\n\n    style A fill:#2d3748,stroke:#4a5568,color:#fff\n    style F fill:#48bb78,stroke:#38a169,color:#fff\n    style B fill:#4299e1,stroke:#3182ce,color:#fff\n    style C fill:#4299e1,stroke:#3182ce,color:#fff\n    style D fill:#4299e1,stroke:#3182ce,color:#fff\n    style E fill:#4299e1,stroke:#3182ce,color:#fff</code></pre> <p>Each step answers a critical question. Let's explore what you need to check.</p>"},{"location":"day_one/orientation/#what-you-need-to-check","title":"What You Need to Check","text":"<ul> <li> <p> Your Identity</p> <p>Why it matters: You need to know your privilege level before exploring. Do you have <code>sudo</code> access?</p> Check Who You Are<pre><code>whoami\n# jsmith\n\nid\n# uid=1001(jsmith) gid=1001(jsmith) groups=1001(jsmith),27(sudo)\n</code></pre> <p>Key insight: If you see <code>sudo</code> or <code>wheel</code> in your groups, you have elevated privileges. That's significant power\u2014use it carefully.</p> </li> <li> <p> Server Identity</p> <p>Why it matters: Know what server you're on before making any changes. Production? Staging? Dev?</p> What Server Is This?<pre><code>hostname\n# prod-web-01\n\ncat /etc/os-release | grep -E \"^NAME=|^VERSION=\"\n# NAME=\"Red Hat Enterprise Linux\"\n# VERSION=\"8.6 (Ootpa)\"\n</code></pre> <p>Key insight: Hostnames reveal purpose: <code>prod-web-01</code> = production, <code>staging-db</code> = staging database. Know before you act.</p> </li> <li> <p> Resource Check</p> <p>Why it matters: Don't run heavy operations on a struggling server. Check capacity before acting.</p> System Health Snapshot<pre><code>free -h\n# Available: 10Gi (check this number!)\n\ndf -h /\n# Use%: 45% (under 90% is good)\n\nuptime\n# load average: 0.15, 0.10, 0.08 (compare to CPU count)\n</code></pre> <p>Key insight: Low available memory (&lt;10%) or high disk usage (&gt;90%) means proceed carefully. High load (&gt;2\u00d7 CPU cores) means the server is busy.</p> </li> <li> <p> Who Else Is Here?</p> <p>Why it matters: If someone else is actively working, coordinate before making changes.</p> Check Other Users<pre><code>w\n# Shows who's logged in and what they're doing\n</code></pre> <p>Key insight: See someone with <code>IDLE</code> time of 0-5 minutes? They're actively working. Coordinate changes with them.</p> </li> </ul>"},{"location":"day_one/orientation/#common-scenarios","title":"Common Scenarios","text":"<p>Different situations call for different orientation checks. Pick your scenario:</p> Just Logged In - First 30 SecondsBefore Making ChangesManager Asked About ResourcesSomething Seems Wrong <p>Goal: Get your bearings immediately after connecting.</p> <p>You just need to know: Who am I, where am I, what server is this, and is it healthy?</p> Quick Orientation (30 seconds)<pre><code>whoami              # Your username\n# jsmith\n\npwd                 # Where am I in the filesystem?\n# /home/jsmith\n\nhostname            # Server name\n# prod-web-01\n\nuptime              # Is it healthy?\n# 14:23:01 up 47 days, 3:12, 2 users, load average: 0.15, 0.10, 0.08\n</code></pre> <p>What you learned:</p> <ul> <li>You're logged in as <code>jsmith</code></li> <li>You're in your home directory (<code>/home/jsmith</code>)</li> <li>This is the <code>prod-web-01</code> server</li> <li>It's been running 47 days with low load (healthy)</li> </ul> <p>Understanding Your Location</p> <p>When you log in, you start in your home directory:</p> <ul> <li>Regular users: <code>/home/username</code></li> <li>Root user: <code>/root</code></li> <li>Service accounts: Varies (often <code>/var/lib/servicename</code>)</li> </ul> <p>The <code>~</code> symbol is shorthand for your home directory. You'll see it in prompts like <code>[jsmith@server ~]$</code>.</p> <p>Next step: If load looks good and it's the right server, you're safe to explore.</p> <p>Goal: Safety check before modifying files, restarting services, or running commands.</p> <p>Before you change anything, verify three things: correct server, no high load, no active users.</p> Pre-Change Safety Check<pre><code>hostname            # Confirm correct server\n# prod-web-01       \u2713 Correct server\n\nw                   # Who else is here?\n# jsmith   pts/0    14:20    0.00s  -bash\n# admin    pts/1    09:45   4:30m   -bash    \u2190 Someone idle (safe)\n\nuptime              # Is it busy?\n# load average: 0.15, 0.10, 0.08    \u2190 Low load (safe to proceed)\n</code></pre> <p>Decision time:</p> <ul> <li>\u2705 Proceed: Load is low, other users are idle, correct server</li> <li>\u26a0\ufe0f Wait: Load is high (&gt;2\u00d7 CPU cores)\u2014find out why first</li> <li>\u26a0\ufe0f Coordinate: Other user has low idle time\u2014ask before changing things</li> </ul> <p>Goal: Report on server capacity and utilization.</p> <p>Your manager or team lead wants to know if the server has capacity for new workloads.</p> Resource Report Commands<pre><code># CPU capacity\nnproc\n# 4                  \u2190 4 CPU cores available\n\n# Memory status\nfree -h\n#               total        used        free      available\n# Mem:           15Gi       4.2Gi       8.1Gi        10Gi    \u2190 10Gi available for new work\n\n# Disk space\ndf -h | grep -vE \"tmpfs|devtmpfs\"\n# /dev/sda1       100G   45G   55G  45% /              \u2190 55GB free (55%)\n# /dev/sdb1       500G  320G  180G  64% /data          \u2190 180GB free (36%)\n\n# Current load\nuptime\n# load average: 0.15, 0.10, 0.08    \u2190 Very light load (0.15 on 4 cores = 3.75% utilization)\n\n# OS and kernel version\ncat /etc/os-release | grep -E \"^NAME=|^VERSION=\"\n# NAME=\"Red Hat Enterprise Linux\"\n# VERSION=\"8.6 (Ootpa)\"\n\nuname -r\n# 5.14.0-284.11.1.el9_2.x86_64      \u2190 Kernel version\n</code></pre> <p>What to report:</p> <ul> <li>CPU: 4 cores, currently at ~4% utilization (load 0.15)</li> <li>Memory: 15GB total, 10GB available for new processes</li> <li>Disk: Root filesystem 55% free (55GB), data volume 36% free (180GB)</li> <li>OS: Red Hat Enterprise Linux 8.6, kernel 5.14.0</li> <li>Assessment: Server has significant capacity for additional workloads</li> </ul> <p>Goal: Diagnose why the server feels slow or unresponsive.</p> <p>The server is sluggish or commands are taking forever. Check what's happening.</p> Health Diagnostics<pre><code># Check system load\nuptime\n# load average: 8.45, 7.23, 6.12    \u2190 High load! (on 4 cores = 2\u00d7 capacity)\n\n# Check memory pressure\nfree -h\n#               total        used        free      available\n# Mem:           15Gi        14Gi       512Mi       800Mi    \u2190 Low available memory!\n\n# Check disk space\ndf -h /\n# /dev/sda1       100G   98G   2.0G  98% /          \u2190 Disk almost full!\n\n# See what's running\ntop\n# Press 'q' to exit when done\n</code></pre> <p>Red flags:</p> <ul> <li>\u26a0\ufe0f High load (&gt;2\u00d7 CPU cores): Something is consuming CPU heavily</li> <li>\u26a0\ufe0f Low available memory (&lt;10%): System is memory-constrained</li> <li>\ud83d\udea8 Disk &gt;90% full: Critical\u2014things will start failing soon</li> </ul> <p>What to do:</p> <ul> <li>Don't make changes yet\u2014you could make it worse</li> <li>If load is the issue, <code>top</code> (already in the commands above) sorts processes by CPU at the top of the list \u2014 the culprit is usually the first entry. <code>htop</code> is a friendlier alternative if installed</li> <li>Document what you found (screenshot or copy the output)</li> <li>Escalate to your team: \"Server XYZ has [high load / low memory / full disk], top process is [name]\"</li> <li>Let experienced team members decide whether to intervene</li> </ul>"},{"location":"day_one/orientation/#quick-reference-checklist","title":"Quick Reference Checklist","text":"<p>Here's your first-60-seconds checklist:</p> Question Command What You Learn Who am I? <code>whoami</code> Your username What can I do? <code>id</code> Your groups and permissions Where am I? <code>pwd</code> Current directory What server is this? <code>hostname</code> Server name What OS? <code>cat /etc/os-release</code> Distribution and version How long running? <code>uptime</code> Uptime and load How much memory? <code>free -h</code> RAM usage How much disk? <code>df -h</code> Disk usage Who else is here? <code>w</code> Other logged-in users"},{"location":"day_one/orientation/#what-not-to-do-yet","title":"What NOT to Do Yet","text":"<p>You've oriented yourself. You know what server you're on, what resources it has, and who else is around.</p> <p>Resist the urge to:</p> <ul> <li>Start editing config files</li> <li>Restart any services</li> <li>Delete anything</li> <li>Run scripts you don't understand</li> </ul> <p>You're still in reconnaissance mode. Keep exploring safely \u2014 head to Safe Exploration to learn how to look around without breaking things.</p>"},{"location":"day_one/orientation/#practice-exercises","title":"Practice Exercises","text":"Exercise 1: Server Reconnaissance <p>Log into a server and gather the following information:</p> <ul> <li>Username and groups</li> <li>Hostname</li> <li>OS distribution and version</li> <li>Available memory</li> <li>Disk space usage</li> </ul> <p>Goal: Complete this in under 60 seconds.</p> Solution Quick Orientation Commands<pre><code>whoami\nid\nhostname\ncat /etc/os-release | grep -E \"^NAME=|^VERSION=\"\nfree -h\ndf -h\n</code></pre> <p>Tip: Create a shell alias or script to run these commands automatically on login.</p> Exercise 2: Interpret Load Average <p>A server shows: <code>load average: 8.45, 7.23, 6.12</code></p> <p>It has 4 CPU cores. Is this server:</p> <ul> <li>Relaxed</li> <li>Normal load</li> <li>Getting busy</li> <li>Critical?</li> </ul> <p>Hint: Compare the load to the number of cores.</p> Solution <p>Getting busy / Critical</p> <p>With 4 cores, a comfortable load is around 4.0. At 8.45, the server is handling twice its comfortable capacity. You should investigate what's consuming resources using <code>top</code> or <code>htop</code>.</p>"},{"location":"day_one/orientation/#quick-recap","title":"Quick Recap","text":"<p>Your first 60 seconds should answer:</p> <ol> <li>Who am I? \u2192 <code>whoami</code>, <code>id</code></li> <li>Where am I? \u2192 <code>pwd</code>, <code>hostname</code></li> <li>What is this? \u2192 <code>cat /etc/os-release</code>, <code>uname -a</code></li> <li>What resources? \u2192 <code>free -h</code>, <code>df -h</code>, <code>nproc</code></li> <li>How's it doing? \u2192 <code>uptime</code>, <code>top</code></li> <li>Who else is here? \u2192 <code>w</code></li> </ol>"},{"location":"day_one/orientation/#further-reading","title":"Further Reading","text":""},{"location":"day_one/orientation/#command-references","title":"Command References","text":"<ul> <li><code>man whoami</code> - User identity commands</li> <li><code>man uptime</code> - System uptime and load</li> <li><code>man free</code> - Memory usage reporting</li> <li><code>man df</code> - Disk space reporting</li> <li><code>man w</code> - Show who is logged in and what they're doing</li> <li><code>man uname</code> - Print system information</li> </ul>"},{"location":"day_one/orientation/#deep-dives","title":"Deep Dives","text":"<ul> <li>Understanding Linux Load Averages - Comprehensive explanation of load metrics</li> <li>Brendan Gregg's Linux Performance - Performance analysis tools and methodology</li> </ul>"},{"location":"day_one/orientation/#official-documentation","title":"Official Documentation","text":"<ul> <li>Red Hat Enterprise Linux Documentation - RHEL system administration guides</li> <li>Ubuntu Server Documentation - Ubuntu-specific server guides</li> <li>Debian Administrator's Handbook - Comprehensive Debian/Ubuntu reference</li> <li>The Linux Documentation Project - Guides, HOWTOs, and FAQs</li> <li>Linux Kernel Documentation - Official kernel documentation</li> </ul>"},{"location":"day_one/orientation/#whats-next","title":"What's Next?","text":"<p>Now that you know where you are and what you're working with, it's time to understand what you're actually allowed to do on this server. Head to Understanding Your Permissions to learn about your access level and how to use <code>sudo</code> safely.</p> <p>Once you've worked through Safe Exploration, continue to Reading Logs Like a Pro to learn how to diagnose problems on production systems.</p> <p>Make It a Habit</p> <p>Run these orientation commands every time you log into a new server. It takes 30 seconds and prevents a lot of confusion later.</p>"},{"location":"day_one/overview/","title":"Day One: Getting Started with Linux","text":"<p>Every Linux expert started exactly where you are. This is Day One.</p>"},{"location":"day_one/overview/#welcome-to-linux","title":"Welcome to Linux","text":"<p>This is your first time working with a Linux system, and you're probably feeling one of two ways:</p> <ul> <li>Excited: \"I've heard Linux runs everything! Time to learn!\"</li> <li>Nervous: \"I just got server access for work and have no idea what I'm doing...\"</li> </ul> <p>Both are valid. You're in the right place.</p> <p>This guide is for anyone starting their Linux journey\u2014whether someone handed you SSH credentials to a production server, or you're setting up your own Linux environment to learn and experiment.</p>"},{"location":"day_one/overview/#what-youll-learn","title":"What You'll Learn","text":"<p>By the end of Day One, you'll have these essential Linux skills:</p> Skill What You'll Master Getting Access Connect via SSH or set up your own Linux environment Orientation Know where you are, what server, who you are Permissions Understand your access level and use <code>sudo</code> safely Safe Exploration Look around without breaking things Reading Logs Use <code>tail</code>, <code>grep</code>, and <code>journalctl</code> effectively Finding Help Know where to look when stuck Avoiding Mistakes Common pitfalls that impact production"},{"location":"day_one/overview/#two-paths-one-destination","title":"Two Paths, One Destination","text":"<p>This guide acknowledges that people come to Linux from different starting points:</p>  SSH Access Local Setup <p>You have server credentials.</p> <p>Someone gave you an IP address, username, and password. Maybe it's a production server, staging environment, or cloud instance. You need to connect and start working\u2014safely.</p> <p>We'll cover: Connecting via SSH, orienting yourself on an unfamiliar system, understanding what you can and cannot do, and staying in read-only mode until you're comfortable.</p> <p>You're setting up your own environment.</p> <p>You want to learn Linux but don't have a server. You're choosing between WSL2, VirtualBox, cloud providers, or a physical install. You want a safe playground to experiment.</p> <p>We'll cover: Quick setup options with links to official guides, choosing what works for your situation, and validating your environment is ready.</p> <p>Either way: Once you've got access to a Linux terminal, you're on the same journey. The commands work the same, the concepts are identical, and you'll build the same foundational skills.</p>"},{"location":"day_one/overview/#who-this-is-for","title":"Who This Is For","text":"<ul> <li> <p> Perfect For</p> <p>Developers \u2014 First-time server access</p> <p>Junior DevOps \u2014 Starting your journey</p> <p>Students \u2014 Learning for class or career</p> <p>Hobbyists \u2014 Hands-on exploration</p> <p>Career Changers \u2014 Moving to systems work</p> </li> <li> <p> You Don't Need</p> <p>Prior Experience \u2014 We assume none</p> <p>CS Degree \u2014 Concepts explained clearly</p> <p>Command Memorization \u2014 We teach how to find help</p> <p>Fear \u2014 Safety emphasized throughout</p> </li> </ul>"},{"location":"day_one/overview/#the-articles","title":"The Articles","text":"<p>Work through these in order for the full Day One experience:</p> <ol> <li>Getting Access to Linux - Connect via SSH or set up your own environment</li> <li>First 60 Seconds: Orientation - Where am I? What is this server? Who am I?</li> <li>Understanding Your Permissions - What can I actually do here? Groups, <code>sudo</code>, and access levels</li> <li>Safe Exploration - How to look around without breaking things</li> <li>Reading Logs Like a Pro - <code>tail</code>, <code>journalctl</code>, and <code>grep</code></li> <li>Finding Documentation - Where's the team wiki? (coming soon)</li> <li>Common First Tasks - Checking status, finding configs (coming soon)</li> <li>The \"Don't Do This\" Guide - Safety rules for real systems (coming soon)</li> </ol> <p>Articles Publishing Soon</p> <p>Articles are being published as they're reviewed for quality. Start with Getting Access to get connected to a Linux system.</p>"},{"location":"day_one/overview/#the-philosophy","title":"The Philosophy","text":"<p>Throughout Day One, we emphasize safety and confidence. How you approach Linux depends on your environment:</p>  Production Systems Personal Systems <p>If you're working on a real server (production, staging, team infrastructure):</p> <ul> <li>You won't break production by looking at things. Reading logs, checking processes, exploring files\u2014these are safe operations.</li> <li>We stay read-only until you know more. No deleting files, no restarting services, no making changes until you understand the system.</li> <li>It's okay to ask questions. Everyone was new to this once. Your team would rather you ask than guess wrong.</li> </ul> <p>If you're learning on your own (VM, WSL2, personal server):</p> <ul> <li>Breaking things is how you learn. In a safe environment, mistakes are educational.</li> <li>You can always rebuild. VMs can be snapshotted and restored. WSL2 can be reset. Cloud instances can be deleted and recreated.</li> <li>Experimentation is encouraged. Try commands. See what happens. Learn by doing.</li> </ul>"},{"location":"day_one/overview/#our-teaching-approach","title":"Our Teaching Approach","text":"<p>Day One focuses on practical, immediate needs\u2014the skills you need in your first hours and days working with Linux.</p> <ul> <li>The \"Why\" \u2014 Understanding purpose, not just syntax</li> <li>Real Scenarios \u2014 Situations you'll actually encounter</li> <li>Finding Answers \u2014 How to help yourself when stuck</li> <li>Safety Habits \u2014 Practices that serve you forever</li> </ul>"},{"location":"day_one/overview/#whats-next","title":"What's Next?","text":"<p>Once you're comfortable navigating a Linux system and reading logs, you're ready for Level 1: Everyday Navigation. That's where you'll level up your command-line skills with the tools you'll use hundreds of times a day.</p>"},{"location":"day_one/overview/#ready","title":"Ready?","text":"<p>Start with Getting Access to Linux and we'll get you connected to a Linux system.</p> <p>Remember: The person who looks like a Linux wizard today? They had a Day One too. This is yours.</p>"},{"location":"day_one/permissions/","title":"Understanding Your Permissions","text":"<p>Part of Day One</p> <p>This is the third article in the Day One: Getting Started series. You should have already completed Getting Access and Orientation.</p> <p>You're logged in, you've oriented yourself, and now you're wondering: What am I actually allowed to do on this server?</p> <p>This is a crucial question. Enterprise servers have strict access controls for good reason \u2014 one wrong command with elevated privileges can bring down production. Before you start working, you need to understand your permission level.</p> <p>Let's figure out what powers you have (and don't have).</p>"},{"location":"day_one/permissions/#understanding-linux-permission-hierarchy","title":"Understanding Linux Permission Hierarchy","text":"<p>Here's how Linux organizes user permissions from most to least powerful:</p> <pre><code>graph TD\n    A[\"\ud83d\udd34 Root User (uid=0)&lt;br/&gt;&lt;br/&gt;Full System Access&lt;br/&gt;No Restrictions&lt;br/&gt;Can Break Everything\"]\n    B[\"\ud83d\udfe1 Regular User + Sudo&lt;br/&gt;&lt;br/&gt;Temporarily Become Root&lt;br/&gt;For Specific Commands&lt;br/&gt;Requires Authentication\"]\n    C[\"\ud83d\udfe2 Regular User&lt;br/&gt;&lt;br/&gt;Own Files Only&lt;br/&gt;Limited System Access&lt;br/&gt;Safest Default\"]\n\n    style A fill:#c92a2a,stroke:#ff6b6b,stroke-width:3px,color:#fff\n    style B fill:#d97706,stroke:#fbbf24,stroke-width:3px,color:#fff\n    style C fill:#2f9e44,stroke:#51cf66,stroke-width:3px,color:#fff</code></pre> <p>You are ONE of these. You don't \"escalate\" - you either have an identity (Regular or Root) and may have sudo permissions that let you temporarily run commands as root.</p>"},{"location":"day_one/permissions/#the-three-permission-levels","title":"The Three Permission Levels","text":"<p>On most servers, users fall into one of three categories:</p> Level What You Can Do Typical Users Regular User Only your own files, limited system access Most developers Sudo User Elevate to root for specific tasks Senior devs, junior admins Root Everything. No limits. Admins only (rarely used directly) <p>But before we figure out which one you are, you need to understand how Linux actually controls access to files.</p>"},{"location":"day_one/permissions/#understanding-file-permissions-rwx","title":"Understanding File Permissions (rwx)","text":"<p>Every file and directory on Linux has permissions that determine who can read, write, or execute it. This is the foundation of Linux security.</p>"},{"location":"day_one/permissions/#why-this-matters","title":"Why This Matters","text":"<p>Understanding file permissions explains:</p> <ul> <li>Why you can read some files but not others</li> <li>Why <code>cd /root</code> fails but <code>cd /home</code> works</li> <li>Why some scripts won't run even though you can read them (missing execute permission)</li> <li>Why you need <code>sudo</code> to edit system files</li> </ul> <p>Let's see this in action:</p> Check Permissions on Common Locations<pre><code>ls -ld /root\n# drwx------ 5 root root 4096 Jan 15 10:00 /root\n# Only root can access\n\nls -ld /home\n# drwxr-xr-x 5 root root 4096 Jan 15 10:00 /home\n# Everyone can list, only root can create users\n\nls -la /etc/shadow\n# -rw-r----- 1 root shadow 1234 Jan 15 10:00 /etc/shadow\n# Root can read/write, shadow group can read, others blocked\n</code></pre> <p>For Day One: You don't need to master all the details below. Just understand that those weird letter codes (<code>rwxr-xr-x</code>) control who can access what. Explore the tabs if you're curious.</p>"},{"location":"day_one/permissions/#the-details-optional-for-day-one","title":"The Details (Optional for Day One)","text":"The Basics Permission Types Common Patterns How Linux Checks <p>Every file has three pieces of permission information:</p> <ol> <li>Owner - The user who owns the file</li> <li>Group - The group that owns the file</li> <li>Permissions - What the owner, group, and others can do</li> </ol> <p>Check any file's permissions:</p> View File Permissions<pre><code>ls -la /etc/hosts\n# -rw-r--r-- 1 root root 220 Jan 15 10:00 /etc/hosts\n</code></pre> <p>Let's decode that permission string:</p> <pre><code>-rw-r--r-- 1 root root 220 Jan 15 10:00 /etc/hosts\n\u2502\u2514\u252c\u2518\u2514\u252c\u2518\u2514\u252c\u2518   \u2514\u2500\u252c\u2518 \u2514\u2500\u252c\u2500\u2518\n\u2502 \u2502  \u2502  \u2502      \u2502    \u2514\u2500\u2500 Group owner: root\n\u2502 \u2502  \u2502  \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500 File owner: root\n\u2502 \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Others: read only (r--)\n\u2502 \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Group: read only (r--)\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Owner: read+write (rw-)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 File type: regular file (-)\n</code></pre> <p>Each position can have one of three permissions:</p> Permission Symbol For Files For Directories Read <code>r</code> View file contents List directory contents Write <code>w</code> Modify file Create/delete files inside Execute <code>x</code> Run as program/script Enter the directory (<code>cd</code> into it) None <code>-</code> No access No access <p>Permissions are shown in groups of three: owner, group, others</p> <pre><code>rwxr-xr--\n\u2502\u2502\u2502\u2502\u2502\u2502\u2502\u2502\u2502\n\u2502\u2502\u2502\u2514\u252c\u2518\u2514\u252c\u2518\n\u2502\u2502\u2502 \u2502  \u2514\u2500\u2500\u2500 Others: read only (r--)\n\u2502\u2502\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500 Group: read + execute (r-x)\n\u2502\u2514\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Owner: read + write + execute (rwx)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 File type (d=directory, -=file, l=link)\n</code></pre> <p>Files:</p> <pre><code>-rw-r--r--  (644)  # Config files - owner writes, others read\n-rw-------  (600)  # Private files like SSH keys\n-rwxr-xr-x  (755)  # Executable scripts\n</code></pre> <p>Directories:</p> <pre><code>drwxr-xr-x  (755)  # Standard directory\ndrwx------  (700)  # Private directory (like home directories)\ndrwxrwxr-x  (775)  # Shared directory\n</code></pre> <p>Avoid 777 Permissions in Enterprise</p> <p>Files with <code>-rwxrwxrwx</code> (777) permissions mean anyone can read, write, and execute. This is a major security risk.</p> <p>In enterprise environments:</p> <ul> <li>Security scanning tools will flag 777 files</li> <li>Compliance audits will require remediation</li> <li>You may be asked to fix these immediately</li> </ul> <p>Never set 777 permissions on production systems. If you see them, it's usually a sign of improper configuration or a security issue that needs attention.</p> <p>Critical concept: Linux checks in order and stops at the first match.</p> <ol> <li>Are you the owner? \u2192 Use owner permissions (stop checking)</li> <li>Are you in the file's group? \u2192 Use group permissions (stop checking)</li> <li>Else \u2192 Use \"others\" permissions</li> </ol> <p>Example:</p> <pre><code>-rw-r----- 1 alice developers 1024 Jan 15 10:00 report.txt\n</code></pre> <ul> <li>alice (owner): Can read and write (<code>rw-</code>)</li> <li>bob (in developers group): Can only read (<code>r--</code>)</li> <li>charlie (not owner, not in group): No access (<code>---</code>)</li> </ul> <p>Important: Even if alice is ALSO in the developers group, she gets owner permissions (<code>rw-</code>), not group permissions. First match wins.</p> <p>Gotcha: sudo Group \u2260 File Access</p> <p>Being in the <code>sudo</code> group does not give you access to files you couldn't read before. <code>sudo</code> is a command that lets you run programs as root \u2014 it doesn't change the permission check on the file itself.</p> <ul> <li><code>cat /etc/nginx/nginx.conf</code> \u2192 Permission denied (you're not root, not in the nginx group)</li> <li><code>sudo cat /etc/nginx/nginx.conf</code> \u2192 Works, because <code>sudo</code> runs <code>cat</code> as root</li> </ul> <p>The file permissions didn't change. You temporarily borrowed a different identity to bypass them. This is one of the most common points of confusion on day one.</p>"},{"location":"day_one/permissions/#how-to-check-your-permission-level","title":"How to Check Your Permission Level","text":"<p>Now that you understand how file permissions work, let's figure out what level of access YOU have on this server.</p> <p>Use these commands to determine what access you have on the server:</p>  Check Your Groups Check Sudo Access <p>Your group memberships determine a lot about what you can do:</p> List Your Groups<pre><code>groups\n# jsmith sudo docker developers\n</code></pre> <p>Or with more detail:</p> Full Group Information<pre><code>id\n# uid=1001(jsmith) gid=1001(jsmith) groups=1001(jsmith),27(sudo),998(docker),1002(developers)\n</code></pre> <p>Key groups to look for:</p> Group What It Means <code>sudo</code> or <code>wheel</code> You can run commands as root <code>docker</code> You can run Docker commands without sudo <code>www-data</code> Web server access (read/write web files) <code>adm</code> Can read most log files Custom groups Team-specific access (ask your team what they mean) <p>No sudo/wheel group?</p> <p>If you don't see <code>sudo</code> or <code>wheel</code> in your groups, you're a regular user without root access. That's normal for many developer accounts \u2014 it's a security feature, not a limitation of your skills.</p> <p>The <code>sudo</code> command lets you run commands as root (the superuser). But having the <code>sudo</code> group doesn't always mean you can do everything.</p> <p>Check what <code>sudo</code> lets you do:</p> Check Sudo Permissions<pre><code>sudo -l\n</code></pre> <p>You might see:</p> <pre><code>User jsmith may run the following commands on prod-web-01:\n    (ALL : ALL) ALL\n</code></pre> <p>This means you can run any command as root. Full power.</p> <p>Or you might see something more restrictive:</p> <pre><code>User jsmith may run the following commands on prod-web-01:\n    (root) /usr/bin/systemctl restart nginx\n    (root) /usr/bin/tail /var/log/nginx/*\n</code></pre> <p>This means you can only restart <code>nginx</code> and read its logs \u2014 nothing else with <code>sudo</code>.</p> <p>Or you might see:</p> <pre><code>Sorry, user jsmith may not run sudo on prod-web-01.\n</code></pre> <p>No <code>sudo</code> for you. You're working with regular user permissions only.</p>"},{"location":"day_one/permissions/#what-permission-denied-actually-means","title":"What \"Permission Denied\" Actually Means","text":"<p>You'll inevitably see this error:</p> <pre><code>-bash: /etc/nginx/nginx.conf: Permission denied\n</code></pre> <p>Or:</p> <pre><code>cat: /var/log/secure: Permission denied\n</code></pre> <p>This isn't a bug \u2014 it's Linux protecting the system.</p> <p>Now you can use what you learned about file permissions to understand why. Check the file's permissions:</p> Check File Permissions<pre><code>ls -la /etc/nginx/nginx.conf\n# -rw-r----- 1 root nginx 2488 Jan 10 15:30 /etc/nginx/nginx.conf\n</code></pre> <p>Reading the permission string: <code>-rw-r-----</code></p> <ul> <li>Owner (root): read + write (<code>rw-</code>)</li> <li>Group (nginx): read only (<code>r--</code>)</li> <li>Others (you): no access (<code>---</code>)</li> </ul> <p>You're not root, and you're probably not in the nginx group. Linux checked the permissions and blocked you.</p>"},{"location":"day_one/permissions/#your-options-when-blocked","title":"Your Options When Blocked","text":"<ol> <li>You need to read it: Ask someone to add you to the right group, or use <code>sudo</code> if you have it</li> <li>You need to edit it: You almost certainly need <code>sudo</code> (or shouldn't be editing it)</li> <li>You're just exploring: Move on, find files you CAN read</li> </ol>"},{"location":"day_one/permissions/#when-to-ask-for-more-access","title":"When to Ask for More Access","text":"<p>You'll sometimes need permissions you don't have. Here's the right approach:</p> <p>DO:</p> <ul> <li>Ask your team lead or sysadmin politely</li> <li>Explain what you're trying to accomplish</li> <li>Request the minimum access you need</li> <li>Accept \"no\" gracefully \u2014 there may be good reasons</li> </ul> <p>DON'T:</p> <ul> <li>Try to hack around permission limits</li> <li>Ask for root access when you need to read one log file</li> <li>Get frustrated \u2014 permissions protect the system (and you)</li> </ul> <p>Example request:</p> <p>\"Hey, I need to read the nginx error logs to debug the API timeout issue. Can I get added to the <code>adm</code> group, or is there another way to access <code>/var/log/nginx/error.log</code>?\"</p> <p>Much better than \"I need root access.\"</p>"},{"location":"day_one/permissions/#enterprise-access-processes","title":"Enterprise Access Processes","text":"<p>In most companies, getting elevated access follows a formal process:</p>  Standard Environments Production Environments Example Workflow <p>Typical <code>sudo</code> access for dev/staging servers:</p> Aspect What to Expect Scope Specific servers or server groups (not blanket access) Approval Manager or team lead approval required Duration Time-limited, renewed periodically (quarterly/annually) Auditing All <code>sudo</code> commands logged and reviewable <p>Bottom line: You'll have reasonable access, but it's controlled and monitored.</p> <p>Stricter controls for production systems:</p> Feature How It Works ID Checkout Check out privileged IDs (not permanent <code>sudo</code>) Justification Must provide ticket number or business reason Time-Boxed Access expires after hours, not days Multiple Approvers May need manager + security team approval Auto-Revocation Access automatically removed when time expires <p>Bottom line: Production access is heavily restricted. Plan ahead.</p> <p>Typical enterprise access request:</p> <pre><code>graph TD\n    A[Submit Access Request&lt;br/&gt;ServiceNow, Jira, etc.] --&gt; B[Provide Justification&lt;br/&gt;Business reason + server list]\n    B --&gt; C[Manager Approval&lt;br/&gt;Direct manager reviews]\n    C --&gt; D[Security Review&lt;br/&gt;Security team validates]\n    D --&gt; E[Access Granted&lt;br/&gt;Limited scope, time-limited]\n    E --&gt; F[Monitoring Active&lt;br/&gt;All actions logged &amp; auditable]\n\n    style A fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style B fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style C fill:#d97706,stroke:#b45309,color:#fff\n    style D fill:#d97706,stroke:#b45309,color:#fff\n    style E fill:#2f855a,stroke:#276749,color:#fff\n    style F fill:#1a202c,stroke:#2d3748,color:#fff</code></pre> <p>Timeline: Expect 1-3 days for standard access, 3-7 days for production.</p> <p>Plan Ahead</p> <p>Don't wait until you urgently need access. Request it early in your project timeline, especially for production systems.</p>"},{"location":"day_one/permissions/#the-permissions-cheat-sheet","title":"The Permissions Cheat Sheet","text":"Task Check With What You Need Read a file <code>ls -la filename</code> Read (r) permission or <code>sudo</code> Edit a file <code>ls -la filename</code> Write (w) permission or <code>sudo</code> Run a script <code>ls -la script.sh</code> Execute (x) permission Access a directory <code>ls -la dirname</code> Execute (x) on directory Restart service <code>sudo -l</code> <code>sudo</code> with service permission Read protected logs <code>sudo -l</code> or group membership <code>adm</code> group or <code>sudo</code>"},{"location":"day_one/permissions/#practice-exercises","title":"Practice Exercises","text":"<p>Now that you understand permissions, try these hands-on exercises to build confidence:</p> Exercise 1: Check Your Access Level <p>Run the commands to determine your permission level on the server. Find out:</p> <ol> <li>What is your username?</li> <li>What groups are you in?</li> <li>Can you use <code>sudo</code>? If so, what can you <code>sudo</code>?</li> </ol> <p>Hint: Use <code>whoami</code>, <code>groups</code>, <code>id</code>, and <code>sudo -l</code>.</p> Solution Check Your Identity and Access<pre><code># Check your username\nwhoami\n\n# Check your groups\ngroups\n\n# Get detailed ID information\nid\n\n# Check sudo privileges\nsudo -l\n</code></pre> <p>What to note:</p> <ul> <li>Your username from <code>whoami</code></li> <li>Whether you see <code>sudo</code> or <code>wheel</code> in your groups</li> <li>What the <code>sudo -l</code> command shows (full access, limited access, or no access)</li> </ul> Exercise 2: Investigate a Permission Denied Error <p>Try to read a protected file (this is safe, it will just tell you \"no\"):</p> Try Reading a Protected File<pre><code>cat /etc/shadow\n</code></pre> <p>You'll get \"Permission denied.\" Now investigate why:</p> <ol> <li>Check the file's permissions with <code>ls -la /etc/shadow</code></li> <li>Who owns the file?</li> <li>What permissions does the owner have?</li> <li>What permissions do you (as \"others\") have?</li> </ol> <p>Challenge: Can you read it with <code>sudo</code> (if you have <code>sudo</code> access)?</p> Solution Investigate the Permissions<pre><code># Try to read (will fail)\ncat /etc/shadow\n# cat: /etc/shadow: Permission denied\n\n# Check why\nls -la /etc/shadow\n# -rw-r----- 1 root shadow 1234 Jan 15 10:00 /etc/shadow\n</code></pre> <p>Analysis:</p> <ul> <li>Owner: <code>root</code> (read+write)</li> <li>Group: <code>shadow</code> (read only)</li> <li>Others: no permissions (---)</li> <li>You're not root and not in the shadow group, so you're blocked</li> </ul> <p>With <code>sudo</code> (if available):</p> Read with Sudo<pre><code>sudo cat /etc/shadow\n# root:$6$random_hash...:18000:0:99999:7:::\n</code></pre> <p>Warning: The <code>/etc/shadow</code> file contains password hashes. In production, only read this if you have a legitimate reason.</p>"},{"location":"day_one/permissions/#quick-recap","title":"Quick Recap","text":"Scenario What to Do Commands First time on server Find your access level <code>groups</code> - What groups am I in?<code>sudo -l</code> - What can I sudo?<code>id</code> - Full identity info Permission denied error Investigate why <code>ls -la filename</code> - Check ownershipTry <code>sudo</code> if you have itAsk for access if needed Using <code>sudo</code> Use carefully Run minimum command neededDouble-check before EnterNever run unknown commands Need more access Follow process Ask team lead politelyExplain what you needRequest minimum required"},{"location":"day_one/permissions/#whats-next","title":"What's Next?","text":"<p>Now that you understand your permission level, you're ready to explore the server safely. Head to Safe Exploration to learn read-only exploration techniques\u2014how to look around without accidentally changing anything.</p> <p>Once you're comfortable exploring safely, head to Reading Logs Like a Pro \u2014 it's the most important debugging skill you'll develop for working on production Linux systems.</p> <p>Bookmark Your Access Level</p> <p>First time on a server, run <code>id</code> and <code>sudo -l</code> and make a mental note. Knowing your access level prevents frustration and keeps you from accidentally trying things that won't work.</p>"},{"location":"day_one/permissions/#further-reading","title":"Further Reading","text":""},{"location":"day_one/permissions/#command-references","title":"Command References","text":"<ul> <li><code>man sudo</code> - Complete <code>sudo</code> documentation with all options and configuration</li> <li><code>man id</code> - Display user and group identity information</li> <li><code>man groups</code> - Show group memberships</li> <li><code>man chmod</code> - Change file permissions (covered in depth in Level 3)</li> <li><code>man chown</code> - Change file ownership</li> <li><code>man ls</code> - List directory contents (the <code>-l</code> flag shows permissions)</li> <li><code>man find</code> - Search for files (the <code>-readable</code>, <code>-writable</code> flags filter by access)</li> </ul>"},{"location":"day_one/permissions/#deep-dives","title":"Deep Dives","text":"<ul> <li>Sudo Manual - Official <code>sudo</code> project documentation</li> <li>Understanding Linux File Permissions - Red Hat's comprehensive guide</li> <li>Principle of Least Privilege - Why systems limit access by default</li> <li>CIS Benchmarks - Industry-standard security configurations (includes <code>sudo</code> hardening)</li> <li>NIST: Least Privilege - Official definition and security guidance</li> </ul>"},{"location":"day_one/permissions/#official-documentation","title":"Official Documentation","text":"<ul> <li>Red Hat: Managing sudo access - Enterprise Linux <code>sudo</code> configuration</li> <li>Ubuntu Server Guide: User Management - Ubuntu-specific user and permission guidance</li> <li>Linux Documentation Project: Users and Groups - Classic reference on Linux user management</li> </ul>"},{"location":"day_one/reading_logs/","title":"Reading Logs Like a Pro","text":"<p>Part of Day One</p> <p>This is the fifth article in the Day One: Getting Started series. You should have already completed Getting Access, Orientation, Understanding Your Permissions, and Safe Exploration.</p> <p>Something broke. The app is throwing errors. Users are complaining. Your team lead says, \"Can you check the logs?\"</p> <p>And now you're staring at files full of timestamps and cryptic messages wondering where to even begin.</p> <p>Let's fix that.</p> <p>Reading logs is probably the most important skill for debugging production systems. Once you get comfortable with it, you'll be able to diagnose problems in minutes instead of hours.</p>"},{"location":"day_one/reading_logs/#the-investigation-workflow","title":"The Investigation Workflow","text":"<pre><code>graph TD\n    A[\"\ud83d\udea8 Something Is Broken\"] --&gt; B[\"Find the Logs&lt;br/&gt;ls -la /var/log/\"]\n    B --&gt; C[\"View Recent Entries&lt;br/&gt;tail -100 logfile\"]\n    C --&gt; D[\"Search for Errors&lt;br/&gt;grep -i error logfile\"]\n    D --&gt; E{\"Pattern Found?\"}\n    E --&gt;|Yes| F[\"Narrow the Time Window&lt;br/&gt;journalctl --since\"]\n    E --&gt;|No| G[\"Check Service Logs&lt;br/&gt;journalctl -u service\"]\n    G --&gt; D\n    F --&gt; H[\"\u2705 Root Cause Identified\"]\n\n    style A fill:#c92a2a,stroke:#ff6b6b,color:#fff\n    style H fill:#2f9e44,stroke:#51cf66,color:#fff\n    style B fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style C fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style D fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style E fill:#d97706,stroke:#b45309,color:#fff\n    style F fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style G fill:#2b6cb0,stroke:#2c5282,color:#fff</code></pre>"},{"location":"day_one/reading_logs/#where-are-the-logs","title":"Where Are the Logs?","text":"<p>Most logs live in <code>/var/log/</code>:</p> List Log Files<pre><code>ls -la /var/log/\n</code></pre> <p>Common log files:</p> Log File What It Contains <code>/var/log/syslog</code> or <code>/var/log/messages</code> General system logs <code>/var/log/auth.log</code> or <code>/var/log/secure</code> Authentication (logins, sudo) <code>/var/log/dmesg</code> Kernel messages (hardware, boot) <code>/var/log/nginx/</code> Nginx access and error logs <code>/var/log/apache2/</code> Apache logs <code>/var/log/mysql/</code> MySQL/MariaDB logs <p>Application-specific logs often live in:</p> <ul> <li><code>/var/log/appname/</code></li> <li><code>/opt/appname/logs/</code></li> <li><code>/home/appuser/logs/</code></li> <li>Wherever the app was configured to write them</li> </ul> <p>Ask your team: \"Where do the application logs live?\" Every app is different.</p>"},{"location":"day_one/reading_logs/#reading-common-log-formats","title":"Reading Common Log Formats","text":"<p>Before reaching for <code>tail</code> or <code>grep</code>, it helps to know what you're looking at. Log formats vary by application \u2014 here are the three most common:</p>  Syslog Format Nginx Access Log Nginx Error Log <p>General system events from Linux itself and most services follow this format:</p> <pre><code>Jan 15 14:23:45 prod-web-01 nginx[1234]: 2024/01/15 14:23:45 [error] ...\n</code></pre> Part Meaning <code>Jan 15 14:23:45</code> Timestamp <code>prod-web-01</code> Hostname (useful when logs are aggregated from multiple servers) <code>nginx[1234]</code> Service name and process ID Everything after <code>:</code> The actual message <p>Every HTTP request to your server leaves a line here:</p> <pre><code>192.168.1.50 - - [15/Jan/2024:14:23:45 +0000] \"GET /api/users HTTP/1.1\" 200 1234 \"-\" \"Mozilla/5.0...\"\n</code></pre> Part Meaning <code>192.168.1.50</code> Client IP address <code>[15/Jan/2024:14:23:45 +0000]</code> Timestamp <code>\"GET /api/users HTTP/1.1\"</code> HTTP method, path, and protocol <code>200</code> HTTP status code <code>1234</code> Response size in bytes <p>What to look for:</p> <ul> <li><code>4xx</code> codes \u2014 Client errors (404 not found, 401 unauthorized)</li> <li><code>5xx</code> codes \u2014 Server errors (500 internal error, 502 bad gateway)</li> </ul> Find All 500 Errors<pre><code>grep '\" 500 ' /var/log/nginx/access.log\n</code></pre> <p>When something goes wrong server-side, it ends up here:</p> <pre><code>2024/01/15 14:23:45 [error] 1234#0: *5678 connect() failed (111: Connection refused) while connecting to upstream\n</code></pre> <p>Unlike access logs, error logs are descriptive \u2014 the <code>[error]</code> level and the message tell you directly what went wrong. Look for words like <code>failed</code>, <code>refused</code>, <code>timeout</code>, and <code>upstream</code>.</p>"},{"location":"day_one/reading_logs/#the-essential-log-commands","title":"The Essential Log Commands","text":"View Recent Entries Watch Live Browse Large Files Check the Start <p>When to use: Something just broke and you want to see the last few dozen log lines.</p> <p>Most recent entries are at the bottom of a log file \u2014 start there:</p> Last 20 Lines<pre><code>tail -20 /var/log/syslog\n</code></pre> Last 100 Lines (for more history)<pre><code>tail -100 /var/log/nginx/error.log\n</code></pre> <p>Key insight: The number after <code>tail</code> controls how many lines you see. Start with 20-50 for a quick look; go up to 500 if the problem started a while ago.</p> <p>When to use: You want to reproduce the problem and watch errors appear in real-time.</p> <p>This is the killer feature \u2014 new log entries appear as they're written:</p> Follow Log in Real-Time<pre><code>tail -f /var/log/nginx/access.log\n</code></pre> <p>Trigger the problem (refresh the page, make an API call) and watch the entries appear live. Press <code>Ctrl+C</code> to stop.</p> <p>Follow multiple logs at once:</p> Watch Access and Error Logs Together<pre><code>tail -f /var/log/nginx/access.log /var/log/nginx/error.log\n</code></pre> <p>Key insight: Following multiple logs simultaneously lets you correlate access requests with errors \u2014 you can see which request triggered which error.</p> <p>When to use: The log file is huge and you need to scroll around, search, or read it like a document.</p> Open Log in Browser<pre><code>less /var/log/syslog\n</code></pre> <p>Navigation inside <code>less</code>:</p> Key Action <code>G</code> Jump to end (most recent entries) <code>g</code> Jump to beginning <code>/error</code> Search forward for \"error\" <code>n</code> Next search match <code>N</code> Previous search match <code>q</code> Quit <p>Key insight: Press <code>G</code> immediately after opening a large log to jump to the most recent entries \u2014 you almost never want to start at the beginning.</p> <p>When to use: You want to know when a log file was created, or check the log format before diving in.</p> First 20 Lines<pre><code>head -20 /var/log/syslog\n</code></pre> <p>Key insight: <code>head</code> is most useful for confirming the timestamp format a log uses before you try to <code>grep</code> for a specific time window \u2014 log formats vary between applications.</p>"},{"location":"day_one/reading_logs/#searching-logs-with-grep","title":"Searching Logs with grep","text":"<p><code>grep</code> is your search tool \u2014 it finds lines in a log file that match a pattern. Here are the flags you'll reach for most often:</p> Flag What It Does <code>-i</code> Case-insensitive (<code>error</code>, <code>Error</code>, <code>ERROR</code> all match) <code>-C N</code> Show N lines of Context before AND after each match <code>-B N</code> Show N lines Before each match <code>-A N</code> Show N lines After each match <code>-c</code> Count matches instead of printing them <code>-m N</code> Stop after the first N matches <code>-r</code> Search recursively through a directory <code>--line-buffered</code> Flush output immediately (required when piping to another command)"},{"location":"day_one/reading_logs/#find-all-errors","title":"Find All Errors","text":"<p>When to use: You want to see every line in a log file that mentions an error.</p> Find Error Lines<pre><code>grep -i \"error\" /var/log/syslog\n</code></pre> <p>Key insight: Always use <code>-i</code> unless you're intentionally filtering by case \u2014 logs are inconsistent about capitalisation (<code>error</code>, <code>Error</code>, and <code>ERROR</code> all appear in the wild).</p>"},{"location":"day_one/reading_logs/#find-errors-with-context","title":"Find Errors with Context","text":"<p>When to use: You found an error but need to understand what led up to it. Errors rarely happen in isolation.</p> Show Context Around Errors<pre><code>grep -i -C 3 \"error\" /var/log/nginx/error.log\n</code></pre> <p><code>-C 3</code> shows 3 lines before AND after each match. Use <code>-B</code> and <code>-A</code> separately when you need asymmetric context:</p> More History, Less After<pre><code>grep -i -B 5 -A 1 \"error\" /var/log/nginx/error.log\n</code></pre> <p>Key insight: The lines before an error are often more informative than the error line itself \u2014 they show what the system was doing when it failed.</p>"},{"location":"day_one/reading_logs/#recent-errors-only","title":"Recent Errors Only","text":"<p>When to use: The log file has been running for weeks and you only care about recent activity. Grepping a multi-gigabyte log is slow and buries current errors in historical noise.</p> Search Only Recent Log Entries<pre><code>tail -500 /var/log/nginx/error.log | grep -i \"error\"\n</code></pre> <p>Key insight: <code>tail</code> limits the data before <code>grep</code> even runs. Adjust the number to match how far back you need \u2014 <code>tail -100</code> for a quick check, <code>tail -2000</code> on a busy server where the problem started an hour ago.</p>"},{"location":"day_one/reading_logs/#find-by-timestamp","title":"Find by Timestamp","text":"<p>When to use: You know roughly when something happened and want to narrow the search to that window.</p> <p>First, check the timestamp format in your log \u2014 it varies between applications, and this is exactly where checking the format first with <code>head</code> pays off:</p> Check Timestamp Format First<pre><code>head -3 /var/log/syslog\n# Jan 15 14:23:45 prod-web-01 ...\n</code></pre> <p>Then grep for entries in that window:</p> Find Entries from Specific Time<pre><code>grep \"Jan 15 14:\" /var/log/syslog\n</code></pre> <p>Key insight: Be as specific as the format allows. <code>grep \"14:\"</code> is too broad; <code>grep \"Jan 15 14:3\"</code> narrows to a 10-minute window. For journalctl-managed logs, <code>--since</code> and <code>--until</code> (covered below) are usually easier.</p>"},{"location":"day_one/reading_logs/#search-multiple-files","title":"Search Multiple Files","text":"<p>When to use: You're not sure which log file contains the error, or you want to sweep an entire log directory at once.</p> Search All Logs in a Directory<pre><code>grep -r -i \"connection refused\" /var/log/nginx/\n</code></pre> Search All System Logs<pre><code>grep -r -i \"out of memory\" /var/log/\n</code></pre> <p>Key insight: <code>-r</code> prefixes every match with its filename \u2014 useful for discovering which log file is actually capturing the errors you're hunting.</p>"},{"location":"day_one/reading_logs/#count-occurrences","title":"Count Occurrences","text":"<p>When to use: You want to gauge the scale of a problem before diving into the details.</p> Count Error Occurrences<pre><code>grep -c \"connection refused\" /var/log/syslog\n# 47\n</code></pre> <p>Key insight: Start with <code>-c</code> to understand severity. Three occurrences might be noise; 47 in the last hour is worth dropping everything for. Once you know the scale, remove the <code>-c</code> to read the actual lines.</p>"},{"location":"day_one/reading_logs/#journalctl-the-modern-log-tool","title":"journalctl - The Modern Log Tool","text":"<p>On systems using systemd (most modern Linux), <code>journalctl</code> is incredibly powerful.</p> <p>Access Requirements</p> <p>On many systems, <code>journalctl</code> without <code>sudo</code> only shows logs for your own user. If you're getting empty output or \"permission denied\" errors, either run it with <code>sudo</code>, or ask your team to add you to the <code>systemd-journal</code> group \u2014 which grants read access to all system logs without needing full sudo.</p>"},{"location":"day_one/reading_logs/#view-all-recent-logs","title":"View All Recent Logs","text":"Recent System Logs<pre><code>journalctl -n 50\n</code></pre> <p>Shows the last 50 log entries from all services.</p>"},{"location":"day_one/reading_logs/#follow-logs-in-real-time","title":"Follow Logs in Real-Time","text":"Follow All Logs<pre><code>journalctl -f\n</code></pre> <p>Like <code>tail -f</code> but for all system logs at once.</p>"},{"location":"day_one/reading_logs/#view-logs-for-a-specific-service","title":"View Logs for a Specific Service","text":"<p>This is where journalctl shines:</p> Nginx Logs Only<pre><code>journalctl -u nginx\n</code></pre> MySQL Logs Only<pre><code>journalctl -u mysql\n</code></pre> SSH Logs Only<pre><code>journalctl -u sshd\n</code></pre>"},{"location":"day_one/reading_logs/#logs-since-a-specific-time","title":"Logs Since a Specific Time","text":"Logs from the Last Hour<pre><code>journalctl --since \"1 hour ago\"\n</code></pre> Logs from Today<pre><code>journalctl --since today\n</code></pre> Logs from Specific Time Range<pre><code>journalctl --since \"2024-01-15 14:00\" --until \"2024-01-15 15:00\"\n</code></pre>"},{"location":"day_one/reading_logs/#show-only-errors-and-warnings","title":"Show Only Errors and Warnings","text":"Errors and Above<pre><code>journalctl -p err\n</code></pre> <p>Priority levels: <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>err</code>, <code>warning</code>, <code>notice</code>, <code>info</code>, <code>debug</code></p>"},{"location":"day_one/reading_logs/#combine-service-and-time","title":"Combine Service and Time","text":"Recent Nginx Errors<pre><code>journalctl -u nginx --since \"1 hour ago\" -p err\n</code></pre> <p>This command says: \"Show me nginx errors from the last hour.\"</p>"},{"location":"day_one/reading_logs/#log-analysis-patterns","title":"Log Analysis Patterns","text":"<p>Pick the scenario that matches your situation:</p>  Something Broke at 2:30pm The App Keeps Crashing When Did This Start? Is It Still Happening? <p>Goal: Find out what was happening on the server around a specific time.</p> Investigate a Time Window<pre><code>journalctl --since \"14:25\" --until \"14:35\"\n</code></pre> <p>Or grep a log file directly if you know the format:</p> Grep for Time Window in Syslog<pre><code>grep \"14:3\" /var/log/syslog | less\n</code></pre> <p>Key insight: Check the log format first (with <code>head</code>) so you know what timestamp pattern to grep for \u2014 it varies between applications.</p> <p>Goal: Find which error is happening most often so you know where to start.</p> Find Most Common Errors<pre><code>grep -i \"error\" /var/log/app/error.log | sort | uniq -c | sort -rn | head -20\n</code></pre> <p>What this does: <code>sort</code> groups identical lines together, <code>uniq -c</code> counts them, <code>sort -rn</code> puts the most frequent first. Start investigating from the top.</p> <p>Goal: Find the very first occurrence of an error to establish a timeline.</p> Find First Occurrence<pre><code>grep -m 1 \"connection refused\" /var/log/syslog\n</code></pre> <p><code>-m 1</code> stops after the first match \u2014 without it, <code>grep</code> would print every occurrence. Once you have a timestamp, you can correlate it with deployments, config changes, or traffic spikes.</p> <p>Goal: Watch live to see if errors are still occurring right now.</p> Watch for Specific Error in Real-Time<pre><code>tail -f /var/log/syslog | grep --line-buffered \"error\"\n</code></pre> <p><code>--line-buffered</code> ensures matches appear immediately rather than waiting for a full buffer. If no new lines appear after reproducing the problem, you may be looking at the wrong log file.</p>"},{"location":"day_one/reading_logs/#accessing-protected-logs","title":"Accessing Protected Logs","text":"<p>Some logs are owned by root or a restricted group and will return \"Permission denied\" when you try to read them directly. You have two options:</p> View Protected Logs with Sudo<pre><code>sudo tail -100 /var/log/secure\nsudo journalctl -u sshd\n</code></pre> <p>Or, if you're in the <code>adm</code> group, you already have read access to most system logs without needing <code>sudo</code>. Check with <code>groups</code> \u2014 if <code>adm</code> isn't listed, ask your team to add you. See Understanding Your Permissions for how groups and log access work together.</p>"},{"location":"day_one/reading_logs/#quick-reference","title":"Quick Reference","text":""},{"location":"day_one/reading_logs/#most-used-commands","title":"Most Used Commands","text":"Log Reading Cheat Sheet<pre><code># Last 100 lines of a log\ntail -100 /var/log/syslog\n\n# Follow log in real-time\ntail -f /var/log/nginx/error.log\n\n# Search for errors\ngrep -i \"error\" /var/log/syslog\n\n# Service logs (systemd)\njournalctl -u nginx -n 100\n\n# Recent errors only\njournalctl --since \"1 hour ago\" -p err\n\n# Follow service logs\njournalctl -u nginx -f\n</code></pre>"},{"location":"day_one/reading_logs/#log-locations-cheat-sheet","title":"Log Locations Cheat Sheet","text":"What You're Looking For Where to Look General system events <code>/var/log/syslog</code> or <code>journalctl</code> Authentication/logins <code>/var/log/auth.log</code> or <code>journalctl -u sshd</code> Web server <code>/var/log/nginx/</code> or <code>/var/log/apache2/</code> Database <code>/var/log/mysql/</code> or <code>journalctl -u mysql</code> Application Ask your team!"},{"location":"day_one/reading_logs/#practice-exercises","title":"Practice Exercises","text":"Exercise 1: Find Recent Authentication Failures <p>You've been told that someone may be attempting to brute-force SSH logins. Check the last 200 lines of <code>/var/log/auth.log</code> and search for failed login attempts.</p> <p>Hint: Pipe <code>tail</code> into <code>grep</code>. The word to search for is \"Failed\".</p> Which log file? <p>On Debian/Ubuntu, authentication events are in <code>/var/log/auth.log</code>. On RHEL/CentOS/Fedora, the same file is <code>/var/log/secure</code>. Either way, the <code>grep</code> command and output are identical.</p> Solution Find Recent SSH Failures<pre><code>tail -200 /var/log/auth.log | grep \"Failed\"\n</code></pre> <p>You'll see lines like: <pre><code>Jan 15 14:23:11 prod-web-01 sshd[1234]: Failed password for invalid user admin from 192.168.1.100 port 54321 ssh2\n</code></pre></p> <p>Multiple failures from one IP address is a sign of a brute-force attempt. Report it to your security team.</p> Exercise 2: Find the Most Frequent Errors Today <p>The app has been logging errors all day. Use <code>journalctl</code> to get today's errors for the <code>nginx</code> service, then find which error message appears most often.</p> <p>Hint: Combine <code>journalctl</code>, <code>grep</code>, <code>sort</code>, <code>uniq -c</code>, and <code>sort -rn</code>.</p> Solution Most Common Nginx Errors Today<pre><code>journalctl -u nginx --since today -p err | sort | uniq -c | sort -rn | head -10\n</code></pre> <p><code>uniq -c</code> counts consecutive identical lines. <code>sort -rn</code> orders by count descending. The most common error appears first \u2014 start there.</p> Exercise 3: Investigate a Time Window <p>Your team lead says the app started throwing errors around 2:30pm. Use <code>journalctl</code> to show all system logs from 2:25pm to 2:40pm today.</p> <p>Hint: Use <code>--since</code> and <code>--until</code> with time strings.</p> Solution Investigate Time Window<pre><code>journalctl --since \"14:25\" --until \"14:40\"\n</code></pre> <p>Alternative \u2014 grep a log file directly: Grep Time Window in Syslog<pre><code>grep \"14:2[5-9]\\|14:3\" /var/log/syslog | less\n</code></pre></p>"},{"location":"day_one/reading_logs/#quick-recap","title":"Quick Recap","text":"<p>Start with the basics:</p> <ol> <li><code>tail -f /var/log/app.log</code> \u2014 Watch in real-time</li> <li><code>grep \"error\"</code> \u2014 Find the bad stuff</li> <li><code>journalctl -u servicename</code> \u2014 Service-specific logs</li> </ol> <p>Add context:</p> <ul> <li>Use <code>-B</code> and <code>-A</code> with grep for surrounding lines</li> <li>Use <code>--since</code> with journalctl for time windows</li> <li>Combine <code>tail</code> and <code>grep</code> for recent errors</li> </ul> <p>Think like a detective:</p> <ul> <li>When did it start?</li> <li>How often is it happening?</li> <li>What's the pattern?</li> </ul>"},{"location":"day_one/reading_logs/#further-reading","title":"Further Reading","text":""},{"location":"day_one/reading_logs/#command-references","title":"Command References","text":"<ul> <li><code>man tail</code> \u2014 Full options for <code>tail</code>; <code>--retry</code> is useful when following logs that rotate during an active <code>tail -f</code></li> <li><code>man journalctl</code> \u2014 Comprehensive reference; the <code>-o</code> output format options and <code>--output-fields</code> are particularly powerful</li> <li><code>man grep</code> \u2014 Full grep documentation; <code>-C</code> for context lines, <code>-P</code> for Perl-compatible regex in complex patterns</li> </ul>"},{"location":"day_one/reading_logs/#deep-dives","title":"Deep Dives","text":"<ul> <li>Brendan Gregg - Linux Performance \u2014 When logs point to performance issues, this is the definitive next stop</li> </ul>"},{"location":"day_one/reading_logs/#official-documentation","title":"Official Documentation","text":"<ul> <li>systemd journalctl \u2014 Authoritative journalctl reference from the systemd project</li> <li>Red Hat: Viewing and Managing Log Files \u2014 RHEL-specific log management guide</li> </ul>"},{"location":"day_one/reading_logs/#related-articles","title":"Related Articles","text":"<ul> <li>Orientation \u2014 Covers <code>hostname</code> and system identification if you're not sure which server's logs you're looking at</li> <li>Safe Exploration \u2014 Finding where application logs are stored on an unfamiliar server</li> </ul>"},{"location":"day_one/reading_logs/#whats-next","title":"What's Next?","text":"<p>You can read logs like a pro. The next skill is knowing where to find the team wiki, runbooks, and who to ask when logs alone aren't enough. Finding Documentation is coming soon. In the meantime, head back to the Day One Overview to review the full series.</p> <p>Logs Tell Stories</p> <p>Every log entry is a breadcrumb. Errors rarely happen in isolation \u2014 there's usually a chain of events. Learn to read that story, and debugging becomes much easier.</p>"},{"location":"day_one/safe_exploration/","title":"Safe Exploration","text":"<p>Part of Day One</p> <p>This is the fourth article in the Day One: Getting Started series. You should have already completed Getting Access, Orientation, and Understanding Your Permissions.</p> <p>You're logged in, you've oriented yourself, and you understand your permission level. Now you want to poke around \u2014 see what's on this server, find the application code, locate config files.</p> <p>But there's a voice in your head: \"What if I break something?\"</p> <p>Good instinct. Let's explore without touching anything.</p> <p>This article is about read-only reconnaissance. Looking without modifying. Finding things without moving them. By the end, you'll be able to confidently explore any server knowing you're not going to accidentally bring down production.</p>"},{"location":"day_one/safe_exploration/#the-exploration-workflow","title":"The Exploration Workflow","text":"<p>Here's your path to safely exploring a server:</p> <pre><code>graph TD\n    A[Start: You're Logged In] --&gt; B[List Directories&lt;br/&gt;ls, tree]\n    B --&gt; C[Read Files&lt;br/&gt;cat, less, head, tail]\n    C --&gt; D[Follow Logs&lt;br/&gt;tail -f]\n    D --&gt; E[Understand Server&lt;br/&gt;Confident &amp; Safe]\n\n    style A fill:#2d3748,stroke:#4a5568,color:#fff\n    style E fill:#2f855a,stroke:#276749,color:#fff\n    style B fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style C fill:#2b6cb0,stroke:#2c5282,color:#fff\n    style D fill:#2b6cb0,stroke:#2c5282,color:#fff</code></pre>"},{"location":"day_one/safe_exploration/#the-golden-rule-read-dont-write","title":"The Golden Rule: Read, Don't Write","text":"Safe Commands (Read-Only) Dangerous Commands (Modify Data) <p>These commands only read data - use them freely:</p> Command What It Does Safety Level <code>ls</code> List files and directories \u2705 Completely safe <code>tree</code> Show directory structure \u2705 Completely safe <code>cat</code>, <code>less</code> View file contents \u2705 Completely safe <code>head</code>, <code>tail</code> View beginning/end of files \u2705 Completely safe <code>pwd</code>, <code>cd</code> Check/change location \u2705 Completely safe <code>whoami</code>, <code>id</code> Check your identity \u2705 Completely safe <p>These commands change things - avoid during exploration:</p> Command What It Does Why It's Dangerous <code>rm</code> Delete files \u26a0\ufe0f Cannot be undone <code>mv</code> Move/rename files \u26a0\ufe0f Can overwrite files <code>cp</code> Copy files \u26a0\ufe0f Creates new files, uses disk space <code>chmod</code>, <code>chown</code> Change permissions \u26a0\ufe0f Can break access control <code>systemctl restart/stop</code> Modify services \ud83d\udea8 Can disrupt service <code>vim</code>, <code>nano</code> Open editor \u26a0\ufe0f Might accidentally save changes <code>&gt;</code> or <code>&gt;&gt;</code> Redirect output to file \u26a0\ufe0f Can overwrite or create files <code>sudo</code> anything Run as root \ud83d\udea8 Maximum impact if wrong"},{"location":"day_one/safe_exploration/#exploring-directories","title":"Exploring Directories","text":""},{"location":"day_one/safe_exploration/#look-before-you-leap","title":"Look Before You Leap","text":"<p>Before diving into a directory, peek at what's there:</p> List Directory Contents<pre><code>ls -la /var/log/\n</code></pre> <p>The <code>-la</code> flags give you the full picture:</p> <ul> <li><code>-l</code> \u2014 Long format (permissions, owner, size, date)</li> <li><code>-a</code> \u2014 Show hidden files (starting with <code>.</code>)</li> </ul>"},{"location":"day_one/safe_exploration/#what-those-columns-mean","title":"What Those Columns Mean","text":"<p>We covered permissions in detail in Understanding Your Permissions, but here's what you're seeing when you explore with <code>ls -la</code>:</p> <pre><code>drwxr-xr-x 2 root root 4096 Jan 15 10:30 nginx\n\u2502          \u2502 \u2502    \u2502    \u2502    \u2502            \u2514\u2500\u2500\u2500 Filename\n\u2502          \u2502 \u2502    \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Last modified (when changed)\n\u2502          \u2502 \u2502    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Size in bytes\n\u2502          \u2502 \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Group\n\u2502          \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Owner\n\u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  Link count\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  Permissions (d=dir, -=file, see previous article for rwx details)\n</code></pre> <p>For exploration, focus on: filename, size, and last modified date. These tell you what's here, how big it is, and how recent it is.</p>"},{"location":"day_one/safe_exploration/#explore-directory-trees","title":"Explore Directory Trees","text":"<p>See the structure without opening files:</p> Show Directory Tree<pre><code>tree /var/www/ -L 2\n</code></pre> <pre><code>/var/www/\n\u251c\u2500\u2500 html\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 assets\n\u2514\u2500\u2500 app\n    \u251c\u2500\u2500 config\n    \u2514\u2500\u2500 logs\n</code></pre> <p>The <code>-L 2</code> limits depth to 2 levels (so you don't dump thousands of files).</p> tree Not Installed? <p>Some minimal servers don't have <code>tree</code>. Use this alternative:</p> Tree Alternative<pre><code>find /var/www -maxdepth 2 -type d\n</code></pre>"},{"location":"day_one/safe_exploration/#reading-files-safely","title":"Reading Files Safely","text":""},{"location":"day_one/safe_exploration/#quick-peek-at-small-files","title":"Quick Peek at Small Files","text":"View Entire File<pre><code>cat /etc/hostname\n# prod-web-01\n</code></pre> <p>Good for small files. Bad for large files (it dumps everything to your terminal).</p>"},{"location":"day_one/safe_exploration/#browse-large-files","title":"Browse Large Files","text":"<p>For anything more than a few lines, use <code>less</code>:</p> Browse with less<pre><code>less /var/log/syslog\n</code></pre> <p>Navigation in <code>less</code>:</p> Key Action <code>Space</code> Page down <code>b</code> Page up <code>g</code> Go to beginning <code>G</code> Go to end <code>/pattern</code> Search forward <code>n</code> Next search match <code>q</code> Quit"},{"location":"day_one/safe_exploration/#view-just-the-beginning-or-end","title":"View Just the Beginning or End","text":"<p>Often you don't need to see the entire file\u2014just the start to check format, or the end to see recent activity.</p>  Beginning (<code>head</code>) End (<code>tail</code>) Headers + Recent <p>When to use this:</p> <ul> <li>Check file format or headers (CSV files, config files)</li> <li>See the shebang line in scripts (<code>#!/bin/bash</code>)</li> <li>Preview what a file contains without opening it all</li> <li>Check documentation structure (README files, man pages)</li> </ul> First 20 Lines<pre><code>head -n 20 /var/log/nginx/access.log\n</code></pre> First 10 Lines (default)<pre><code>head /etc/hosts\n</code></pre> <p>When to use this:</p> <ul> <li>Most common: View recent log entries (logs append to the end)</li> <li>See the latest errors or activity</li> <li>Check if a process recently wrote to a file</li> <li>Find the current state vs historical data</li> </ul> Last 20 Lines<pre><code>tail -n 20 /var/log/nginx/access.log\n</code></pre> Last 50 Lines<pre><code>tail -n 50 /var/log/nginx/error.log\n</code></pre> Last 10 Lines (default)<pre><code>tail /var/log/syslog\n</code></pre> <p>Advanced Pattern - Don't Worry About Memorizing This</p> <p>This is a handy trick once you're comfortable with <code>head</code> and <code>tail</code>. For Day One, just knowing the basic commands is enough!</p> <p>When to use this:</p> <ul> <li>See column headers plus the most recent entries (filesystem usage, process lists)</li> <li>Check table structure and latest data without scrolling through everything</li> <li>Common pattern: \"Show me what the columns mean and the last few entries\"</li> </ul> Filesystem Headers + Last 3 Mounts<pre><code>df -h | { head -n 1; tail -n 3; }\n# Filesystem      Size  Used Avail Use% Mounted on\n# /dev/sda5       100G   45G   50G  48% /data\n# /dev/sdb1       500G  320G  180G  64% /backups\n# tmpfs           7.8G     0  7.8G   0% /run/user/1000\n</code></pre> <p>What you see: The header row explaining the columns, then just the last 3 filesystem mounts\u2014skipping everything in between.</p> Process List Headers + Last 5 Processes<pre><code>ps aux | { head -n 1; tail -n 5; }\n</code></pre> How It Works<pre><code># The { } groups commands together\n# head -n 1 shows the header row\n# tail -n 3 shows the last 3 lines\n# Together: header + recent entries\n</code></pre> <p>Pro tip: This pattern works great with any command that outputs tables with headers.</p>"},{"location":"day_one/safe_exploration/#follow-a-file-in-real-time","title":"Follow a File in Real-Time","text":"<p>This is incredibly useful for watching logs as they're being written:</p> <p>Using <code>tail -f</code> (most common):</p> Watch Log Updates Live<pre><code>tail -f /var/log/nginx/access.log\n</code></pre> <p>New lines appear as they're written. Press <code>Ctrl+C</code> to stop.</p> <p>Using <code>less</code> + <code>F</code> key:</p> <p>If you're already viewing a file in <code>less</code>, press <code>F</code> to enter follow mode (same as <code>tail -f</code>). Press <code>Ctrl+C</code> to stop following and return to normal <code>less</code> navigation.</p> View File, Then Follow<pre><code>less /var/log/nginx/access.log\n# Press F to start following\n# Press Ctrl+C to stop following\n# Press q to quit less\n</code></pre> <p>When to use which:</p> <ul> <li>Use <code>tail -f</code> when you know you want to follow from the start</li> <li>Use <code>less</code> + <code>F</code> when you're browsing a file and decide you want to follow it</li> </ul>"},{"location":"day_one/safe_exploration/#safe-exploration-checklist","title":"Safe Exploration Checklist","text":"<p>Before running any command, ask yourself:</p> Question If Yes... Does this command have <code>rm</code>, <code>mv</code>, or <code>&gt;</code> in it? Stop. Review carefully. Does this require <code>sudo</code>? Double-check you need it. Am I opening an editor (<code>vim</code>, <code>nano</code>)? Be careful not to save accidentally. Does this command modify a service? Don't run it during exploration. Am I just reading/viewing data? You're probably fine!"},{"location":"day_one/safe_exploration/#common-day-one-exploration-tasks","title":"Common Day One Exploration Tasks","text":"What's in This Directory? Where Are the Logs? What's in This File? List Everything with Details<pre><code>ls -la\n</code></pre> <p>Look for:</p> <ul> <li>Files and directories (first column: <code>-</code> = file, <code>d</code> = directory)</li> <li>File sizes (helpful to know before opening)</li> <li>Last modified dates (when was this last touched?)</li> </ul> <p>Logs are almost always in <code>/var/log/</code>:</p> Explore Log Directory<pre><code>ls -la /var/log/\n</code></pre> <p>Common log files you'll see:</p> <ul> <li><code>syslog</code> - System messages</li> <li><code>auth.log</code> - Authentication attempts</li> <li><code>kern.log</code> - Kernel messages</li> <li>Application-specific directories (nginx/, apache2/, etc.)</li> </ul> <p>Quick peek at a file:</p> View a Small File<pre><code>cat /etc/hostname\n</code></pre> <p>Browse a larger file:</p> Browse with less<pre><code>less /var/log/syslog\n</code></pre> <p>See just the end (for logs):</p> Last 20 Lines<pre><code>tail -n 20 /var/log/syslog\n</code></pre>"},{"location":"day_one/safe_exploration/#practice-exercises","title":"Practice Exercises","text":"<p>Now that you know how to explore safely, try these hands-on exercises:</p> Exercise 1: Explore a Directory <p>Navigate to <code>/var/log</code> and explore its structure without opening any files.</p> <ol> <li>List all files and directories with details</li> <li>Notice the file sizes and dates</li> <li>Try using <code>tree</code> if available</li> </ol> <p>Hint: Use <code>ls -la</code> and optionally <code>tree</code>.</p> Solution Explore /var/log<pre><code># List everything with details\nls -la /var/log\n\n# Show directory tree (if tree is installed)\ntree /var/log -L 2\n</code></pre> <p>What to notice: - Directory vs file (first column: <code>d</code> = directory, <code>-</code> = file) - File sizes (some logs can be very large) - Last modified dates (when was this last touched?) - Ownership (most owned by root or specific service accounts)</p> Exercise 2: Read a Log File <p>Look at the system log to see what's been happening on the server.</p> <ol> <li>View the last 20 lines of <code>/var/log/syslog</code> (or <code>/var/log/messages</code> on some systems)</li> <li>Follow the log in real-time for a few seconds</li> </ol> <p>Hint: Use <code>tail</code> with <code>-n 20</code> and <code>-f</code> flags.</p> Solution View Recent System Logs<pre><code># See the last 20 lines\ntail -n 20 /var/log/syslog\n\n# Follow in real-time (press Ctrl+C to stop)\ntail -f /var/log/syslog\n</code></pre> <p>What to notice: - Timestamps on each log line - Service names (what's generating these messages) - Different message types (info, warning, error)</p> Exercise 3: Explore Your Home Directory <p>Get familiar with where your personal files live.</p> <ol> <li>List all files in your home directory (including hidden files)</li> <li>Look at the structure with <code>tree</code> if available</li> <li>Use <code>less</code> to browse your <code>.bashrc</code> or <code>.profile</code> file</li> </ol> <p>Hint: Use <code>cd ~</code> to go home, then <code>ls -la</code> to list everything.</p> Solution Explore Your Home<pre><code># Go to your home directory\ncd ~\n\n# List everything including hidden files\nls -la\n\n# View directory tree\ntree -L 1\n\n# Browse your bash config (read-only, safe)\nless .bashrc\n</code></pre> <p>What to notice: - Hidden files start with <code>.</code> (like <code>.bashrc</code>, <code>.profile</code>) - Your home directory is your personal workspace - Config files here customize your terminal experience</p>"},{"location":"day_one/safe_exploration/#day-one-exploration-cheat-sheet","title":"Day One Exploration Cheat Sheet","text":"<p>Now that you've learned the commands, here's a quick reference for common Day One tasks:</p> Task Safe Commands What to Look For Avoid Explore a directory <code>ls -la</code><code>tree -L 2</code> File sizes, dates, permissions <code>rm</code>, <code>mv</code> - Don't delete or move Find logs <code>ls -la /var/log/</code> syslog, auth.log, app directories Don't modify or delete logs Read a file <code>cat filename</code><code>less filename</code><code>head -n 20 filename</code><code>tail -n 20 filename</code> File contents, structure, recent entries <code>vim</code>, <code>nano</code> - Don't edit accidentally Follow logs live <code>tail -f /var/log/syslog</code><code>less</code> then press <code>F</code> Real-time updates, errors as they happen <code>&gt;</code>, <code>&gt;&gt;</code> - Don't redirect to files When unsure Use <code>command --help</code> Command documentation Never run with <code>sudo</code> unless certain <p>Golden rule: If you're just looking, you're safe. If you're changing, stop and think.</p>"},{"location":"day_one/safe_exploration/#quick-recap","title":"Quick Recap","text":"<p>The golden rule: Read-only commands can't break things. Stay in that lane during Day One.</p> <ul> <li>Navigate: <code>ls -la</code> to list, <code>tree -L 2</code> for structure</li> <li>Read files: <code>cat</code> for small files, <code>less</code> for large ones, <code>head</code>/<code>tail</code> for beginning or end</li> <li>Watch live: <code>tail -f</code> to follow a log as it's written</li> <li>Before you open: Run <code>ls -la filename</code> first \u2014 file size tells you whether <code>cat</code> is safe or whether you need <code>less</code></li> </ul> <p>See the cheat sheet above for a full command reference.</p>"},{"location":"day_one/safe_exploration/#further-reading","title":"Further Reading","text":""},{"location":"day_one/safe_exploration/#command-references","title":"Command References","text":"<ul> <li><code>man ls</code> - List directory contents with all options</li> <li><code>man less</code> - View file contents interactively</li> <li><code>man cat</code> - Display file contents</li> <li><code>man head</code> - Output the first part of files</li> <li><code>man tail</code> - Output the last part of files</li> <li><code>man tree</code> - Display directory trees</li> </ul>"},{"location":"day_one/safe_exploration/#deep-dives","title":"Deep Dives","text":"<ul> <li>Explain Shell - Visual breakdown of shell commands</li> <li>TLDR Pages - Simplified command examples</li> <li>Linux Journey: Command Line - Interactive learning path</li> <li>OverTheWire: Bandit - Security wargame for learning Linux commands safely in a controlled environment</li> </ul>"},{"location":"day_one/safe_exploration/#official-documentation","title":"Official Documentation","text":"<ul> <li>GNU Coreutils Manual - Official docs for <code>ls</code>, <code>cat</code>, <code>head</code>, <code>tail</code>, etc.</li> </ul>"},{"location":"day_one/safe_exploration/#whats-next","title":"What's Next?","text":"<p>Now that you can explore safely, head to Reading Logs Like a Pro \u2014 learning to read logs is the most powerful skill you'll develop for diagnosing problems on production systems.</p>"},{"location":"day_one/safety_guide/","title":"The \"Don't Do This\" Guide","text":"<p>Part of Day One</p> <p>This is the final article in the Day One: Getting Started series. Read this before making any changes to a production server.</p> <p>You've learned what to do on a production server. Now let's talk about what not to do.</p> <p>These aren't hypothetical dangers. Every rule here exists because someone (often a very smart someone) made this mistake and caused an outage. Learn from their pain.</p> <p>Read this before you do anything with <code>sudo</code>.</p>"},{"location":"day_one/safety_guide/#the-cardinal-rules","title":"The Cardinal Rules","text":""},{"location":"day_one/safety_guide/#rule-1-dont-run-commands-you-dont-understand","title":"Rule 1: Don't Run Commands You Don't Understand","text":"<p>Someone in a forum says \"just run this\":</p> DO NOT RUN THIS<pre><code>curl -s http://sketchy-site.com/fix.sh | sudo bash\n</code></pre> <p>Never do this. You're downloading and executing unknown code with root privileges.</p> <p>Even if the command looks harmless, understand what it does before running it:</p> <ul> <li><code>rm</code> deletes things</li> <li><code>&gt;</code> overwrites files</li> <li><code>chmod 777</code> makes everything writable by everyone</li> <li><code>dd</code> can destroy disks</li> </ul> <p>When in doubt: Ask someone. Look it up. Don't just run it.</p>"},{"location":"day_one/safety_guide/#rule-2-dont-make-changes-without-understanding-impact","title":"Rule 2: Don't Make Changes Without Understanding Impact","text":"<p>Before changing anything, ask:</p> <ol> <li>What does this change do?</li> <li>What could go wrong?</li> <li>How do I undo it?</li> <li>Is anyone else affected?</li> </ol> <p>If you can't answer these questions, you're not ready to make the change.</p>"},{"location":"day_one/safety_guide/#rule-3-test-in-lower-environments-first","title":"Rule 3: Test in Lower Environments First","text":"<p>The hierarchy of environments exists for a reason:</p> <pre><code>Development \u2192 Staging \u2192 Production\n   (safe)      (safe)     (dangerous)\n</code></pre> <p>Never test changes in production if you have staging available.</p>"},{"location":"day_one/safety_guide/#the-dangerous-commands","title":"The Dangerous Commands","text":""},{"location":"day_one/safety_guide/#rm-delete-with-extreme-prejudice","title":"rm - Delete With Extreme Prejudice","text":"<p><code>rm</code> doesn't move files to trash. It destroys them. Forever.</p> DANGEROUS - DO NOT RUN<pre><code>rm -rf /                    # Deletes EVERYTHING\nrm -rf /*                   # Also deletes EVERYTHING\nrm -rf /home/*              # Deletes all user data\nrm -rf ./*                  # Deletes everything in current directory\n</code></pre> <p>The -rf Flags</p> <ul> <li><code>-r</code> = Recursive (delete directories and contents)</li> <li><code>-f</code> = Force (no confirmation prompts)</li> </ul> <p>Together, they delete everything without asking. One typo and you've lost data.</p> <p>Safer alternatives:</p> Safer Deletion<pre><code># Check what you're about to delete first\nls /path/to/delete\n\n# Remove without -f so you get prompts\nrm -ri /path/to/delete\n\n# Use trash-cli if available\ntrash-put /path/to/delete\n</code></pre>"},{"location":"day_one/safety_guide/#chmod-777-the-security-disaster","title":"chmod 777 - The Security Disaster","text":"DANGEROUS - DO NOT RUN<pre><code>chmod 777 /var/www/app        # Anyone can read/write/execute\nchmod -R 777 /                # Security nightmare\n</code></pre> <p><code>777</code> means: owner, group, AND everyone else can read, write, and execute.</p> <p>What's wrong with this?</p> <ul> <li>Any user on the system can modify your files</li> <li>Attackers who get minimal access can now modify everything</li> <li>Some applications refuse to run with 777 permissions (SSH keys, for example)</li> </ul> <p>What to do instead:</p> Proper Permissions<pre><code># Make file readable by owner and group\nchmod 640 /path/to/file\n\n# Make directory accessible\nchmod 750 /path/to/directory\n\n# If you're not sure, ask what permissions should be\nls -la /path/to/file\n</code></pre>"},{"location":"day_one/safety_guide/#restarting-services-in-production","title":"Restarting Services in Production","text":"THINK BEFORE RUNNING<pre><code>sudo systemctl restart nginx\nsudo service mysql restart\nsudo reboot\n</code></pre> <p>These commands cause downtime. Even \"restart\" has a brief interruption.</p> <p>Before restarting anything:</p> <ol> <li>Is this production?</li> <li>What depends on this service?</li> <li>Is there a maintenance window?</li> <li>Have you told anyone?</li> <li>Is there a rollback plan?</li> </ol> <p>Better approach:</p> <ul> <li>Ask: \"Is it okay to restart nginx on prod?\"</li> <li>Check if there's an on-call procedure</li> <li>Schedule a maintenance window if needed</li> <li>Use <code>reload</code> instead of <code>restart</code> when possible (zero-downtime config reload)</li> </ul> Reload vs Restart<pre><code>sudo systemctl reload nginx  # Reloads config without dropping connections\nsudo systemctl restart nginx # Full restart, connections dropped\n</code></pre>"},{"location":"day_one/safety_guide/#writing-to-system-files","title":"Writing to System Files","text":"DANGEROUS - DO NOT RUN<pre><code>echo \"something\" &gt; /etc/hosts\ncat something &gt; /etc/passwd\n&gt; /var/log/syslog  # Truncates the log file\n</code></pre> <p>The <code>&gt;</code> operator overwrites files. The <code>&gt;&gt;</code> operator appends. One wrong character and you've destroyed a critical system file.</p> <p>Before writing to any file:</p> <ol> <li>Is this a system file?</li> <li>Do you have a backup?</li> <li>Are you using <code>&gt;</code> or <code>&gt;&gt;</code>?</li> <li>Have you tested this command?</li> </ol> <p>Safer approach:</p> Safer File Editing<pre><code># Make a backup first\nsudo cp /etc/hosts /etc/hosts.backup\n\n# Use an editor (you can see what you're changing)\nsudo vim /etc/hosts\n\n# Verify the change\ncat /etc/hosts\n</code></pre>"},{"location":"day_one/safety_guide/#dd-the-disk-destroyer","title":"dd - The Disk Destroyer","text":"<p><code>dd</code> is powerful and dangerous. It writes raw data to devices.</p> WILL DESTROY YOUR DISK<pre><code>sudo dd if=/dev/zero of=/dev/sda  # Wipes the primary disk\n</code></pre> <p>If you see <code>dd</code> in a command, be extremely careful about the <code>of=</code> target. A wrong target destroys data instantly with no confirmation.</p>"},{"location":"day_one/safety_guide/#things-that-seem-safe-but-arent","title":"Things That Seem Safe But Aren't","text":""},{"location":"day_one/safety_guide/#editing-config-files-directly","title":"Editing Config Files Directly","text":"RISKY<pre><code>sudo vim /etc/nginx/nginx.conf\n</code></pre> <p>This isn't dangerous by itself, but:</p> <ul> <li>One syntax error can break the service</li> <li>You might forget to reload the service</li> <li>You have no record of what changed</li> </ul> <p>Better approach:</p> Safer Config Editing<pre><code># Test the config before editing\nsudo nginx -t\n\n# Make a backup\nsudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup\n\n# Edit\nsudo vim /etc/nginx/nginx.conf\n\n# Test again\nsudo nginx -t\n\n# Only reload if test passes\nsudo systemctl reload nginx\n</code></pre>"},{"location":"day_one/safety_guide/#running-scripts-without-reading-them","title":"Running Scripts Without Reading Them","text":"RISKY<pre><code>sudo ./fix-everything.sh\n</code></pre> <p>Always read the script first:</p> Check Script Contents<pre><code>cat ./fix-everything.sh\nless ./fix-everything.sh\n</code></pre> <p>Look for <code>rm</code>, <code>dd</code>, <code>chmod</code>, service restarts, or anything you don't understand.</p>"},{"location":"day_one/safety_guide/#copying-commands-from-the-internet","title":"Copying Commands from the Internet","text":"<p>That Stack Overflow answer might be:</p> <ul> <li>Outdated</li> <li>Written for a different Linux distribution</li> <li>Missing context</li> <li>Malicious (rare but possible)</li> </ul> <p>Always understand before running:</p> <ul> <li>What does each part of the command do?</li> <li>Is this appropriate for your system?</li> <li>What's the worst that could happen?</li> </ul>"},{"location":"day_one/safety_guide/#production-safety-checklist","title":"Production Safety Checklist","text":"<p>Before making any change in production:</p> Check Question \u2705 Do I understand what this command does? \u2705 Have I tested this in a lower environment? \u2705 Do I have a rollback plan? \u2705 Have I made a backup (if applicable)? \u2705 Does anyone else need to know? \u2705 Is there a change management process I should follow? \u2705 Am I comfortable explaining this to my team lead? <p>If any answer is \"no\", stop and get help.</p>"},{"location":"day_one/safety_guide/#practice-exercises","title":"Practice Exercises","text":"Exercise 1: Safe Config Edit Workflow <p>You need to check the <code>worker_processes</code> setting in <code>/etc/nginx/nginx.conf</code>. Walk through the safe approach: backup, view, verify \u2014 without actually changing anything.</p> <p>Hint: Three steps \u2014 backup the file, read it, validate the syntax.</p> Solution Safe Config Inspection Workflow<pre><code># 1. Make a backup (even before read-only inspection, if you might edit later)\nsudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup\n\n# 2. Read the config (safe, read-only)\ngrep \"worker_processes\" /etc/nginx/nginx.conf\n\n# 3. Validate current syntax (before touching anything)\nsudo nginx -t\n</code></pre> <p>If you did edit and broke something: Restore from Backup<pre><code>sudo cp /etc/nginx/nginx.conf.backup /etc/nginx/nginx.conf\nsudo nginx -t\nsudo systemctl reload nginx\n</code></pre></p> Exercise 2: The Pre-Change Checklist <p>Your team lead asks you to restart the <code>mysql</code> service on a production server. Before touching the keyboard, what questions do you need answers to?</p> Solution <p>Work through the production safety checklist:</p> <ol> <li>Do I understand what <code>systemctl restart mysql</code> does? \u2014 Brief downtime. All active connections will drop.</li> <li>Have I tested this in staging? \u2014 Is there a staging server to verify first?</li> <li>Do I have a rollback plan? \u2014 If MySQL doesn't come back up, what's the procedure?</li> <li>Does anyone else need to know? \u2014 Is anyone currently using the database? Alert the team first.</li> <li>Is there a change management process? \u2014 Does this require a ticket, approval, or maintenance window?</li> <li>Am I comfortable explaining this to my team lead? \u2014 If not, ask before acting.</li> </ol> <p>If any answer is \"no\" or \"I don't know\" \u2014 stop and ask before proceeding.</p>"},{"location":"day_one/safety_guide/#when-things-go-wrong","title":"When Things Go Wrong","text":"<p>You made a mistake. Something broke. Now what?</p>"},{"location":"day_one/safety_guide/#dont-panic","title":"Don't Panic","text":"<p>Seriously. Panic leads to worse mistakes.</p>"},{"location":"day_one/safety_guide/#stop-making-changes","title":"Stop Making Changes","text":"<p>Don't try to \"fix\" it with more commands. You might make it worse.</p>"},{"location":"day_one/safety_guide/#document-what-happened","title":"Document What Happened","text":"<p>What command did you run? What time? What server?</p>"},{"location":"day_one/safety_guide/#ask-for-help","title":"Ask for Help","text":"<p>Tell your team immediately. The longer you wait, the worse it gets.</p> <p>\"Hey, I ran [command] on [server] and [symptom]. I need help.\"</p> <p>Much better than trying to fix it alone and making it worse.</p>"},{"location":"day_one/safety_guide/#learn-from-it","title":"Learn from It","text":"<p>Every outage is a learning opportunity. Post-mortems exist to prevent repeats, not to assign blame.</p>"},{"location":"day_one/safety_guide/#the-escape-hatches","title":"The Escape Hatches","text":""},{"location":"day_one/safety_guide/#ctrlc-stop-current-command","title":"Ctrl+C - Stop Current Command","text":"<p>If a command is running and you want to stop it:</p> <pre><code>Ctrl+C\n</code></pre>"},{"location":"day_one/safety_guide/#undo-recent-file-edit","title":"Undo Recent File Edit","text":"<p>If you just edited a file and the service is broken:</p> Restore Backup<pre><code>sudo cp /etc/nginx/nginx.conf.backup /etc/nginx/nginx.conf\nsudo systemctl reload nginx\n</code></pre>"},{"location":"day_one/safety_guide/#check-what-changed","title":"Check What Changed","text":"Diff Against Backup<pre><code>diff /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup\n</code></pre>"},{"location":"day_one/safety_guide/#quick-reference-safe-vs-dangerous","title":"Quick Reference: Safe vs Dangerous","text":"Safe (Read-Only) Dangerous (Modifies) <code>ls</code>, <code>cat</code>, <code>less</code> <code>rm</code>, <code>mv</code>, <code>cp</code> <code>grep</code>, <code>find</code> <code>chmod</code>, <code>chown</code> <code>ps</code>, <code>top</code> <code>kill</code>, <code>pkill</code> <code>systemctl status</code> <code>systemctl restart/stop</code> <code>df</code>, <code>du</code> <code>dd</code>, <code>mkfs</code> <code>git log</code>, <code>git status</code> <code>git push</code>, <code>git reset</code>"},{"location":"day_one/safety_guide/#the-golden-rules-summary","title":"The Golden Rules Summary","text":"<ol> <li>Understand before you run \u2014 Don't blindly execute commands</li> <li>Test in staging first \u2014 Production is not for experiments</li> <li>Make backups \u2014 Before changing any config file</li> <li>Ask if unsure \u2014 It's okay not to know everything</li> <li>Communicate \u2014 Tell people before and after changes</li> <li>Have a rollback plan \u2014 Know how to undo</li> <li>Stay calm \u2014 Panic makes mistakes worse</li> </ol>"},{"location":"day_one/safety_guide/#further-reading","title":"Further Reading","text":""},{"location":"day_one/safety_guide/#command-references","title":"Command References","text":"<ul> <li><code>man cp</code> \u2014 Understand the <code>-p</code> flag to preserve file permissions and timestamps when making backups</li> <li><code>man diff</code> \u2014 Compare two files side-by-side to verify what changed before and after an edit</li> <li><code>man chmod</code> \u2014 Understand permission notation before changing it</li> </ul>"},{"location":"day_one/safety_guide/#deep-dives","title":"Deep Dives","text":"<ul> <li>Google SRE Book - Managing Risk \u2014 Production safety from a site reliability engineering perspective; free online</li> <li>The Art of Unix Programming \u2014 Classic Unix philosophy including the principle of least surprise</li> </ul>"},{"location":"day_one/safety_guide/#related-articles","title":"Related Articles","text":"<ul> <li>Understanding Your Permissions \u2014 Know what you're allowed to do before you do it</li> <li>Reading Logs \u2014 When something goes wrong, logs are how you figure out what happened</li> <li>Day One Overview \u2014 Recap of the complete Day One series</li> </ul>"},{"location":"day_one/safety_guide/#youve-completed-day-one","title":"You've Completed Day One!","text":"<p>Congratulations! You now know how to:</p> <ul> <li>\u2705 Connect to a server via SSH</li> <li>\u2705 Orient yourself on a new system</li> <li>\u2705 Understand your permissions</li> <li>\u2705 Explore safely</li> <li>\u2705 Read logs like a pro</li> <li>\u2705 Find documentation and help</li> <li>\u2705 Perform common first tasks</li> <li>\u2705 Avoid dangerous mistakes</li> </ul> <p>What's next?</p> <p>Ready to keep leveling up? Level 1: Everyday Navigation is coming soon \u2014 covering the daily commands you'll use on any Linux system. In the meantime, head back to the Day One overview to review everything you've covered.</p> <p>You're Going to Be Fine</p> <p>Everyone who's comfortable on Linux servers started exactly where you are now. The fact that you read a safety guide before diving in shows good instincts. Keep asking questions, keep learning, and you'll be the one helping new people before you know it.</p>"},{"location":"development/development/","title":"Software Development with Enterprise Linux","text":""},{"location":"development/development/#application-development","title":"Application Development","text":"<p>One of the primary objectives of Enterprise Linux systems is to support application development and hosting.</p> <p>Introducing Podman</p> <p>Running Rootless Containers As Services</p>"},{"location":"development/development/#kernel-development","title":"Kernel Development","text":"<p>The Linux kernel is under constant development.  With every release, it improves its ability to support application development and hosting.  </p> <p>Linux Kernel on GitHub</p> <p>Linux Kernel Documentation</p>"},{"location":"development/introducingPodman/","title":"Introducing Podman","text":"<p>Podman, short for Pod Manager is an enterprise-grade containerization tool.  Although it is largely associated with the RHEL family of distributions, it is a stand-alone project that runs on all enterprise-grade Linux distributions. See Podman.io for tons of documentation.</p>"},{"location":"development/introducingPodman/#docker-vs-podman","title":"Docker vs Podman","text":"<p>Docker has been the containerization standard for several years in enterprise computing.  However, Podman is a strong competitor with several significant advantages.  These can be summarized as:</p> Docker Podman Separate Daemon? Uses Docker daemon Daemonless architecture Requires Root Access? Runs containers as <code>roo</code>t only Runs containers as <code>root</code> and non-<code>root</code> How are Images Built? YAML-Based DockerFile YAML-Based Image File, Buildah tool Monolithic Architecture? Yes No Container Orchestration? Yes Yes Integrated into the Linux Kernel? No Yes <p>The biggest advantages that Podman enjoys is that it is daemonless - meaning that <code>root</code> access is not needed to run containers.  This is incredibly developer-friendly in enterprise computing, as developers rarely have <code>root</code> access to servers.  Directly related to this daemonless architecture is that Podman is better integrated into the Linux kernel.  This has to do with the actual libraries in use and is beyond the scope of this article, but in short Podman is more Linux-kernel friendly.</p> <p>Note that setting up Podman still requires <code>root</code> access - much the same as installing other software requires <code>root</code>.  However, once installed and configured, developers can run as many containers as they have resources to support without super-user powers.</p> <p>The biggest challenge related to using Podman is that because Docker is so ubiquitous, it is easy to find playbooks that include Docker containers which developers have to \"translate\" into a Podman version. Luckily, Podman and Docker are largely command-equivalent (at least in recent versions) and this is becoming less and less of a challenge. \ud83d\udc33\u27a1\ufe0f\ud83e\uddad</p>"},{"location":"development/introducingPodman/#command-equivalent-to-docker","title":"Command-Equivalent to Docker","text":"<p>For developers who have used Docker in the past, it comes as a huge relief to know that Podman is command-equivalent in most regards.  This means that <code>podman run -p 80:80 nginx:latest</code> will produce exactly the same result as <code>docker run -p 80:80 nginx:latest</code> (all else being equal).  So, while there will be some minor migration pains, the process is a minor inconvenience at worst.</p>"},{"location":"development/introducingPodman/#a-quick-demo","title":"A Quick Demo","text":"<p>Podman containers are created in the exact same way as other containers.  The standard demo for this is to simply run <code>podman run -d -p 8080:80 nginx</code> which spins up an <code>nginx</code> webserver at <code>localhost:8000</code>.  While this does show a container running, a more complicated demo might be closer to something found in enterprise.</p>"},{"location":"development/introducingPodman/#the-business-requirement-private-cloud-for-a-small-business","title":"The Business Requirement: Private Cloud for a Small Business","text":"<p>Imagine a small business needs a private document storage solution for all its employee documents but doesn't want to use a public system such as Google Drive or Dropbox due to privacy and/or regulatory concerns.  Using Podman, it is relatively simple to host a containerized private storage cloud such as NextCloud on a local server (either physical or virtual).</p> <p>This would also work as a private instance on a public cloud service such as AWS or Azure but these are outside the scope of this article (and may or may not meet privacy/regulatory requirements).</p>"},{"location":"development/introducingPodman/#the-solution-containerized-nextcloud","title":"The Solution: Containerized NextCloud","text":"<p>While Podman comes pre-installed on RHEL8 and up, if it is missing, it is easy to install Podman with <code>dnf install podman</code> or <code>apt install podman</code>(depending on the distribution).  With Podman installed, issue the following commands (obviously changing the passwords/ports as needed):</p> <pre><code># Creating a new Podman network\npodman network create nextcloud-net\n\n# Creating volumes in which to store the Nexcloud Data\npodman volume create nextcloud-app\npodman volume create nextcloud-data\npodman volume create nextcloud-db\n\n# Deploy Mariadb (underlying database for NextCloud)\npodman run --detach --env MYSQL_DATABASE=nextcloud --env MYSQL_USER=nextcloud \\\n--env MYSQL_PASSWORD=DB_USER_PASSWORD --env MYSQL_ROOT_PASSWORD=DB_ROOT_PASSWORD \\\n--volume nextcloud-db:/var/lib/mysql --network nextcloud-net \\\n--name nextcloud-db docker.io/library/mariadb:10\n\n# Deploy Nextcloud\npodman run --detach --env MYSQL_HOST=nextcloud-db.dns.podman \\\n--env MYSQL_DATABASE=nextcloud --env MYSQL_USER=nextcloud \\\n--env MYSQL_PASSWORD=DB_USER_PASSWORD --env NEXTCLOUD_ADMIN_USER=NC_ADMIN \\\n--env NEXTCLOUD_ADMIN_PASSWORD=NC_PASSWORD --volume nextcloud-app:/var/www/html \\\n--volume nextcloud-data:/var/www/html/data --network nextcloud-net \\\n--name nextcloud --publish 8889:80 docker.io/library/nextcloud:20\n\n# Credit: https://fedoramagazine.org/nextcloud-20-on-fedora-linux-with-podman/\n</code></pre> <p>Simple as that, an instance of NextCloud is available for use at <code>localhost:8889</code> which of course can also be accessed via IP, via <code>hostfile</code> or via an internal DNS server if the company is so equipped:</p> <p></p> <p>Best of all, the data stored in this container is permanent - residing in the Podman volume <code>nextcloud-data</code> - which can be backed-up and exported in the same way as any other directory on a Linux system.</p> <p>To see how to make running this rootless container part of the boot procedure, see Running Rootless Containers as Services.</p>"},{"location":"development/rootless_containers_as_services/","title":"Running Rootless Containers as Services","text":"<p>When utilizing rootless containers directly on a Linux server, starting and stopping the container manually can become a major hassle, especially if other containers rely on the service.  For this reason, running containers as <code>systemd</code> services that start and stop with the underlying <code>systemd</code> controls provides significant value to developers and system administrators alike.</p> <p>Application Development on Enterprise Linux occurs largely within containerized applications.  While container orchestration platforms like Kubernetes and OpenShift (RHEL's version of Kubernetes with extra features) are often used, there is also a use-case for running a container directly on a Linux server without orchestration, often in the early-stages of development.</p>"},{"location":"development/rootless_containers_as_services/#enable-linger-for-specific-user-account","title":"Enable Linger for Specific User Account","text":"<p>The only part of this process that will require <code>root</code> access is to enable linger for the user that owns the container.  This means that even if the user is not logged in, <code>systemd</code> services associated with that user will start/stop with the server (if they are enabled).  Enabling linger is a simple one-line command:</p> <pre><code>#loginctl enable-linger &lt;user&gt;\nloginctl enable-linger brad\n</code></pre> <p>Now, if the user <code>brad</code> enables a <code>systemd</code> service (as per below), it will start and stop with the server startup/shutdown.</p>"},{"location":"development/rootless_containers_as_services/#create-a-systemd-service-to-control-a-rootless-container","title":"Create a Systemd Service to Control a Rootless Container","text":"<p>Logged in as the linger-enabled user and with a container already running (see Introducing Podman for an example), issue the following commands:</p> <p><pre><code>mkdir ~/.config/systemd/user # create a directory to store the systemd files\ncd ~/.config/systemd/user # switch to that directory\n# podman generate systemd --name &lt;ContainerName&gt; --files\npodman generate systemd --name nextCloud --files # generate the files\nsystemctl --user daemon-reload # make the systemd service aware of the files\n</code></pre> Starting and stopping the container should now be done with <code>systemctl --user start &lt;containerName&gt;.serivice</code>, <code>systemctl --user stop &lt;containerName&gt;.service</code>, or simply check the status with <code>systemctl --user status &lt;containerName&gt;.servicei</code>.  For example, running <code>systemctl --user status container-nextcloud.service</code> results in:</p> <p></p>"},{"location":"development/rootless_containers_as_services/#enable-the-systemd-service-to-run-at-system-startup","title":"Enable the Systemd Service to Run at System Startup","text":"<p>Now that the container is controlled by a <code>systemd</code> service, it can be enabled in a similar way as any other <code>systemd</code> service. The only caveat is to remember to add the <code>--user</code> flag as it is a user service, not a system service:</p> <pre><code># systemctl --user enable &lt;container-ContainerName.service&gt;\nsystemctl --user enable container-nextcloud.service\n</code></pre> <p>Find the name of the container serve in <code>~/.config/systemd/user/</code> directory if necessary.</p> <p>Rebooting the server should now result in the container starting automatically.  This can be validated with a simple <code>ps -ef | grep nextcloud</code> or <code>podman ps | grep nextcloud</code>.</p> <p>Depending on the application setup, it may be necessary to repeat this process and even edit the <code>systemd</code> service files to ensure the containers start in the correct order to resolve their dependencies on each other (outside the scope of this article).  For example, the container setup in Introducing Podman requires that the MariaDB container be started before the NextCloud container.</p>"},{"location":"essential_concepts/file_permissions/","title":"File Permissions","text":"<p>File permissions in Linux can feel like a maze at first \u2014 lots of letters, dashes, and gotchas. But don't worry: once you break it down, it's actually pretty logical. \ud83d\udd10</p> <p>One big thing to keep in mind: in Linux, everything is a file. Yep, everything \u2014 text files, devices, directories, even your monitor connection. And all of them have permissions attached.</p> <p>You can peek at permissions with ls -ltr. For example:</p> Listing Files with Permissions<pre><code>-rwxr--r--  1 root root     2354 Feb 17 08:54 .bashrc\n</code></pre>"},{"location":"essential_concepts/file_permissions/#file-ownership","title":"File Ownership","text":"<p>Every file has two owners:</p> <ul> <li>a user (the actual owner)</li> <li>a group (a collection of users)</li> </ul> <p>Here\u2019s that same example with some arrows added:</p> Group and User Ownership<pre><code>-rwxr--r--  1 root   root     2354 Feb 17 08:54 .bashrc\n               ^      ^\n             owner  group\n</code></pre> Permissions are not additive <p>Linux permissions are not additive.  This means that if a user falls into a category (owner, group, or other), Linux doesn't perform any further checks or processing.  Whatever the permissions of the first matching category are the effective permissions for the file.</p>"},{"location":"essential_concepts/file_permissions/#permissions-on-files","title":"Permissions on Files","text":"<p>Now let\u2019s zoom in on that left-hand side:</p> <pre><code>   -        rwx    r--    r--\n   ^         ^      ^      ^\nfile type  owner  group  other\n</code></pre> <p>That cryptic string breaks down into three sets of permissions: - r = read (open the file and look at it) - w = write (change it) - x = execute (run it as a program/script)</p> <p>In the <code>.bashrc</code> example:</p> <ul> <li>The owner (root) can read, write, and execute.</li> <li>The group (root) can only read.</li> <li>Everyone else (the \u201cother\u201d category) can only read too.</li> </ul>"},{"location":"essential_concepts/filesystem_hierarchy/","title":"Linux Filesystem Hierarchy","text":"<p>If you've spent any time with Linux, you'll notice that totally different distributions share a similar file structure \"under the hood.\" Even UNIX systems like IBM's AIX have a layout that's a lot like standard Linux distros.</p> <p>Why? It's thanks to the Linux File Hierarchy Standard (FHS), maintained by the Linux Foundation. The FHS defines the standard directories you should find on any Linux system. There's some wiggle room in where files go inside those directories, but for the most part, all compliant Linux distributions stick to this structure:</p> Linux Filesystem Hierarchy<pre><code>root@localhost /]# ls -ltr\ntotal 20\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 srv\nlrwxrwxrwx.   1 root root    8 Aug  9  2022 sbin -&gt; usr/sbin\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 opt\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 mnt\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 media\nlrwxrwxrwx.   1 root root    9 Aug  9  2022 lib64 -&gt; usr/lib64\nlrwxrwxrwx.   1 root root    7 Aug  9  2022 lib -&gt; usr/lib\nlrwxrwxrwx.   1 root root    7 Aug  9  2022 bin -&gt; usr/bin\ndr-xr-xr-x.   1 root root    0 Aug  9  2022 afs\ndrwx------.   1 root root    0 Nov  5 05:14 lost+found\ndrwxr-xr-x.   1 root root  168 Nov  5 05:21 usr\ndrwxr-xr-x.   1 root root  194 Nov  5 05:28 var\ndr-xr-xr-x.   6 root root 4096 Mar  9 20:07 boot\ndrwxr-xr-x.   1 root root    8 Mar  9 20:07 home\ndrwxr-xr-x.   1 root root 5000 Mar  9 20:10 etc\ndr-xr-x---.   1 root root  208 Mar  9 20:10 root\ndr-xr-xr-x. 291 root root    0 Mar 23 09:35 proc\ndr-xr-xr-x.  13 root root    0 Mar 23 09:35 sys\ndrwxr-xr-x.  20 root root 3980 Mar 23 09:35 dev\ndrwxr-xr-x.  56 root root 1520 Mar 23 09:35 run\ndrwxrwxrwt.  18 root root  420 Mar 23 09:35 tmp\n[root@localhost /]#\n</code></pre> <p>Since Linux is a self-documenting operating system (see Finding Help in Linux), there's a Manual page that explains the file system hierarchy. Just run <code>man hier</code> on any distro, read, learn, and enjoy! \ud83d\udcda</p>"},{"location":"essential_concepts/filesystem_hierarchy/#ephemeral-vs-persistent-file-systems-and-directories","title":"Ephemeral vs Persistent File Systems and Directories","text":"<p>Not everything in the above listing is a file or directory stored on your hard drive. In particular, <code>/proc</code> and <code>/run</code> (and sometimes <code>/tmp</code>) are \"ephemeral\" directories mounted on RAM-based file systems. They're created during boot and only exist for your current session. If you accessed the hard drive without booting Linux (say, from another OS), <code>/proc</code> and <code>/run</code> wouldn't be there.</p> <p>So, changes you make in these directories (modifying <code>/run</code> is more common and less risky than <code>/proc</code>) only last until you reboot. After that, things reset to whatever the kernel finds at boot.</p> <p>If you want changes to stick around after a reboot, make them in <code>/etc/</code>. That's where persistent configuration lives.</p>"},{"location":"getting_around/finding_files/","title":"Finding Files in Linux","text":"<p>One of the first things you\u2019ll bump into on Linux is the question: \u201cWhere the heck did that file go?\u201d \ud83d\udd75\ufe0f Whether you\u2019re trying to track down a rogue config, a missing binary, or just want to see what\u2019s eating up disk space, Linux gives you a handful of tools \u2014 each with its own quirks.</p>"},{"location":"getting_around/finding_files/#the-toolbox","title":"The Toolbox","text":"<p>Here\u2019s a quick rundown of the main commands you\u2019ll use to find files:</p>"},{"location":"getting_around/finding_files/#ls-just-listing-not-finding","title":"<code>ls</code> \u2013 Just Listing, Not Finding","text":"<p>The <code>ls</code> command is for listing files in a directory, not searching for them. Think of it like peeking into a folder \u2014 helpful when you already know where you are, but useless if you\u2019ve lost track of the thing entirely.</p> Listing /etc with ls<pre><code>ls /etc\n</code></pre>"},{"location":"getting_around/finding_files/#which-hunting-binaries-in-your-path","title":"<code>which</code> \u2013 Hunting Binaries in Your <code>$PATH</code>","text":"<p>If you\u2019re wondering \u201cWhere is this program actually located?\u201d, <code>which</code> has your back. It looks through your <code>$PATH</code> (the list of directories Linux checks for commands) and shows you where an executable lives.</p> Finding bash with which<pre><code>which bash\n# /usr/bin/bash\n</code></pre> <p>Only works for binaries, though. If you\u2019re trying to find a random text file, you\u2019re out of luck.</p>"},{"location":"getting_around/finding_files/#locate-speedy-but-database-driven","title":"<code>locate</code> \u2013 Speedy (but Database-Driven)","text":"<p><code>locate</code> is like a cheat sheet: instead of crawling your disk live, it searches a pre-built database. That\u2019s why it\u2019s lightning fast, but the results can be stale if the database isn\u2019t updated.</p> <p>The database is refreshed by running:</p> Updating the locate Database<pre><code>sudo updatedb\n</code></pre> <p>Then you can search for files by name:</p> <p>Using locate to Find Files<pre><code>locate myFile.txt\n# /home/user/documents/myFile.txt\n</code></pre> If it feels instant, that\u2019s because it is \u2014 <code>locate</code> already did the heavy lifting in the background.</p>"},{"location":"getting_around/finding_files/#find-the-heavyweight-champion","title":"<code>find</code> \u2013 The Heavyweight Champion","text":"<p>When you need flexibility, <code>find</code> is your best friend. It actually walks the filesystem, checking names, types, sizes, permissions, and even content if you chain it with other tools. Slower than locate, but way more powerful.</p> <p>Here are some real-world examples:</p> <p>Find every file or directory named hosts starting at root (<code>/</code>):</p> Finding Files or Directories Named hosts<pre><code>find / -name \"hosts\"\n</code></pre> <p>Find files larger than 100 MB in the root directory:</p> Finding Large Files<pre><code>find / -type f -size +100M\n</code></pre> <p>Search for files in <code>/etc</code> containing the word \"student\", then copy them to <code>find/contents</code>:</p> Finding Files by Content<pre><code>find /etc -exec grep -l student {} \\; -exec cp {} find/contents/ \\; 2&gt; /dev/null\n</code></pre> <p>Combine with <code>xargs</code> for speed: find all files in <code>/etc</code> and search them for 127.0.0.1:</p> Using find with xargs<pre><code>find /etc -name '*' -type f | xargs grep \"127.0.0.1\"\n</code></pre> <p>It\u2019s a Swiss Army knife \u2014 intimidating at first, but once you get comfortable, you\u2019ll wonder how you ever lived without it.</p>"},{"location":"getting_around/finding_files/#common-gotchas","title":"Common Gotchas","text":"<p>Even pros run into these snags:</p>"},{"location":"getting_around/finding_files/#permission-errors-with-find","title":"Permission errors with <code>find</code>","text":"<p>Running <code>find</code> against a directory where the user doesn't have permissions will throw lots of \"Permission denied\" errors. Options:</p> <ul> <li>Run with <code>sudo</code></li> <li>Or redirect errors to the void:</li> </ul> Redirecting find Errors<pre><code>find / -name \"hosts\" 2&gt;/dev/null\n</code></pre>"},{"location":"getting_around/finding_files/#locate-database-is-out-of-date","title":"<code>locate</code> database is out of date","text":"<p>Since <code>locate</code> relies on a database, you may see files that don\u2019t exist anymore (or miss new ones). Fix it with:</p> Updating the locate Database<pre><code>sudo updatedb\n</code></pre>"},{"location":"getting_around/finding_files/#which-only-shows-the-first-match-in-path","title":"<code>which</code> only shows the first match in <code>$PATH</code>","text":"<p>If you have multiple versions of a binary installed, <code>which</code> won\u2019t tell you about the others. Use:</p> Finding All Instances of bash<pre><code>type -a bash\n</code></pre>"},{"location":"getting_around/finding_files/#quoting-matters-in-find","title":"Quoting matters in <code>find</code>","text":"<p><code>find / -name hosts</code> will work, but if your filename includes special characters (*, ?, spaces), you\u2019ll want quotes:</p> Using Quotes with find<pre><code>find / -name \"my file*\"\n</code></pre>"},{"location":"getting_around/finding_files/#xargs-can-choke-on-spaces","title":"<code>xargs</code> can choke on spaces","text":"<p>When piping filenames with spaces into <code>xargs</code>, it may split them incorrectly. Use:</p> Handling Spaces with xargs<pre><code>find /etc -type f -print0 | xargs -0 grep \"127.0.0.1\"\n</code></pre>"},{"location":"getting_around/finding_files/#quick-recap","title":"Quick Recap","text":"<ul> <li><code>ls</code> \u2192 Show me what\u2019s here.</li> <li><code>which</code>- \u2192 Where\u2019s that program in <code>$PATH</code>?</li> <li><code>locate</code> \u2192 Fast, but needs an up-to-date database.</li> <li><code>find</code> \u2192 Slow but powerful; can match on almost anything.</li> </ul> <p>\ud83d\udc49 Pro tip: If you\u2019re not sure which tool to reach for, start with <code>locate</code> for speed. If it doesn\u2019t cut it, switch to <code>find</code> for more control.</p>"},{"location":"getting_around/finding_help/","title":"Finding Help in Linux","text":"<p>Lost in the terminal? Don't worry \u2014 Linux has your back with tons of built-in help. Whether you're just poking around or knee-deep in shell scripts, there's always a way to get unstuck. Let's walk through some handy ways to find help (and maybe a few hidden gems) right from your command line.</p>"},{"location":"getting_around/finding_help/#1-manual-pages-man","title":"1. Manual Pages (<code>man</code>)","text":"<p>The classic move: check the manual! Linux comes loaded with \"man pages\" \u2014 detailed guides for almost every command and utility. To peek at the manual for a command, just type:</p> <pre><code>man &lt;command&gt;\n</code></pre> <p>Curious about <code>lvcreate</code>? Try:</p> <pre><code>man lvcreate\n</code></pre> <p>Results in: </p> <p>You'll get a full rundown: what the command does, all its options, and some usage notes. It's like having a wise old wizard explain things (with extra beard).</p>"},{"location":"getting_around/finding_help/#navigating-the-manual-pages","title":"Navigating the Manual Pages","text":"<ul> <li>Search: Hit <code>/</code>, type your keyword, and press Enter to jump to what   you need.</li> <li>Quit: Press <code>q</code> when you're done (no need to be polite).</li> <li>Scroll: Use the arrow keys or spacebar to move around.</li> </ul>"},{"location":"getting_around/finding_help/#rebuilding-the-manual-pages","title":"Rebuilding the Manual Pages","text":"<p>Just installed Linux and <code>man</code> seems a bit empty? Sometimes the manual page database needs a refresh. You can rebuild it with:</p> <pre><code>mandb\n</code></pre> <p>This updates the index so you get the latest docs. Handy if you've just added new packages or tools.</p>"},{"location":"getting_around/finding_help/#manual-page-sections-a-quick-map","title":"Manual Page Sections (A Quick Map)","text":"<p>Man pages are split into sections \u2014 think of them as chapters in a choose-your-own-adventure book:</p> <ul> <li>1: User commands (the stuff you'll run most often)</li> <li>2: System calls (how programs talk to the kernel)</li> <li>3: Library calls (functions in libraries)</li> <li>4: Special files (usually in <code>/dev</code>)</li> <li>5: File formats and conventions (like <code>/etc/passwd</code>)</li> <li>6: Games (yes, really)</li> <li>7: Miscellaneous (macros, conventions, and oddities)</li> <li>8: System admin commands (for the brave and root users)</li> <li>9: Kernel routines (advanced stuff)</li> </ul> <p>If you're just starting out, sections 1 and 8 are your best friends. Sections 5 and 7 are great for file formats and conventions.</p> <p>But what if you don\u2019t even know the command\u2019s name yet? That\u2019s where searching comes in.</p>"},{"location":"getting_around/finding_help/#2-fuzzy-searching-for-commands","title":"2. Fuzzy Searching For Commands","text":"<p>Can't remember the exact command? No problem \u2014 Linux lets you search by keyword:</p> <ul> <li><code>man -k &lt;keyword&gt;</code>: Lists all commands related to your keyword.</li> <li><code>apropos &lt;keyword&gt;</code>: Does the same thing, just with a different   name.</li> </ul> <p>For example, to find anything about networking:</p> <pre><code>man -k network\n</code></pre> <p>Or:</p> <pre><code>apropos network\n</code></pre> <p>Want to narrow it down even more? Pipe it through <code>grep</code>:</p> <pre><code>man -k network | grep &lt;subkeyword&gt;\n</code></pre> <p>It's like asking Linux, \"Hey, what do you know about this?\" \u2014 and getting a list of everything it can find.</p> <p>Once you\u2019ve found the right command, though, you don\u2019t always need the full manual. Sometimes you just want a quick hint \u2014 enter <code>--help</code>.</p>"},{"location":"getting_around/finding_help/#3-quick-hints-with-the-help-option","title":"3. Quick Hints with the <code>--help</code> Option","text":"<p>Almost every Linux command has a built-in help option you can summon with <code>--help</code>. Think of it as the command whispering, \u201cHere\u2019s what I can do\u201d \u2014 without dragging you through the whole manual.</p> <p>Try this with <code>ls</code>:</p> <pre><code>ls --help\n</code></pre> <p>You\u2019ll get a concise list of options, their meanings, and sometimes even a few examples. It\u2019s perfect when you just need a quick refresher.</p> <p>A couple of tips:</p> <ul> <li> <p>Single vs double dash: Some older commands use <code>-h</code> instead of <code>--help</code>. If <code>--help</code> doesn\u2019t work, try <code>-h</code>.</p> </li> <li> <p>Too much text? Pipe it into <code>less</code> to make it scrollable:</p> <pre><code>ls --help | less\n</code></pre> </li> <li> <p>Not universal: A few grumpy old commands (looking at you, <code>vi</code>)   don\u2019t play by these rules \u2014 in those cases, man is still your friend.</p> </li> </ul> <p>This is usually the fastest way to jog your memory on a command\u2019s options. For deeper dives or background details, head back to the <code>man</code> pages.</p> <p>With these tricks \u2014 man pages for the deep dives, fuzzy searching when you can\u2019t quite remember the name, and the handy <code>--help</code> flag for a quick refresher \u2014 you\u2019ll never be stuck for long.</p> <p>The Linux help system is deep, but friendly once you know where to look. Keep exploring, keep asking questions, and remember: even the pros check the manual (sometimes twice).</p>"},{"location":"getting_around/generating_the_manual/","title":"Generating the Manual","text":"<p>A listing of the pages in the Manual is stored in a system-generated database. Accessing them is as simple as running <code>man &lt;command&gt;</code>, and you'll usually get a detailed listing of how to use that command. Check out Finding Help in Linux for more info about using <code>man</code>.</p>"},{"location":"getting_around/generating_the_manual/#help-the-manual-is-missing","title":"Help! The Manual is Missing!","text":"<p>On a freshly created Linux system, it's common for the Manual Pages to not be generated yet. Running <code>man &lt;command&gt;</code> might give you an error, even for basic utilities like <code>ls</code>. That's a pain \u2014 especially since new systems often mean running lots of commands with rarely-used options. Sometimes, the Manual can also get outdated after a software update and need a rebuild.</p> <p>Most Linux distributions use a scheduled job to generate the Manual, usually once a day. But if you need it right now, you can update the Manual yourself in a flash. Just run:</p> <pre><code>mandb\n</code></pre> <p></p> <p>Once that's done, your Manual will be fully stocked and ready for exploration. Happy learning!</p>"},{"location":"getting_around/using_the_command_line/","title":"Using The Command Line","text":"<p>In Enterprise Linux, the command line is the tool of choice for most tasks. Getting comfortable with it is key \u2014 most developers and admins SSH into servers and use the command line for their daily work. \u2328\ufe0f</p>"},{"location":"getting_around/using_the_command_line/#cli-command-syntax","title":"CLI Command Syntax","text":"<p>Most standard commands have three parts (though the last two are often optional):</p> <ol> <li>Command</li> <li>Option (optional)</li> <li>Argument (optional)</li> </ol> <p>For example:</p> <pre><code>ls -ltr /etc/\n</code></pre> <p>Which breaks down like this:</p> <pre><code>  ls    -ltr    /etc/\n   ^      ^       ^\nCOMMAND OPTION ARGUMENT\n</code></pre>"},{"location":"getting_around/using_the_command_line/#cli-commands-with-irregular-options","title":"CLI Commands with Irregular Options","text":"<p>Not every command follows this neat structure. Many advanced commands mix things up a bit:</p> <pre><code>grep -r 'conf' /etc/ # Recursively search for \"conf\" in all files in /etc\nfind /etc -name \"*journald**\" -exec ls -ltr {} \\; # Find files with \"journald\" in the name and list them\nps aux # List running processes (no hyphen for options here)\n</code></pre>"},{"location":"getting_around/using_the_command_line/#single-vs-double-hyphen-options","title":"Single vs Double Hyphen Options","text":"<p>Some commands accept both single and double hyphens. Single hyphens usually mean each letter is a separate option, while double hyphens spell out full words. For example:</p> <pre><code>lvcreate -h\nlvcreate --help\n</code></pre> <p>Both commands will show the help output.</p>"},{"location":"getting_around/using_the_command_line/#cli-visual-cues","title":"CLI Visual Cues","text":"<p>You can tell if you're running as <code>root</code> or a normal user by looking at the prompt.</p> <p>A normal user's prompt looks like this (note the <code>$</code>):</p> <pre><code>[brad@localhost ~]$ &lt;commandGoesHere&gt;\n</code></pre> <p>The <code>root</code> user gets a hash (<code>#</code>) at the end:</p> <pre><code>[root@localhost ~]# &lt;commandGoesHere&gt;\n</code></pre>"},{"location":"scripting/hello_world/","title":"Scripting <code>Hello World</code>","text":"<p>Writing a Hello World program is a rite of passage in programming \u2014 like your first cup of really good coffee. \u2615 Here's how to do it in a shell script \u2014 straight from the command line on an enterprise Linux system.</p> Prerequisites <p>This guide assumes you're comfortable with  <code>vim</code>.  If not, maybe start  there first.</p>"},{"location":"scripting/hello_world/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Create the script file</p> <p>Starting from a shell, create and open a new file, \"HelloWorld.sh\", using <code>vim</code>:</p> Create HelloWorld.sh<pre><code>vim HelloWorld.sh\n</code></pre> </li> <li> <p>Write the script</p> <p>Inside \"HelloWorld.sh\", enter Insert mode and type this exactly:</p> Write HelloWorld.sh<pre><code>#!/bin/bash\n\necho \"Hello World!\"\n</code></pre> <p></p> <ul> <li>The first line (<code>#!/bin/bash</code>) is called a shebang. It tells Linux which   interpreter should run the script. In this case, it's the Bash shell.</li> <li>The blank line is optional, but it makes the script easier to read.</li> <li>The next line with the keyword <code>echo</code> just prints Hello World! to the   screen.</li> </ul> </li> <li> <p>Save and exit</p> <p>Go back to Normal mode, save the file, and exit using <code>:wq</code></p> </li> <li> <p>Make the file executable</p> <p>By default, new files aren't executable. Add that permission:</p> Make the file executable<pre><code>chmod 700 HelloWorld.sh # (1)!\n</code></pre> <ol> <li>Using <code>700</code> gives the owner full permissions (read, write, execute) while removing all permissions for group and others. See Basic Permissions for a more thorough explanation.</li> </ol> </li> <li> <p>Run the script</p> <p>Finally, run it:</p> Run the script<pre><code>./HelloWorld.sh\n</code></pre> <p></p> </li> </ol>"},{"location":"scripting/hello_world/#troubleshooting","title":"Troubleshooting","text":"<p>If your script didn\u2019t run the first time, don\u2019t worry \u2014 here are the common gotchas:</p>"},{"location":"scripting/hello_world/#permission-denied-when-running-helloworldsh","title":"Permission denied when running <code>./HelloWorld.sh</code>","text":"<ul> <li> <p>You probably forgot to make it executable. Run:</p> Make the file executable<pre><code>chmod 700 HelloWorld.sh\n</code></pre> </li> </ul>"},{"location":"scripting/hello_world/#command-not-found-or-nothing-happens","title":"<code>command not found</code> or nothing happens","text":"<ul> <li>Make sure you're running it with <code>./HelloWorld.sh</code> and not just <code>HelloWorld.sh</code>. The <code>./</code> tells the shell to look in the current directory for the script.</li> </ul>"},{"location":"scripting/hello_world/#weird-characters-in-the-output","title":"Weird characters in the output","text":"<ul> <li>Make sure you typed the script exactly as shown, especially the quotes around \"Hello World!\".</li> <li>Double-check that the first line is <code>#!/bin/bash</code> with no extra spaces or characters. If you leave out the <code>!</code>, for example, it won't work.</li> </ul>"},{"location":"scripting/hello_world/#using-windows-line-endings","title":"Using Windows line endings","text":"<ul> <li> <p>If you created the script on Windows and then copied it to Linux, it may have Windows-style line endings (CRLF) instead of Unix-style (LF). This can cause issues. To fix it, run:</p> Convert line endings<pre><code>dos2unix HelloWorld.sh\n</code></pre> </li> </ul>"},{"location":"scripting/hello_world/#still-stuck","title":"Still stuck?","text":"<ul> <li> <p>Try running the script with <code>bash -x</code> to see what\u2019s going on behind the     scenes:</p> Run with bash -x<pre><code>bash -x HelloWorld.sh\n</code></pre> </li> </ul>"},{"location":"text_processing/grep/","title":"Grep: The Ultimate Searcher","text":"<p>If you spend any time in the Linux terminal, <code>grep</code> will quickly become your most-used tool. Its name stands for Global Regular Expression Print.</p> <p>Its job is simple: scan a file (or input) and print only the lines that match a specific pattern.</p>"},{"location":"text_processing/grep/#1-basic-usage","title":"1. Basic Usage","text":"<p>The simplest way to use grep is to search for a word in a file.</p> <p><code>grep \"error\" server.log</code></p> <p>This will print every line in <code>server.log</code> that contains the word \"error.\"</p>"},{"location":"text_processing/grep/#2-common-flags","title":"2. Common Flags","text":"<p><code>grep</code> is much more powerful when you use its flags:</p> <ul> <li><code>-i</code> (Ignore Case): Matches \"ERROR,\" \"Error,\" and \"error.\"<ul> <li><code>grep -i \"error\" server.log</code></li> </ul> </li> <li><code>-v</code> (Invert Match): Prints everything except the lines that match.<ul> <li><code>grep -v \"debug\" server.log</code> (Show me everything that isn't a debug message).</li> </ul> </li> <li><code>-r</code> (Recursive): Searches for the pattern in all files in a directory and its subdirectories.<ul> <li><code>grep -r \"password\" /etc/</code></li> </ul> </li> <li><code>-n</code> (Line Number): Shows you which line the match was found on.</li> <li><code>-c</code> (Count): Just tells you how many lines matched, rather than printing the lines.</li> </ul>"},{"location":"text_processing/grep/#3-regular-expressions-regex","title":"3. Regular Expressions (Regex)","text":"<p>Grep is named after Regular Expressions. You aren't limited to searching for exact words; you can search for patterns. (Learn more about patterns in the Regular Expressions article).</p> <ul> <li><code>^</code> (Start of line): <code>grep \"^Search\" file</code> (Find lines starting with Search).</li> <li><code>$</code> (End of line): <code>grep \"End$\" file</code> (Find lines ending with End).</li> <li><code>.</code> (Any character): <code>grep \"h.t\" file</code> (Matches \"hat,\" \"hit,\" \"hot\").</li> </ul>"},{"location":"text_processing/grep/#4-grep-in-a-pipeline","title":"4. Grep in a Pipeline","text":"<p>Grep is most commonly used at the end of a pipe to filter output from other commands.</p> <p><code>ps aux | grep \"python\"</code> (List all running processes, but only show the ones related to Python).</p>"},{"location":"text_processing/grep/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Finding IP Addresses <p>You have a file <code>access.log</code>. You want to see every line that does NOT come from the IP <code>192.168.1.1</code>. Which command do you use?</p> Solution <p><code>grep -v \"192.168.1.1\" access.log</code></p> <p>The <code>-v</code> flag tells grep to \"invert\" the search, showing only the lines that don't match the pattern.</p> Practice Problem 2: Counting Errors <p>How many times does the word \"Critical\" appear in <code>syslog</code>? (You only want the number).</p> Solution <p><code>grep -c \"Critical\" /var/log/syslog</code></p> <p>The <code>-c</code> flag returns the count of matching lines.</p>"},{"location":"text_processing/grep/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Grep filters text line by line.</li> <li>Use <code>-i</code> for case-insensitivity and <code>-v</code> to exclude lines.</li> <li>Combine it with Pipes to filter output from any command.</li> </ul> <p>Grep is the \"X-Ray vision\" of the Linux terminal. Whether you are searching through source code, log files, or system configurations, <code>grep</code> allows you to cut through the noise and see exactly the information you need.</p>"},{"location":"text_processing/pipes_and_redirection/","title":"Pipes and Redirection","text":"<p>In Linux, the \"Unix Philosophy\" is: \"Write programs that do one thing and do it well. Write programs to work together.\"</p> <p>To make programs work together, we use Pipes and Redirection. They allow us to connect the output of one command to the input of another, creating a powerful \"assembly line\" for data.</p>"},{"location":"text_processing/pipes_and_redirection/#1-standard-streams","title":"1. Standard Streams","text":"<p>Every command in Linux has three \"pipes\" attached to it automatically: 1.  STDIN (0): Standard Input (usually your keyboard). 2.  STDOUT (1): Standard Output (usually your screen). 3.  STDERR (2): Standard Error (where error messages go).</p>"},{"location":"text_processing/pipes_and_redirection/#2-redirection-to-and-from-files","title":"2. Redirection: To and From Files","text":"<p>Instead of printing to the screen, you can redirect output to a file.</p> <ul> <li><code>&gt;</code> (Overwrite): Saves output to a file, deleting anything that was already there.<ul> <li><code>ls &gt; files.txt</code></li> </ul> </li> <li><code>&gt;&gt;</code> (Append): Adds output to the end of a file.<ul> <li><code>echo \"New line\" &gt;&gt; notes.txt</code></li> </ul> </li> <li><code>&lt;</code> (Input): Feeds a file into a command.<ul> <li><code>sort &lt; names.txt</code></li> </ul> </li> </ul>"},{"location":"text_processing/pipes_and_redirection/#3-pipes-command-to-command","title":"3. Pipes: Command to Command","text":"<p>A Pipe (<code>|</code>) takes the STDOUT of the command on the left and feeds it into the STDIN of the command on the right.</p> <p>Example: <code>ls -l /etc | less</code> 1.  <code>ls -l</code> lists all files. 2.  Instead of printing 500 lines to the screen, the pipe sends them to <code>less</code>. 3.  <code>less</code> allows you to scroll through the list one page at a time.</p> <p>Complex Pipeline: <code>cat access.log | grep \"404\" | wc -l</code> 1.  Read the log file. 2.  Find lines containing \"404\". 3.  Count how many lines were found.</p>"},{"location":"text_processing/pipes_and_redirection/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Overwrite vs Append <p>You run <code>echo \"Hello\" &gt; test.txt</code>. Then you run <code>echo \"World\" &gt; test.txt</code>. What is inside <code>test.txt</code>?</p> Solution <p>\"World\"</p> <p>The single <code>&gt;</code> overwrites the file. If you wanted both words, you should have used <code>&gt;&gt;</code> for the second command.</p> Practice Problem 2: Hidden Errors <p>You run a command that produces an error, and you try to save it to a file: <code>bad_command &gt; error.log</code> The file <code>error.log</code> is empty, and the error still prints to the screen. Why?</p> Solution <p>Because <code>&gt;</code> only redirects STDOUT (1). Error messages are sent to STDERR (2). To redirect errors, you must use <code>2&gt;</code>: <code>bad_command 2&gt; error.log</code></p>"},{"location":"text_processing/pipes_and_redirection/#key-takeaways","title":"Key Takeaways","text":"Symbol Action <code>&gt;</code> Redirect Output (Overwrite). <code>&gt;&gt;</code> Redirect Output (Append). <code>&lt;</code> Redirect Input. <code>|</code> Send output of one command to input of another. <p>Pipes are the \"glue\" of Linux. By combining small, simple tools into a pipeline, you can perform complex data processing tasks that would normally require a custom-written program.</p>"},{"location":"text_processing/sed/","title":"Sed: The Stream Editor","text":"<p><code>sed</code> is short for Stream Editor. Unlike a text editor like Vim or Nano, where you open a file and manually type changes, <code>sed</code> performs edits automatically as text \"streams\" through it.</p> <p>It is most commonly used for Search and Replace.</p>"},{"location":"text_processing/sed/#1-basic-substitution","title":"1. Basic Substitution","text":"<p>The core syntax for substitution is: <code>sed 's/find/replace/' file</code></p> <p>Example: <code>echo \"The cat sat on the mat\" | sed 's/cat/dog/'</code> -   Output: \"The dog sat on the mat\"</p>"},{"location":"text_processing/sed/#2-the-global-flag-g","title":"2. The Global Flag (<code>g</code>)","text":"<p>By default, <code>sed</code> only replaces the first occurrence on each line.</p> <p><code>echo \"red fish blue fish\" | sed 's/fish/cat/'</code> -   Output: \"red cat blue fish\"</p> <p>To replace every occurrence, add the <code>g</code> (global) flag: <code>echo \"red fish blue fish\" | sed 's/fish/cat/g'</code> -   Output: \"red cat blue cat\"</p>"},{"location":"text_processing/sed/#3-in-place-editing-i","title":"3. In-place Editing (<code>-i</code>)","text":"<p>Normally, <code>sed</code> prints the edited text to the screen but does not change the original file.</p> <p>To save your changes directly to the file, use the <code>-i</code> flag. </p> <p><code>sed -i 's/localhost/127.0.0.1/g' config.txt</code> (This will permanently update <code>config.txt</code>).</p> <p>Warning: Be careful with <code>-i</code>! It\u2019s a good idea to run the command without it first to make sure your substitution is correct before committing the change to the file.</p>"},{"location":"text_processing/sed/#4-deleting-lines","title":"4. Deleting Lines","text":"<p>You can also use <code>sed</code> to delete lines that match a pattern.</p> <p><code>sed '/debug/d' log.txt</code> (This prints <code>log.txt</code> but deletes any line containing the word \"debug\").</p>"},{"location":"text_processing/sed/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Changing Delimiters <p>You want to change the word \"path/to/file\" to \"new/path\". Using <code>sed 's/path\\/to\\/file/new\\/path/'</code> is messy because of the slashes. Is there a better way?</p> Solution <p>Yes. </p> <p>You can use any character as a delimiter in <code>sed</code>, not just <code>/</code>. Many people use <code>|</code> or <code>:</code> to make it cleaner: <code>sed 's|path/to/file|new/path|' file</code></p> Practice Problem 2: Global Replace <p>You have a file <code>names.txt</code> where the word \"John\" appears three times on the first line. You run <code>sed 's/John/Doe/' names.txt</code>. How many times is \"John\" replaced on that first line?</p> Solution <p>Once. </p> <p>Without the <code>g</code> flag, <code>sed</code> only replaces the first instance it finds on each line.</p>"},{"location":"text_processing/sed/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>s/old/new/</code> is the command for substitution.</li> <li>Add <code>g</code> to the end to replace all instances on a line.</li> <li>Use <code>-i</code> to save changes directly to the file.</li> <li>Use <code>/pattern/d</code> to delete matching lines.</li> </ul> <p><code>sed</code> is a scalpel for text processing. While it has a massive list of complex commands, mastering the basic search-and-replace syntax gives you the power to automate repetitive editing tasks across thousands of files in seconds.</p>"}]}