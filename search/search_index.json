{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-exploring-enterprise-linux","title":"Welcome to Exploring Enterprise Linux","text":"<p>A subsection of BradPenney.io, Exploring Enterprise Linux is your go-to companion in the world of open\u2011source adventure and command\u2011line wizardry! \ud83d\udc27\ud83d\udd0d</p> <p>This space is dedicated to showcasing the power, quirks, and elegant simplicity of essential Linux tools \u2014 think <code>bash</code>, <code>systemd</code>, <code>tmux</code>, <code>grep</code>, <code>awk</code>, plus distro\u2011hopping tips and shell\u2011fu shortcuts \u2014 for anyone who wants to do more with fewer keystrokes (and fewer facepalms).</p> <p>Whether you're dipping your toes in Linux for the first time or you've been tinkering with kernels and bootloaders since floppy\u2011disk days, I hope you\u2019ll discover something that sparkles, surprises, or gives you a good chuckle (penguin\u2011style) \ud83d\ude04</p>"},{"location":"#upcoming-topics-to-explore","title":"Upcoming Topics to Explore \ud83d\udc27","text":"<ul> <li>Diving into the command line: shells, prompt tricks, scripting, and more</li> <li>Mastering process control and service management with systemd</li> <li>Multiplexing like a pro with tmux &amp; session workflows</li> <li>Text\u2011magic with <code>grep</code>, <code>awk</code>, and <code>sed</code> for powerful data wrangling</li> <li>File system mastery: partitions, permissions, links, and troubleshooting</li> <li>Distro deep\u2011dives, installation tips, and customizing your penguin playground</li> </ul> <p>Stick around \u2014 more tutorials, shell\u2011fu examples, and spontaneous penguin tangents are on the way. Thanks for stopping by, and happy exploring! \ud83d\udc4b</p>"},{"location":"administering_linux/accessing_network_storage/","title":"Accessing Network Storage","text":"<p>One of the cornerstones of enterprise computing is letting systems share data seamlessly. Enter NFS (Network File System): it lets clients pull from or write to storage on a server as if it were local.</p> <p>Classic use cases include: - Applications writing logs to a central share - Database servers sharing data files - User home directories in large organizations</p> <p>Whatever the use case, NFS makes life a lot easier.</p> Client-Side NFS Setup <p>This article covers accessing an existing NFS export. If you need to set up the server side first, see Serving Up Network Storage.</p>"},{"location":"administering_linux/accessing_network_storage/#finding-an-nfs-share","title":"Finding an NFS Share","text":"<p>To see what a server is sharing, run: Show NFS Exports<pre><code># showmount -e &lt;Name_of_NFS_Server&gt; or &lt;IP_of_NFS_Server&gt;\nshowmount -e homeServer # OR\nshowmount -e 192.168.250.250\n</code></pre></p> <p>The result should resemble: Sample NFS Export List<pre><code>Export list for homeServer:\n/sharedSpace *\n</code></pre></p> <p>Once you know what\u2019s available, you have two main choices for mounting it: permanently or on-demand with automount.</p>"},{"location":"administering_linux/accessing_network_storage/#option-1-permanently-mounted","title":"Option 1: Permanently Mounted","text":"<p>A permanent mount means the NFS share is always present in the Linux File System Hierarchy. To the client, it just looks like another directory.</p> <ul> <li>\ud83d\udc4d Pros: always there, seamless for apps and users</li> <li>\ud83d\udc4e Cons: if the NFS server is down, your client may hang or fail to boot</li> </ul> <p>For enterprise systems with \u201cfive-nines\u201d uptime, that tradeoff is usually fine.</p>"},{"location":"administering_linux/accessing_network_storage/#install-client-packages","title":"Install Client Packages","text":"Install NFS Client Package<pre><code>dnf install nfs-utils # RHEL Family\napt install nfs-common # Debian Family\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#add-to-etcfstab","title":"Add to <code>/etc/fstab</code>","text":"<p>Always back it up first:</p> Backup /etc/fstab<pre><code>cp /etc/fstab /etc/fstab_bkup\n</code></pre> <p>Then add:</p> Edit /etc/fstab<pre><code># &lt;NFS_Server_Name&gt;:/&lt;share_name&gt;   /&lt;mountPoint&gt;   nfs     sync    0 0\nhomeServer:/                        /share          nfs     sync    0 0\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#validate-the-mount","title":"Validate the Mount","text":"<pre><code>mount -a # check if error thrown\nmount | grep homeServer # should return some lines\nfindmnt --verify # should return no issues\n</code></pre> <p>If all looks good, reboot and confirm it mounts automatically.</p>"},{"location":"administering_linux/accessing_network_storage/#option-2-automount","title":"Option 2: Automount","text":"<p>Automounting makes shares available on demand \u2014 they appear only when accessed, and disappear when idle.</p> <p>This is great for:</p> <ul> <li>User home directories (only mount them when someone logs in)</li> <li>Occasional writes (e.g., daily log dumps)</li> <li>Reducing overhead when constant connectivity isn\u2019t needed</li> </ul> <p>From a user\u2019s perspective: it \u201cjust works\u201d when they need it, but doesn\u2019t clutter the system otherwise.</p>"},{"location":"administering_linux/accessing_network_storage/#install-and-enable-autofs","title":"Install and enable <code>autofs</code>","text":"<pre><code>dnf install autofs # RHEL Family\napt install autofs # Debian Family\n\n# Enable the service\nsystemctl enable --now autofs\n</code></pre> Restart Required After Config Changes <p>Remember: restart autofs every time you change its config:</p> Restart autofs<pre><code>systemctl restart autofs\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#configure-automount","title":"Configure Automount","text":"<p>Automount uses at least two files: - <code>/etc/auto.master</code> \u2192 defines the mount point and its map file - <code>/etc/auto.&lt;shortName&gt;</code> \u2192 the specific config for that share</p> <p>Example:</p> <p><code>/etc/auto.master</code>:</p> Sample /etc/auto.master<pre><code># /etc/auto.master\n# /&lt;mountPoint&gt; /etc/auto.&lt;configFile&gt;\n/share  /etc/auto.share\n</code></pre> <p><code>/etc/auto.share</code>:</p> Sample /etc/auto.share<pre><code># /etc/auto.share\n# &lt;wildcard&gt; &lt;read/write&gt; &lt;location&gt;\n*   -rw     homeServer:/sharedSpace/&amp;\n</code></pre>"},{"location":"administering_linux/accessing_network_storage/#how-it-works","title":"How it Works","text":"<ul> <li>The server homeServer shares <code>/sharedSpace</code>.</li> <li>Clients don\u2019t see subdirectories until they\u2019re accessed (i.e. <code>/share/backups</code>).</li> </ul>"},{"location":"administering_linux/accessing_network_storage/#conclusion","title":"Conclusion","text":"<p>Whether you go with permanent mounts or automount, NFS is a fundamental tool for enterprise admins. It extends the filesystem across machines, making your infrastructure far more flexible and powerful.</p> Need the Server Side? <p>In case you missed it above, Serving Up Network Storage contains the details on how to set up the share drive.</p>"},{"location":"administering_linux/adding_storage/","title":"Adding a Storage Disk To Linux","text":"<p>Adding extra storage in Linux is one of those everyday sysadmin tasks \u2014 especially in virtual machines. In big enterprise setups, you\u2019d normally use LVM (Logical Volume Management), but sometimes you just need to drop in a simple disk and make it usable.</p> <p>That\u2019s what we\u2019ll do here: add a plain disk, partition it, format it, and mount it so Linux can use it.</p>"},{"location":"administering_linux/adding_storage/#connect-a-new-disk","title":"Connect a New Disk","text":"<p>How you attach a disk depends on your setup:</p> <ul> <li>Physical server \u2192 crack open the case/rack and plug it in (not covered here).</li> <li>Virtual machine \u2192 add one through your hypervisor.</li> </ul> <p>In this demo we\u2019re using Virtual Machine Manager (a front-end for KVM/QEMU). The process is similar if you\u2019re on VMware, VirtualBox, or Hyper-V.</p> <p>Open the VM details, hit Add Hardware, and create a new disk:</p> <p></p> <p>We\u2019ll add a couple of 10GiB virtual disks:</p> <p></p> <p>They\u2019ll then show up as hardware for the VM:</p> <p></p>"},{"location":"administering_linux/adding_storage/#find-the-added-disks-with-lsblk","title":"Find the Added Disks with <code>lsblk</code>","text":"<p>Boot the VM, log in, become <code>root</code>, and run <code>lsblk</code>. You\u2019ll see your new disks \u2014 the names depend on the hypervisor (<code>sdb</code>, <code>vdb</code>, etc.):</p> <p></p> <p>Here they\u2019re <code>vdb</code> and <code>vdc</code>, which live in <code>/dev/</code>:</p> <p></p> <p>\u26a0\ufe0f Heads-up: storage management is root-level work. Don\u2019t try this as a normal user.</p>"},{"location":"administering_linux/adding_storage/#create-a-partition-table-with-fdisk","title":"Create a Partition Table with <code>fdisk</code>","text":"<p>Fresh disks are blank slates \u2014 no partition table, no use. - MBR = old style (limited, mostly legacy now). - GPT = modern, flexible, and what we\u2019ll use.</p> <p>Run fdisk on the new disk:</p> <p></p> <p>Inside fdisk: - <code>g</code> \u2192 create a GPT partition table - <code>n</code> \u2192 create a new Partition - <code>p</code> \u2192 print the partition table - <code>m</code> \u2192 print the help menu - <code>w</code> \u2192 write changes and exit</p> <code>fdisk</code> Help <p>Help inside <code>fdisk</code> can be found with <code>m</code> (some think of it as <code>m</code> for Menu)</p>"},{"location":"administering_linux/adding_storage/#use-fdisk-to-create-partitions","title":"Use <code>fdisk</code> to Create Partitions","text":"<p>Reopen fdisk on /dev/vdb and create a partition: - <code>n</code> \u2192 new partition - choose number, start, and size (or just hit Enter for defaults)</p> <p>Here\u2019s an example making a 1GiB partition:</p> <p></p> Note <p>Pressing Enter at the prompts usually accepts sensible defaults</p>"},{"location":"administering_linux/adding_storage/#validate-partition-and-write-to-disk","title":"Validate Partition and Write to Disk","text":"<p>Still in <code>fdisk</code>: - <code>p</code> \u2192 print the partition table (double-check your work) - <code>w</code> \u2192 write to disk</p> <p></p> <p>Repeat these steps to create another partition on the disk that was created. Once both partitions are created, a simple <code>lsblk</code> should show both disks with partitions, ready for the next steps:</p> <p></p>"},{"location":"administering_linux/adding_storage/#make-a-file-system-on-the-created-partitions","title":"Make a File System On the Created Partitions","text":"<p>Partitions are just containers. To actually use them, format with a filesystem:</p> <p></p> File System Types <p>Just for fun, we created two different types of file systems, one <code>xfs</code> and the other <code>ext4</code>.  File system types are a big topic, but these are two very important types.</p>"},{"location":"administering_linux/adding_storage/#create-a-directory-for-the-file-systems","title":"Create a Directory for the File Systems","text":"<p>In Linux, new storage doesn\u2019t show up as a drive letter. You need to 'attach' it somewhere in the filesystem.</p> <p>For this demo: - <code>/app</code> \u2192 XFS disk - <code>/db</code> \u2192 ext4 disk</p> <p>Make Mount Points<pre><code>sudo mkdir /app /db\n</code></pre> As below (using <code>root</code>, therefore no <code>sudo</code>):</p> <p></p>"},{"location":"administering_linux/adding_storage/#make-a-backup-of-etcfstab","title":"Make a Backup of <code>/etc/fstab</code>","text":"<p>The <code>/etc/fstab</code> file controls which filesystems get mounted at boot. It\u2019s powerful but unforgiving: one bad entry can prevent the system from starting.</p> <p>Make a backup first:</p> <p></p>"},{"location":"administering_linux/adding_storage/#make-the-mounts-automatic-and-permanent","title":"Make the Mounts Automatic and Permanent","text":"<p>Best practice is to mount by UUID (unique ID) instead of device name. Grab it with:</p> Get UUID of New Partition<pre><code>blkid | grep vdb1 | awk ' { print $2 } '\n</code></pre> <p>Append it to <code>/etc/fstab</code>:</p> Append the UUID to fstab<pre><code>blkid | grep vdb1 | awk ' { print $2 } ' &gt;&gt; /etc/fstab\n</code></pre> <p></p> Append, Don't Overwrite! <p>Note that this APPENDS (<code>&gt;&gt;</code>) to <code>/etc/fstab</code>.  Do not overwrite <code>/etc/fstab</code>! (But if that happens, simply revert using the backup taken above!) It is highly recommended to confirm the output of the command is as expected BEFORE appending it to <code>/etc/fstab</code>.  This kind of \"trust but verify\" mentality will save many blunders in the command-line.</p> <p>Then check that <code>/etc/fstab</code> has this line:</p> Check fstab<pre><code>UUID=\"&lt;yourUUID&gt;\"     /app    xfs     defaults        0 0\n</code></pre> <p>In our example, <code>/etc/fstab</code> now looks like this:</p> <p></p> <p>Repeat for the other disk.  The final <code>/etc/fstab</code> should look like this:</p> <p></p>"},{"location":"administering_linux/adding_storage/#mount-validate-the-new-storage","title":"Mount &amp; Validate the New Storage","text":"<p>Apply the changes with:</p> Mount All Filesystems in fstab<pre><code>mount -a\n</code></pre> <p>Verify both disks are showing up and that there are no issues with:</p> Validate the New Mounts<pre><code>mount | grep vd[bc] # will vary depending on setup/hypervisor\nfindmnt --verify\n</code></pre> <p>For example:</p> <p></p> <p>A couple other checks could be:</p> <p></p> <p>Test them by creating files, then reboot to make sure mounts survive.</p> <p>If the system won\u2019t boot, don\u2019t panic \u2014 drop to root shell and restore your backup:</p> Restore fstab from Backup<pre><code>cp /etc/fstab_bkup /etc/fstab\n</code></pre> <p>Go add some storage to a Linux system! Enjoy!</p> Using <code>parted</code> <p>As mentioned above, there is also a <code>parted</code> utility which works with storage disks.</p>"},{"location":"administering_linux/lvm_basics/","title":"Logical Volume Management Basics","text":"<p>While adding a disk directly works fine, that approach doesn\u2019t scale well in enterprise environments. Big systems need flexibility: adding, resizing, moving, or even migrating storage without reformatting everything.</p> <p>That\u2019s where Logical Volume Management (LVM) shines. At its core, LVM is built around three building blocks:</p> <ol> <li>Physical Volumes (PVs) \u2192 actual disks (or partitions) you feed into    LVM</li> <li>Volume Groups (VGs) \u2192 pools of storage made from PVs</li> <li>Logical Volumes (LVs) \u2192 slices of the pool, presented to Linux as    usable disks</li> </ol> <p>Think LEGO bricks: PVs are the raw bricks, VGs are the big bucket you dump them into, and LVs are the custom shapes you build from that bucket.</p> Demo OS: Rocky Linux <p>This demo uses Rocky Linux (RHEL9 downstream). Everything here is done as <code>root</code> \u2014 which is typical for storage work.</p>"},{"location":"administering_linux/lvm_basics/#add-new-disks","title":"Add New Disks","text":"<p>The setup is the same as in Adding Storage. The only difference: LVM makes the most sense when you\u2019ve got multiple disks to play with.</p> <p>In this demo, we\u2019ll use four 5GiB disks, combined with RAID5 for redundancy (RAID is its own big topic, but redundancy means \u201csafer data\u201d \ud83d\udc4d).</p> <p></p>"},{"location":"administering_linux/lvm_basics/#create-a-new-physical-volumes-pvs","title":"Create a New Physical Volumes (PVs)","text":"<p>Our four new disks (<code>vdb</code>, <code>vdc</code>, <code>vdd</code>, <code>vde</code>) show up in <code>lsblk</code>. Before LVM can use them, we convert them into physical volumes:</p> Create Physical Volumes<pre><code>#pvcreate &lt;disks to add&gt;\npvcreate /dev/vdb /dev/vdc /dev/vdd /dev/vde\n</code></pre> <p></p> <p>You could run <code>pvcreate</code> once per disk, but batching them is faster. Check what PVs exist:</p> <p></p> <p>Or inspect details for one:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#create-a-volume-group-vg","title":"Create a Volume Group (VG)","text":"<p>Now, we pool those PVs into a volume group. This becomes our central storage bucket.</p> Create Volume Group<pre><code># vgcreate &lt;nameOfVolumeGroup&gt; &lt;disksToAdd&gt;\nvgcreate vg_demo /dev/vdb /dev/vdc /dev/vdd /dev/vde\n</code></pre> <p></p> <p>From here: - Add/remove disks as PVs - Create/remove logical volumes from the pool</p> <p>Some useful VG commands:</p> Explore Volume Groups<pre><code>vgscan          # scan for groups\nvgs             # list groups\nvgdisplay vg_demo   # show details\n</code></pre> <p></p> <p>List volume groups with <code>vgs</code>:</p> <p></p> <p>List information about a specific volume group with <code>vgdisplay &lt;volumeGroup&gt;</code>:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#create-a-logical-volume-lv","title":"Create a Logical Volume (LV)","text":"<p>Now for the fun part: carve out an LV from the VG.</p> <p>In this demo, we\u2019ll: -  Use RAID5 - Allocate 50% of the VG\u2019s free space - Name it <code>lv_demo</code></p> <p>Create Logical Volume<pre><code>#lvcreate --type &lt;asRequired&gt; -l &lt;size&gt; -n &lt;lvName&gt; &lt;vgName&gt;\nlvcreate --type raid5 -l 50%FREE -n lv_demo vg_demo\n</code></pre> </p> <p>Explore existing LVs with <code>lvs</code>:</p> <p></p> <p>And <code>lvdisplay</code>:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#make-a-file-system-on-the-logical-volume","title":"Make a File System on the Logical volume","text":"<p>Logical volumes are block devices, just like disks. They need a filesystem before use.</p> <p>By default, they live under <code>/dev/&lt;VG&gt;/&lt;LV&gt;</code>. Format with <code>mkfs</code>:</p> Make a File System on the Logical Volume<pre><code>#mkfs.&lt;fstype&gt; &lt;location&gt;\nmkfs.xfs /dev/vg_demo/lv_demo\n</code></pre> <p></p> <p>Then create a mount point - <code>mkdir /lvmDemo</code>.</p>"},{"location":"administering_linux/lvm_basics/#permanently-mount-the-logical-volume","title":"Permanently Mount the Logical Volume","text":"<p>Check the UUID of the LV: </p> <p>Append its UUID to <code>/etc/fstab</code> safely:</p> <p>Send LVM UUID to /etc/fstab<pre><code>#blkid -s UUID -o value &lt;location of LVM under /dev/mapper&gt;\nblkid -s UUID -o value /dev/mapper/vg_demo-lv_demo &gt;&gt; /etc/fstab\n</code></pre> </p> Append, Don't Overwrite! <p>Always back up <code>/etc/fstab</code> before editing. And double-check the output before appending.</p> <p>The new line in /etc/fstab should look like:</p> <p></p>"},{"location":"administering_linux/lvm_basics/#validate","title":"Validate","text":"<p>Run:</p> Validate LVM Mount<pre><code>mount -a\nmount | grep lv_demo\nfindmnt --verify\n</code></pre> <p></p> <p>Test it by creating files:</p> <p></p> Set Permissions <p>Right now, the LV is owned by <code>root</code>. Adjust ownership/permissions so  other users can use it \u2014 see  Basic Linux Permissions.</p> <p>Finally, reboot to confirm everything survives startup.</p> <p>\ud83c\udf89 Congrats \u2014 you\u2019ve just built a flexible, enterprise-grade storage setup with LVM.</p>"},{"location":"administering_linux/network_file_share_server/","title":"Serving Up Network Storage","text":"<p>One of the coolest perks of running a server is sharing storage across your network. Enter NFS (Network File System) \u2014 a way to let client machines access storage as if it were local.</p> <p>Why is this handy? A few classic use cases: - Centralized home directories (often paired with LDAP) - Applications needing a shared data store - Multiple servers writing logs to one place</p> <p>Honestly, the use cases are endless \u2014 and the setup is refreshingly simple.</p> Server-Side NFS Setup <p>This article covers setting up the server side. See Accessing Network Storage for how to mount NFS shares on clients.  \u26a0\ufe0f You\u2019ll need <code>root</code> for all of this. Storage and networking are not \u201cnormal user\u201d territory.</p>"},{"location":"administering_linux/network_file_share_server/#step-1-install-the-nfs-server-package","title":"Step 1: Install the NFS Server Package","text":"<p>First, add the NFS service. Package names differ by distro:</p> Install NFS Server Package<pre><code>dnf install nfs-utils # RHEL Family\napt install nfs-kernel-server # Debian Family\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#step-2-create-an-export-listing","title":"Step 2: Create an Export Listing","text":"<p>Exports tell NFS which directories you want to share. You almost never share the whole filesystem \u2014 it\u2019s much safer (and saner) to create a dedicated share, e.g. <code>/share</code> or <code>/logs</code>.</p> <p>Edit <code>/etc/exports</code> and define your shares:</p> Sample /etc/exports File<pre><code>/sharedSpace *(rw,no_root_squash)\n/sharedLogs *(rw, no_root_squash)\n</code></pre> <ul> <li><code>rw</code> \u2192 read/write</li> <li><code>no_root_squash</code> \u2192 allows client <code>root</code> to act as <code>root</code> on the share    (use with caution!)</li> </ul>"},{"location":"administering_linux/network_file_share_server/#step-3-enable-the-service-and-adjust-permissions","title":"Step 3: Enable the Service and Adjust Permissions","text":"<p>Turn on the NFS service:</p> Enable NFS Service<pre><code>systemctl enable --now nfs-server # RHEL Family\nsystemctl enable --now nfs-kernel-server # Debian Family\n</code></pre> <p>If you\u2019re running firewalld, allow NFS-related services:</p> Adjust Firewall for NFS<pre><code>firewall-cmd --add-service=nfs\nfirewall-cmd --add-service=rpc-bind\nfirewall-cmd --add-service=mountd\nfirewall-cmd --runtime-to-permanent\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#step-4-validate-with-a-client-system","title":"Step 4: Validate with a Client System","text":"<p>On a client system, check that the server is actually exporting its shares:</p> Find an NFS Share<pre><code># showmount -e &lt;Name_of_NFS_Server&gt; or &lt;IP_of_NFS_Server&gt;\nshowmount -e homeServer # OR\nshowmount -e 192.168.250.250\n</code></pre> <p>Expected output looks like this:</p> Sample Output from showmount<pre><code>Export list for homeServer:\n/sharedSpace *\n/sharedLogs *\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#enterprise-best-practices-for-nfs","title":"Enterprise Best Practices for NFS","text":"<p>A basic NFS setup works fine at home or in a lab, but in Production you\u2019ll want to tighten things up. Here are some smart defaults:</p>"},{"location":"administering_linux/network_file_share_server/#use-root_squash-not-no_root_squash","title":"Use <code>root_squash</code> (not <code>no_root_squash</code>)","text":"<ul> <li>By default, NFS maps remote <code>root</code> users to a harmless local user (usually <code>nfsnobody</code>).</li> <li>This prevents a compromised client from owning your NFS server.</li> <li>Only use <code>no_root_squash</code> for very specific, controlled use cases.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#restrict-access-by-host-or-subnet","title":"Restrict access by host or subnet","text":"<ul> <li>Instead of <code>*</code> (any host), use IPs or CIDR blocks:</li> </ul> Restrict NFS Access by Subnet<pre><code>/sharedSpace 192.168.250.0/24(rw,sync,root_squash)\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#enable-sync-writes","title":"Enable <code>sync</code> writes","text":"<ul> <li>Forces writes to hit disk before returning \u201csuccess.\u201d</li> <li>Safer (though slower) than <code>async</code>.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#set-appropriate-filesystem-permissions","title":"Set appropriate filesystem permissions","text":"<ul> <li>NFS exports don\u2019t override Linux permissions.</li> <li>Make sure your shared directories have correct ownership and mode bits.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#watch-selinux","title":"Watch SELinux","text":"<ul> <li>On RHEL-family systems, SELinux may block NFS exports by default.</li> <li>Enable with:</li> </ul> Enable NFS in SELinux<pre><code>setsebool -P nfs_export_all_rw 1\n</code></pre>"},{"location":"administering_linux/network_file_share_server/#monitor-with-showmount-and-exportfs","title":"Monitor with <code>showmount</code> and <code>exportfs</code>","text":"<ul> <li><code>exportfs -v</code> shows exactly what\u2019s being shared and with what options.</li> <li>Run it after changes to confirm settings are live.</li> </ul>"},{"location":"administering_linux/network_file_share_server/#consider-nfsv4","title":"Consider NFSv4","text":"<ul> <li>Newer, cleaner protocol with better performance and security.</li> <li>Reduces port juggling (everything runs over TCP/2049).</li> </ul> <p>Bottom line: keep it tight. Don\u2019t export wide-open shares unless you\u2019re in a safe lab environment.</p>"},{"location":"automation/caseStatements/","title":"BASH Case Statements","text":"<p>One of the very nice options available in shell scripting is the <code>case</code> statement.  The case statement allows the script to test many different conditionals much more efficiently (in terms of lines of code) than an <code>if/elif/else</code> statement (see Decision Making - <code>if/else</code> Statements for further details).</p> <p>Shell's <code>case</code> statement is similar to the <code>switch</code> statement found in other programming languages (both of which are missing entirely from Python!)</p> <p>As an example, a recent version of Manjaro running i3wm includes the following case statement in its <code>.bashrc</code> file; it decides how to correctly handle compressed files:</p> <p></p>"},{"location":"automation/caseStatements/#case-statement-syntax-and-basic-usage","title":"Case Statement Syntax and Basic Usage","text":"<p>The syntax of the case statement is as follows:</p> <pre><code>case variable in\n    pattern1)\n        command1\n        ;;\n    pattern2)\n        command2\n        ;;\n    pattern3)\n        command3\n        ;;\n    *)\n        default_command\n        ;;\nesac\n</code></pre> <p>Here, <code>variable</code> is the value to check, and <code>pattern1</code>, <code>pattern2</code>, <code>pattern3</code> are the possible values to match. <code>command1</code>, <code>command2</code>, and <code>command3</code> are the commands to be executed a match is found.  The <code>default_command</code> will be executed if none of the patterns match.</p> <p>A very simple example to understand the case statement is as follows:</p> <pre><code>#!/bin/bash\n\n# User is prompted to provide input\necho \"Enter a number between 1 and 3: \"\n# Input is taken from the user\nread num\n\n# Case Statement Evaluates the Response and Responds\ncase $num in\n    1)\n        echo \"You entered one.\"\n        ;;\n    2)\n        echo \"You entered two.\"\n        ;;\n    3)\n        echo \"You entered three.\"\n        ;;\n    *)\n        echo \"Invalid number.\"\n        ;;\nesac\n</code></pre>"},{"location":"automation/caseStatements/#best-practices-for-using-case-statements","title":"Best Practices for Using Case Statements","text":"<p>While case statements can be powerful tools for shell scripting, they can also be tricky to use correctly. Here are some best practices to keep in mind when using case statements:</p> <ol> <li> <p>Use the correct syntax: Make sure that your case statement follows the correct syntax. Any mistakes in the syntax can cause your script to fail.</p> </li> <li> <p>Use meaningful variable names: Choose variable names that are meaningful and descriptive. This will make it easier to understand the purpose of the case statement.</p> </li> <li> <p>Use consistent indentation: Use consistent indentation for each case statement block. This will make it easier to read and understand the code.</p> </li> <li> <p>Use comments: Use comments to explain the purpose of the case statement and each block of code. This will make it easier for others to understand your code.</p> </li> <li> <p>Use patterns wisely: Choose patterns that are easy to understand and maintain. Avoid using complex regular expressions that can be difficult to read and understand.</p> </li> <li> <p>Use a default block: Always include a default block in your case statement. This will ensure that your script handles unexpected values correctly.</p> </li> <li> <p>Keep it simple: Use the case statement only when it is necessary. If a simple if statement can accomplish the same task, use it instead.</p> </li> </ol> <p>Case statements are powerful tools for shell scripting that allow checking the value of a variable and executing different blocks of code based on its value. Enjoy!</p>"},{"location":"automation/ifElseStatements/","title":"BASH If/Else Statements","text":"<p>Shell scripting comes fully equipped with <code>if/else</code> statement capabilities.  This is commonly used to evaluate conditions such as input from parameters, ensure files exist, ensure that processes are running, and there are several other use cases.  The syntax is a little different than some other languages, but for the most part BASH <code>if/else</code> statements are easy, even for those who haven't used other programming languages.</p> <p>In this demo, we'll write a simple script to check if a file exists on the system.  The finished product will work like this:</p> <p></p>"},{"location":"automation/ifElseStatements/#step-1-determine-the-condition","title":"Step 1: Determine the Condition","text":"<p>One of the really fantastic things about shell scripting is that it will run most anything that will run in the standard CLI.  This can make testing conditionals very simple - check the output of any command with the server is running in the desired state, then use that same command in a script.  For example, if checking to see if the SSH service is running, issue this command:</p> <pre><code># Check to see if SSH is mentioned in a PID, removing the grep results, and counting the number of lines in the result\nps aux | grep ssh | grep -v grep | wc -l\n</code></pre> <p>Which results in:</p> <p></p> <p>So, as there is one line returned, there is one SSH process running.  This command could be embedded in any shell script as <code>echo $(ps aux | grep ssh | grep -v grep | wc -l)</code>.  Or, as we'll see below, it could be used as a conditional in an <code>if/else</code> statement.</p> <p>Tip: If the above command is unclear, reverse engineer it by removing the piped sections one-by-one and figure out how this command works.</p> <p>For the script we're about to write, we're going to check if a file exists.  This is a very useful check for scripts that rely on parameter files or logs to exist before they can run correctly.  Its also a useful example to illustrate the versatility and diversity of BASH scripting - it's a conditional that can't be used directly in command-line usage.</p>"},{"location":"automation/ifElseStatements/#step-2-create-the-file","title":"Step 2: Create the File","text":"<p>Before creating any file, it is a smart idea to check and see where the BASH shell is located.  This is standardized to <code>/bin/bash</code>, however, a quick <code>which bash</code> will make sure that BASH is where it is expected</p> <p>Creating the file is as simple as <code>vim testMyFile.sh</code>.  This is the file in which we'll check to see if \"myFile.txt\" exists or not.  After jumping into <code>INSERT</code> mode, add the \"shebang\" line:</p> <pre><code>#!/bin/bash\n</code></pre> <p>This tells the kernel that the contents of the file should be interpreted using the BASH program.  If the \"shebang\" is missing, the file won't run correctly.</p> <p>Note - this also works for other programming languages.  For example, when writing a Python script, the \"shebang\" might be <code>#!/bin/python3</code>, and the kernel will interpret the program using Python</p>"},{"location":"automation/ifElseStatements/#step-3-write-the-ifelse-statement","title":"Step 3: Write the If/Else Statement","text":"<p>Now on to the fun part - writing the <code>if/else</code> statement.  The finished product looks like this:</p> <p></p> <p>Before just copy/pasting this, lets break it down and explain it a little.</p>"},{"location":"automation/ifElseStatements/#the-if-statement","title":"The \"If\" Statement","text":"<p>Any <code>if/else</code> statement starts with <code>if [ &lt;condition&gt; ]; then</code>.  In pseudo-code, this translates to \"if this condition is met, do the following\":</p> <pre><code># If myFile.txt exists, do the following:\nif [ -f myFile.txt ]; then\n    # Write in the terminal that the file exists\n    echo \"The file exists!\"\nfi\n</code></pre> <p>Notice the <code>fi</code> at the end of the statement - this is how an <code>if</code> statement is closed in BASH.  Its just the reverse of <code>if</code>.</p> <p>Note that single square brackets may not work on UNIX operating systems such as AIX and Solaris.  For these systems, use double square-brackets.  Also, the checks for equality are a little unique - for example <code>-gt</code> (greater than) or <code>-le</code> (less than or equal) - rather than more standard <code>&gt;=</code> used by most programming languages.</p>"},{"location":"automation/ifElseStatements/#add-the-catch-all-else","title":"Add the Catch-All \"Else\"","text":"<p>An <code>if</code> statement is plenty useful just by itself.  Adding an <code>else</code> to perform a different action if the condition IS NOT met increases the versatility exponentially.  In our example, if a file exists, we tell the user, \"The file exists!\".  But if the file doesn't exist, we tell them \"Not there!\":</p> <pre><code>if [ -f myFile.txt ]; then\n    echo \"The file exists!\"\n# Catch-all else statement, if file doesn't exist, do this:\nelse\n    # Write to the terminal that the file isn't there\n    echo \"Not there!\"\n    # Write an exit code for the script that shows a generic \"1\" error\n    exit 1\nfi\n</code></pre> <p>Note the <code>exit 1</code> line within the <code>else</code> section.  This is not strictly necessary, but is a good example of what could happen if a condition isn't met.  Having a script exit if conditions for it success are not met is very common in Enterprise Linux scripting.</p> <p>This is a small and simple example with all the unnecessary complexity stripped out.  It would be much more useful if this <code>else</code> statement actually sent an alert or an email to an administrator saying \"The critical file needed for this process is missing!\" - but that might muddle the examination of the <code>else</code> statement.</p>"},{"location":"automation/ifElseStatements/#how-about-multiple-possibilities","title":"How About Multiple Possibilities?","text":"<p>BASH <code>if/else</code> statements also handle multiple possibilities with the <code>elif</code> statement.  It is used in the exact same ways as the <code>if</code> statement.  For example, our script above could be expanded to check if a different file exists instead:</p> <pre><code>if [ -f myFile.txt ]; then\n    echo \"The file exists!\"\nelif [ -f myOtherFile.txt ]; then\n    echo \"The other file exists, using that instead.\"\nelse\n    echo \"Not there!\"\n    exit 1\nfi\n</code></pre>"},{"location":"automation/testingNumberOfParameters/","title":"Testing the Number Of Parameters Passed to a Shell Script","text":"<p>More often than not, custom shell scripts accept parameters supplied by the command-line user.  In case you're wondering what sort of things commonly get passed to custom shell scripts, here are some examples:</p> <ol> <li>Which Process ID (PID) to perform an action on</li> <li>Custom location for a log file</li> <li>Desired location for the output</li> <li>Which database or application to perform an action on</li> <li>Anything else that could be changed on each run of the script.</li> </ol> <p>In situations like these, it may be CRITICAL that the correct number of parameters are supplied (otherwise the script will run incorrectly!).  Writing a quick check to confirm that the correct number of parameters was supplied is a step in the right direction for error checking.  Here's an example:</p> <pre><code>#!/bin/bash\n\nNUM_REQUIRED_PARAMS=2\nnum_params=$#\n\n# Were 2 parameters supplied?\nif [[ num_params -lt $NUM_REQUIRED_PARAMS ]] ; then\n  echo \"Not enough parameters.  This script requires ${NUM_REQUIRED_PARAMS}.\"\n  sleep 2\n  exit 1\nfi\n\n# OPTIONAL - useful for sending parameters to logs\n# for loop showing how many parameters\necho \"You ran this program with ${num_prams} parameters. Here they are:\"\nfor param in \"$@\":\ndo\n   echo \"$param\"\ndone\n</code></pre> <p>Note that this doesn't guarantee that the parameters are in the correct order or have appropriate values supplied.  These conditions should be checked as well.  In a robust script, this would just be the first check of several.</p>"},{"location":"basic_toolset/BASH_shortcuts/","title":"Essential Bash Keyboard Shortcuts","text":"<p>BASH has a ton of shortcuts, but you don\u2019t need to know them all right away. Start with these \u2014 they\u2019ll save you a ton of keystrokes and make life at the command line way smoother.</p> Shortcut What it Does <code>TAB</code> Autocompletes a partially typed command. If there\u2019s more than one match, Bash shows you the options. <code>\u2191 / \u2193</code> Scroll back/forward through your command history. <code>Ctrl+e</code> Jump to the end of the current line. (e = end) <code>Ctrl+a</code> Jump to the start of the current line. (a = alphabet\u2019s start) <code>Ctrl+u</code> Delete everything from the cursor back to the start of the line. <code>Ctrl+k</code> Delete everything from the cursor to the end of the line. <code>Ctrl+w</code> Delete the word just before the cursor. <code>Ctrl+y</code> Paste back (yank) the last thing you deleted with <code>Ctrl+u</code>, <code>Ctrl+k</code>, or <code>Ctrl+w</code>. <code>Ctrl+l</code> Clear the screen (like the <code>clear</code> command). <code>Ctrl+c</code> Cancel/kill the currently running command or process. <code>Ctrl+z</code> Pause the current job (suspends it in the background). <code>fg</code> Resume the most recent job that was paused with <code>Ctrl+z</code>. <code>bg</code> Resume the paused job, but keep it running in the background. <code>Ctrl+d</code> Log out of the current shell (or send an EOF if in a prompt). <code>Ctrl+r</code> Reverse search through your command history. Type part of a command and Bash will find it. (Game-changer!) <code>!!</code> Run the last command again. (<code>sudo !!</code> is a classic trick.) <p>\ud83d\udc49 Pro tip: Start with <code>TAB</code>, <code>Ctrl+r</code>, and <code>Ctrl+c</code>. Those three alone will change your Bash life.</p>"},{"location":"basic_toolset/file_pagers/","title":"File Pagers","text":"<p>When you\u2019re poking around in Linux and want to peek inside a file, you\u2019ve got a handful of handy pager commands at your disposal. Here are some of the ones you can use, plus a few tips for each.</p>"},{"location":"basic_toolset/file_pagers/#more","title":"<code>more</code>","text":"<p>Think of <code>more</code> as the classic, old-school pager. Press Space to keep moving through the file. You can also search with <code>/</code>, just like in <code>man</code> pages or <code>vim</code>.</p> <pre><code>more myFile.txt\ncat myFile.txt | more\n</code></pre>"},{"location":"basic_toolset/file_pagers/#less","title":"<code>less</code>","text":"<p>This is the pager most folks actually use day-to-day. It fixes a bunch of <code>more</code>\u2019s limitations: you can scroll with the arrow keys or Space, and <code>/</code> search works here too. Once you try it, you\u2019ll rarely go back.</p> <pre><code>less myFile.txt\ncat myFile.txt | less\n</code></pre>"},{"location":"basic_toolset/file_pagers/#view","title":"<code>view</code>","text":"<p>This one\u2019s basically <code>vim</code> in read-only mode. You get all the movement and search powers of <code>vim</code>, but by default you can\u2019t save changes \u2014 unless you really mean it with a <code>!</code> (and have write permissions).</p> <pre><code>view myFile.txt\n</code></pre>"},{"location":"basic_toolset/file_pagers/#cat","title":"<code>cat</code>","text":"<p>Not technically a pager, but worth mentioning. <code>cat</code> just dumps the whole file to your terminal in one go. Perfect for tiny files, less fun for giant log monsters. It\u2019s also a common building block when you\u2019re piping output to other commands.</p> <pre><code>cat myFile.txt\ncat myFile.txt | grep -v 'notLinesWithThisText'\n</code></pre> Not sure which to use? <p>If you\u2019re not sure which to use, start with <code>less</code>. It\u2019s faster, friendlier, and more flexible than the others. Happy paging! \ud83c\udf89</p>"},{"location":"basic_toolset/shell_history/","title":"Using Shell History","text":"<p>Most Command Line Shells have a built-in feature to record commands you've run. This is handy for two reasons: it keeps a record of what you've done, and it makes it super easy to repeat commands without retyping them. We'll focus on BASH here, since it's the most common shell in enterprise Linux.</p> <p>To see your command history, just type:</p> <pre><code>history\n</code></pre> <p>These commands are stored in your <code>~/.bash_history</code> file.</p> <p></p> <p>The size of your history is controlled by two environment variables: <code>HISTSIZE</code> and <code>HISTFILESIZE</code>. Where these are set depends on your Linux distribution. On RHEL-family systems, <code>/etc/profile</code> sets a default <code>HISTSIZE</code> of 1,000. On Debian-based systems, each user inherits a <code>HISTFILESIZE</code> of 2,000 and a <code>HISTSIZE</code> of 1,000 from <code>/etc/skel/.bashrc</code>.</p> <p>If you want to keep more (or fewer) commands in your history, you can change these values in your own <code>~/.bashrc</code> file.</p>"},{"location":"basic_toolset/shells/","title":"Enterprise Command Line Shells","text":"<p>In UNIX and Linux, a shell is the basic program you use at the command line. Some folks say the name is a metaphor for a snail \u2014 the shell wraps around the kernel. Like most things in Linux, there are lots of different shells, often building on each other and fixing the quirks of earlier versions. Examples include ZSH, FISH, and plenty more.</p> Graphical vs Command-Line Shells <p>Technically, shells can be graphical too \u2014 <code>GNOME</code> and <code>KDE</code> are popular examples. These are rarely (if ever) used on servers.</p> <p>In Enterprise Linux, only a few command-line shells are widely used:</p>"},{"location":"basic_toolset/shells/#bash-bourne-again-shell","title":"BASH (Bourne-Again Shell)","text":"<ul> <li>By far the most common shell in Enterprise Linux. All Linux distributions   have BASH available, even if it's not the default. Not all UNIX systems   include BASH.</li> <li>Standard file location: <code>/bin/bash</code> or <code>/usr/bin/bash</code></li> <li><code>#!/bin/bash</code> is usually at the top of shell scripts so the kernel   knows which interpreter to use.</li> </ul>"},{"location":"basic_toolset/shells/#ksh-korn-shell","title":"KSH (Korn Shell)","text":"<ul> <li>Still popular on some UNIX systems like AIX.</li> <li>Lacks some features standard in BASH, like tab-completion and   \"up-arrow\" history.</li> </ul>"},{"location":"basic_toolset/shells/#sh-shell","title":"SH (Shell)**","text":"<ul> <li>The original shell interface used in UNIX.</li> <li>Still exists in modern Linux distributions.</li> <li>Standard file location: <code>/bin/sh</code> or <code>/usr/bin/sh</code></li> </ul>"},{"location":"basic_toolset/text_editors/","title":"Text Editors","text":"<p>Command Line Text Editors</p> <p>If you spend any time on the command line, you\u2019ll eventually need to edit text files. Configs, scripts, logs \u2014 they all come up sooner or later. Having a good text editor at your fingertips isn\u2019t just handy, it\u2019s essential.</p> <p>Here are the usual suspects you\u2019ll run into:</p>"},{"location":"basic_toolset/text_editors/#nano","title":"Nano \ud83c\udf7c","text":"<ul> <li>Super beginner-friendly. You can open a file and start typing \u2014 no weird   key combos required.</li> <li>Great for quick edits, but pretty limited compared to the big players.</li> <li>Old-school sysadmins sometimes roll their eyes when they see someone using   Nano (\u201crookie move!\u201d).</li> <li>Installed by default on basically every Linux distro, so it\u2019s always there   as a fallback.</li> </ul> <p>Think of Nano as the training wheels of text editors \u2014 nothing wrong with it, but you\u2019ll probably outgrow it.</p>"},{"location":"basic_toolset/text_editors/#vi-vim","title":"Vi / Vim \u26a1","text":"<ul> <li>The industry standard for editing files in Linux. If you\u2019re serious about   command line work, Vim is the one to know.</li> <li>On most modern systems, typing <code>vi</code> actually launches <code>vim</code> (a supercharged   version of the original <code>vi</code>).</li> <li>Some older UNIX systems still use the plain <code>vi</code>, so it\u2019s worth knowing the   basics.</li> <li>Always available \u2014 it\u2019s installed on every Linux system by default.</li> </ul> <p>Yes, Vim has a bit of a learning curve. Yes, you will forget how to quit at least once. But once you learn the ropes, it\u2019s incredibly powerful and fast. (Your future self will thank you.)</p>"},{"location":"basic_toolset/text_editors/#emacs","title":"Emacs \ud83e\udde0","text":"<ul> <li>Another legendary editor, though not nearly as common in Enterprise Linux   land.</li> <li>Developers tend to love it more than sysadmins.</li> <li>Learning curve? Steep. But the documentation is fantastic.</li> <li>Usually not installed by default, so you\u2019ll have to add it yourself if you   want to give it a spin.</li> </ul> <p>Emacs isn\u2019t just an editor \u2014 some folks basically live inside it. (Email, calendar, games\u2026 you name it.) It\u2019s a rabbit hole, but a fun one if you\u2019re curious.</p>"},{"location":"basic_toolset/text_editors/#bottom-line","title":"\ud83d\udc49 Bottom Line","text":"<ul> <li>Nano is the quick and easy option.</li> <li>Vim is the go-to tool every sysadmin is expected to know.</li> <li>Emacs is powerful but niche, especially on enterprise systems.</li> </ul>"},{"location":"development/development/","title":"Software Development with Enterprise Linux","text":""},{"location":"development/development/#application-development","title":"Application Development","text":"<p>One of the primary objectives of Enterprise Linux systems is to support application development and hosting.</p> <p>Introducing Podman</p> <p>Running Rootless Containers As Services</p>"},{"location":"development/development/#kernel-development","title":"Kernel Development","text":"<p>The Linux kernel is under constant development.  With every release, it improves its ability to support application development and hosting.  </p> <p>Linux Kernel on GitHub</p> <p>Linux Kernel Documentation</p>"},{"location":"development/introducingPodman/","title":"Introducing Podman","text":"<p>Podman, short for Pod Manager is an enterprise-grade containerization tool.  Although it is largely associated with the RHEL family of distributions, it is a stand-alone project that runs on all enterprise-grade Linux distributions. See Podman.io for tons of documentation.</p>"},{"location":"development/introducingPodman/#docker-vs-podman","title":"Docker vs Podman","text":"<p>Docker has been the containerization standard for several years in enterprise computing.  However, Podman is a strong competitor with several significant advantages.  These can be summarized as:</p> Docker Podman Separate Daemon? Uses Docker daemon Daemonless architecture Requires Root Access? Runs containers as <code>roo</code>t only Runs containers as <code>root</code> and non-<code>root</code> How are Images Built? YAML-Based DockerFile YAML-Based Image File, Buildah tool Monolithic Architecture? Yes No Container Orchestration? Yes Yes Integrated into the Linux Kernel? No Yes <p>The biggest advantages that Podman enjoys is that it is daemonless - meaning that <code>root</code> access is not needed to run containers.  This is incredibly developer-friendly in enterprise computing, as developers rarely have <code>root</code> access to servers.  Directly related to this daemonless architecture is that Podman is better integrated into the Linux kernel.  This has to do with the actual libraries in use and is beyond the scope of this article, but in short Podman is more Linux-kernel friendly.</p> <p>Note that setting up Podman still requires <code>root</code> access - much the same as installing other software requires <code>root</code>.  However, once installed and configured, developers can run as many containers as they have resources to support without super-user powers.</p> <p>The biggest challenge related to using  Podman is that because Docker is so ubiquitous, it is easy to find playbooks that include Docker containers which developers have to \"translate\" into a Podman version.  Luckily, Podman and Docker are largely command-equivalent (at least in recent versions) and this is becoming less and less of a challenge.</p>"},{"location":"development/introducingPodman/#command-equivalent-to-docker","title":"Command-Equivalent to Docker","text":"<p>For developers who have used Docker in the past, it comes as a huge relief to know that Podman is command-equivalent in most regards.  This means that <code>podman run -p 80:80 nginx:latest</code> will produce exactly the same result as <code>docker run -p 80:80 nginx:latest</code> (all else being equal).  So, while there will be some minor migration pains, the process is a minor inconvenience at worst.</p>"},{"location":"development/introducingPodman/#a-quick-demo","title":"A Quick Demo","text":"<p>Podman containers are created in the exact same way as other containers.  The standard demo for this is to simply run <code>podman run -d -p 8080:80 nginx</code> which spins up an <code>nginx</code> webserver at <code>localhost:8000</code>.  While this does show a container running, a more complicated demo might be closer to something found in enterprise.</p>"},{"location":"development/introducingPodman/#the-business-requirement-private-cloud-for-a-small-business","title":"The Business Requirement: Private Cloud for a Small Business","text":"<p>Imagine a small business needs a private document storage solution for all its employee documents but doesn't want to use a public system such as Google Drive or Dropbox due to privacy and/or regulatory concerns.  Using Podman, it is relatively simple to host a containerized private storage cloud such as NextCloud on a local server (either physical or virtual).</p> <p>This would also work as a private instance on a public cloud service such as AWS or Azure but these are outside the scope of this article (and may or may not meet privacy/regulatory requirements).</p>"},{"location":"development/introducingPodman/#the-solution-containerized-nextcloud","title":"The Solution: Containerized NextCloud","text":"<p>While Podman comes pre-installed on RHEL8 and up, if it is missing, it is easy to install Podman with <code>dnf install podman</code> or <code>apt install podman</code>(depending on the distribution).  With Podman installed, issue the following commands (obviously changing the passwords/ports as needed):</p> <pre><code># Creating a new Podman network\npodman network create nextcloud-net\n\n# Creating volumes in which to store the Nexcloud Data\npodman volume create nextcloud-app\npodman volume create nextcloud-data\npodman volume create nextcloud-db\n\n# Deploy Mariadb (underlying database for NextCloud)\npodman run --detach --env MYSQL_DATABASE=nextcloud --env MYSQL_USER=nextcloud \\\n--env MYSQL_PASSWORD=DB_USER_PASSWORD --env MYSQL_ROOT_PASSWORD=DB_ROOT_PASSWORD \\\n--volume nextcloud-db:/var/lib/mysql --network nextcloud-net \\\n--name nextcloud-db docker.io/library/mariadb:10\n\n# Deploy Nextcloud\npodman run --detach --env MYSQL_HOST=nextcloud-db.dns.podman \\\n--env MYSQL_DATABASE=nextcloud --env MYSQL_USER=nextcloud \\\n--env MYSQL_PASSWORD=DB_USER_PASSWORD --env NEXTCLOUD_ADMIN_USER=NC_ADMIN \\\n--env NEXTCLOUD_ADMIN_PASSWORD=NC_PASSWORD --volume nextcloud-app:/var/www/html \\\n--volume nextcloud-data:/var/www/html/data --network nextcloud-net \\\n--name nextcloud --publish 8889:80 docker.io/library/nextcloud:20\n\n# Credit: https://fedoramagazine.org/nextcloud-20-on-fedora-linux-with-podman/\n</code></pre> <p>Simple as that, an instance of NextCloud is available for use at <code>localhost:8889</code> which of course can also be accessed via IP, via <code>hostfile</code> or via an internal DNS server if the company is so equipped:</p> <p></p> <p>Best of all, the data stored in this container is permanent - residing in the Podman volume <code>nextcloud-data</code> - which can be backed-up and exported in the same way as any other directory on a Linux system.</p> <p>To see how to make running this rootless container part of the boot procedure, see Running Rootless Containers as Services.</p>"},{"location":"development/rootless_containers_as_services/","title":"Running Rootless Containers as Services","text":"<p>When utilizing rootless containers directly on a Linux server, starting and stopping the container manually can become a major hassle, especially if other containers rely on the service.  For this reason, running containers as <code>systemd</code> services that start and stop with the underlying <code>systemd</code> controls provides significant value to developers and system administrators alike.</p> <p>Application Development on Enterprise Linux occurs largely within containerized applications.  While container orchestration platforms like Kubernetes and OpenShift (RHEL's version of Kubernetes with extra features) are often used, there is also a use-case for running a container directly on a Linux server without orchestration, often in the early-stages of development.</p>"},{"location":"development/rootless_containers_as_services/#enable-linger-for-specific-user-account","title":"Enable Linger for Specific User Account","text":"<p>The only part of this process that will require <code>root</code> access is to enable linger for the user that owns the container.  This means that even if the user is not logged in, <code>systemd</code> services associated with that user will start/stop with the server (if they are enabled).  Enabling linger is a simple one-line command:</p> <pre><code>#loginctl enable-linger &lt;user&gt;\nloginctl enable-linger brad\n</code></pre> <p>Now, if the user <code>brad</code> enables a <code>systemd</code> service (as per below), it will start and stop with the server startup/shutdown.</p>"},{"location":"development/rootless_containers_as_services/#create-a-systemd-service-to-control-a-rootless-container","title":"Create a Systemd Service to Control a Rootless Container","text":"<p>Logged in as the linger-enabled user and with a container already running (see Introducing Podman for an example), issue the following commands:</p> <p><pre><code>mkdir ~/.config/systemd/user # create a directory to store the systemd files\ncd ~/.config/systemd/user # switch to that directory\n# podman generate systemd --name &lt;ContainerName&gt; --files\npodman generate systemd --name nextCloud --files # generate the files\nsystemctl --user daemon-reload # make the systemd service aware of the files\n</code></pre> Starting and stopping the container should now be done with <code>systemctl --user start &lt;containerName&gt;.serivice</code>, <code>systemctl --user stop &lt;containerName&gt;.service</code>, or simply check the status with <code>systemctl --user status &lt;containerName&gt;.servicei</code>.  For example, running <code>systemctl --user status container-nextcloud.service</code> results in:</p> <p></p>"},{"location":"development/rootless_containers_as_services/#enable-the-systemd-service-to-run-at-system-startup","title":"Enable the Systemd Service to Run at System Startup","text":"<p>Now that the container is controlled by a <code>systemd</code> service, it can be enabled in a similar way as any other <code>systemd</code> service. The only caveat is to remember to add the <code>--user</code> flag as it is a user service, not a system service:</p> <pre><code># systemctl --user enable &lt;container-ContainerName.service&gt;\nsystemctl --user enable container-nextcloud.service\n</code></pre> <p>Find the name of the container serve in <code>~/.config/systemd/user/</code> directory if necessary.</p> <p>Rebooting the server should now result in the container starting automatically.  This can be validated with a simple <code>ps -ef | grep nextcloud</code> or <code>podman ps | grep nextcloud</code>.</p> <p>Depending on the application setup, it may be necessary to repeat this process and even edit the <code>systemd</code> service files to ensure the containers start in the correct order to resolve their dependencies on each other (outside the scope of this article).  For example, the container setup in Introducing Podman requires that the MariaDB container be started before the NextCloud container.</p>"},{"location":"essential_concepts/file_permissions/","title":"File Permissions","text":"<p>File permissions in Linux can feel like a maze at first \u2014 lots of letters, dashes, and gotchas. But don\u2019t worry: once you break it down, it\u2019s actually pretty logical.</p> <p>One big thing to keep in mind: in Linux, everything is a file. Yep, everything \u2014 text files, devices, directories, even your monitor connection. And all of them have permissions attached.</p> <p>You can peek at permissions with ls -ltr. For example:</p> Listing Files with Permissions<pre><code>-rwxr--r--  1 root root     2354 Feb 17 08:54 .bashrc\n</code></pre>"},{"location":"essential_concepts/file_permissions/#file-ownership","title":"File Ownership","text":"<p>Every file has two owners:</p> <ul> <li>a user (the actual owner)</li> <li>a group (a collection of users)</li> </ul> <p>Here\u2019s that same example with some arrows added:</p> Group and User Ownership<pre><code>-rwxr--r--  1 root   root     2354 Feb 17 08:54 .bashrc\n               ^      ^\n             owner  group\n</code></pre> Permissions are not additive <p>Linux permissions are not additive.  This means that if a user falls into a category (owner, group, or other), Linux doesn't perform any further checks or processing.  Whatever the permissions of the first matching category are the effective permissions for the file.</p>"},{"location":"essential_concepts/file_permissions/#permissions-on-files","title":"Permissions on Files","text":"<p>Now let\u2019s zoom in on that left-hand side:</p> <pre><code>   -        rwx    r--    r--\n   ^         ^      ^      ^\nfile type  owner  group  other\n</code></pre> <p>That cryptic string breaks down into three sets of permissions: - r = read (open the file and look at it) - w = write (change it) - x = execute (run it as a program/script)</p> <p>In the <code>.bashrc</code> example:</p> <ul> <li>The owner (root) can read, write, and execute.</li> <li>The group (root) can only read.</li> <li>Everyone else (the \u201cother\u201d category) can only read too.</li> </ul>"},{"location":"essential_concepts/filesystem_hierarchy/","title":"Linux Filesystem Hierarchy","text":"<p>If you've spent any time with Linux, you'll notice that totally different distributions share a similar file structure \"under the hood.\" Even UNIX systems like IBM's AIX have a layout that's a lot like standard Linux distros.</p> <p>Why? It's thanks to the Linux File Hierarchy Standard (FHS), maintained by the Linux Foundation. The FHS defines the standard directories you should find on any Linux system. There's some wiggle room in where files go inside those directories, but for the most part, all compliant Linux distributions stick to this structure:</p> Linux Filesystem Hierarchy<pre><code>root@localhost /]# ls -ltr\ntotal 20\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 srv\nlrwxrwxrwx.   1 root root    8 Aug  9  2022 sbin -&gt; usr/sbin\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 opt\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 mnt\ndrwxr-xr-x.   1 root root    0 Aug  9  2022 media\nlrwxrwxrwx.   1 root root    9 Aug  9  2022 lib64 -&gt; usr/lib64\nlrwxrwxrwx.   1 root root    7 Aug  9  2022 lib -&gt; usr/lib\nlrwxrwxrwx.   1 root root    7 Aug  9  2022 bin -&gt; usr/bin\ndr-xr-xr-x.   1 root root    0 Aug  9  2022 afs\ndrwx------.   1 root root    0 Nov  5 05:14 lost+found\ndrwxr-xr-x.   1 root root  168 Nov  5 05:21 usr\ndrwxr-xr-x.   1 root root  194 Nov  5 05:28 var\ndr-xr-xr-x.   6 root root 4096 Mar  9 20:07 boot\ndrwxr-xr-x.   1 root root    8 Mar  9 20:07 home\ndrwxr-xr-x.   1 root root 5000 Mar  9 20:10 etc\ndr-xr-x---.   1 root root  208 Mar  9 20:10 root\ndr-xr-xr-x. 291 root root    0 Mar 23 09:35 proc\ndr-xr-xr-x.  13 root root    0 Mar 23 09:35 sys\ndrwxr-xr-x.  20 root root 3980 Mar 23 09:35 dev\ndrwxr-xr-x.  56 root root 1520 Mar 23 09:35 run\ndrwxrwxrwt.  18 root root  420 Mar 23 09:35 tmp\n[root@localhost /]#\n</code></pre> <p>Since Linux is a self-documenting operating system (see Finding Help in Linux, there's a Manual page that explains the file system hierarchy. Just run <code>man hier</code> on any distro, read, learn, and enjoy!</p>"},{"location":"essential_concepts/filesystem_hierarchy/#ephemeral-vs-persistent-file-systems-and-directories","title":"Ephemeral vs Persistent File Systems and Directories","text":"<p>Not everything in the above listing is a file or directory stored on your hard drive. In particular, <code>/proc</code> and <code>/run</code> (and sometimes <code>/tmp</code>) are \"ephemeral\" directories mounted on RAM-based file systems. They're created during boot and only exist for your current session. If you accessed the hard drive without booting Linux (say, from another OS), <code>/proc</code> and <code>/run</code> wouldn't be there.</p> <p>So, changes you make in these directories (modifying <code>/run</code> is more common and less risky than <code>/proc</code>) only last until you reboot. After that, things reset to whatever the kernel finds at boot.</p> <p>If you want changes to stick around after a reboot, make them in <code>/etc/</code>. That's where persistent configuration lives.</p>"},{"location":"getting_around/finding_files/","title":"Finding Files in Linux","text":"<p>One of the first things you\u2019ll bump into on Linux is the question: \u201cWhere the heck did that file go?\u201d \ud83d\udd75\ufe0f Whether you\u2019re trying to track down a rogue config, a missing binary, or just want to see what\u2019s eating up disk space, Linux gives you a handful of tools \u2014 each with its own quirks.</p>"},{"location":"getting_around/finding_files/#the-toolbox","title":"The Toolbox","text":"<p>Here\u2019s a quick rundown of the main commands you\u2019ll use to find files:</p>"},{"location":"getting_around/finding_files/#ls-just-listing-not-finding","title":"<code>ls</code> \u2013 Just Listing, Not Finding","text":"<p>The <code>ls</code> command is for listing files in a directory, not searching for them. Think of it like peeking into a folder \u2014 helpful when you already know where you are, but useless if you\u2019ve lost track of the thing entirely.</p> Listing /etc with ls<pre><code>ls /etc\n</code></pre>"},{"location":"getting_around/finding_files/#which-hunting-binaries-in-your-path","title":"<code>which</code> \u2013 Hunting Binaries in Your <code>$PATH</code>","text":"<p>If you\u2019re wondering \u201cWhere is this program actually located?\u201d, <code>which</code> has your back. It looks through your <code>$PATH</code> (the list of directories Linux checks for commands) and shows you where an executable lives.</p> Finding bash with which<pre><code>which bash\n# /usr/bin/bash\n</code></pre> <p>Only works for binaries, though. If you\u2019re trying to find a random text file, you\u2019re out of luck.</p>"},{"location":"getting_around/finding_files/#locate-speedy-but-database-driven","title":"<code>locate</code> \u2013 Speedy (but Database-Driven)","text":"<p><code>locate</code> is like a cheat sheet: instead of crawling your disk live, it searches a pre-built database. That\u2019s why it\u2019s lightning fast, but the results can be stale if the database isn\u2019t updated.</p> <p>The database is refreshed by running:</p> Updating the locate Database<pre><code>sudo updatedb\n</code></pre> <p>Then you can search for files by name:</p> <p>Using locate to Find Files<pre><code>locate myFile.txt\n# /home/user/documents/myFile.txt\n</code></pre> If it feels instant, that\u2019s because it is \u2014 <code>locate</code> already did the heavy lifting in the background.</p>"},{"location":"getting_around/finding_files/#find-the-heavyweight-champion","title":"<code>find</code> \u2013 The Heavyweight Champion","text":"<p>When you need flexibility, <code>find</code> is your best friend. It actually walks the filesystem, checking names, types, sizes, permissions, and even content if you chain it with other tools. Slower than locate, but way more powerful.</p> <p>Here are some real-world examples:</p> <p>Find every file or directory named hosts starting at root (<code>/</code>):</p> Finding Files or Directories Named hosts<pre><code>find / -name \"hosts\"\n</code></pre> <p>Find files larger than 100 MB in the root directory:</p> Finding Large Files<pre><code>find / -type f -size +100M\n</code></pre> <p>Search for files in <code>/etc</code> containing the word \"student\", then copy them to <code>find/contents</code>:</p> Finding Files by Content<pre><code>find /etc -exec grep -l student {} \\; -exec cp {} find/contents/ \\; 2&gt; /dev/null\n</code></pre> <p>Combine with <code>xargs</code> for speed: find all files in <code>/etc</code> and search them for 127.0.0.1:</p> Using find with xargs<pre><code>find /etc -name '*' -type f | xargs grep \"127.0.0.1\"\n</code></pre> <p>It\u2019s a Swiss Army knife \u2014 intimidating at first, but once you get comfortable, you\u2019ll wonder how you ever lived without it.</p>"},{"location":"getting_around/finding_files/#common-gotchas","title":"Common Gotchas","text":"<p>Even pros run into these snags:</p>"},{"location":"getting_around/finding_files/#permission-errors-with-find","title":"Permission errors with <code>find</code>","text":"<p>Running <code>find</code> against a directory where the user doesn't have permissions will throw lots of \"Permission denied\" errors. Options:</p> <ul> <li>Run with <code>sudo</code></li> <li>Or redirect errors to the void:</li> </ul> Redirecting find Errors<pre><code>find / -name \"hosts\" 2&gt;/dev/null\n</code></pre>"},{"location":"getting_around/finding_files/#locate-database-is-out-of-date","title":"<code>locate</code> database is out of date","text":"<p>Since <code>locate</code> relies on a database, you may see files that don\u2019t exist anymore (or miss new ones). Fix it with:</p> Updating the locate Database<pre><code>sudo updatedb\n</code></pre>"},{"location":"getting_around/finding_files/#which-only-shows-the-first-match-in-path","title":"<code>which</code> only shows the first match in <code>$PATH</code>","text":"<p>If you have multiple versions of a binary installed, <code>which</code> won\u2019t tell you about the others. Use:</p> Finding All Instances of bash<pre><code>type -a bash\n</code></pre>"},{"location":"getting_around/finding_files/#quoting-matters-in-find","title":"Quoting matters in <code>find</code>","text":"<p><code>find / -name hosts</code> will work, but if your filename includes special characters (*, ?, spaces), you\u2019ll want quotes:</p> Using Quotes with find<pre><code>find / -name \"my file*\"\n</code></pre>"},{"location":"getting_around/finding_files/#xargs-can-choke-on-spaces","title":"<code>xargs</code> can choke on spaces","text":"<p>When piping filenames with spaces into <code>xargs</code>, it may split them incorrectly. Use:</p> Handling Spaces with xargs<pre><code>find /etc -type f -print0 | xargs -0 grep \"127.0.0.1\"\n</code></pre>"},{"location":"getting_around/finding_files/#quick-recap","title":"Quick Recap","text":"<ul> <li><code>ls</code> \u2192 Show me what\u2019s here.</li> <li><code>which</code>- \u2192 Where\u2019s that program in <code>$PATH</code>?</li> <li><code>locate</code> \u2192 Fast, but needs an up-to-date database.</li> <li><code>find</code> \u2192 Slow but powerful; can match on almost anything.</li> </ul> <p>\ud83d\udc49 Pro tip: If you\u2019re not sure which tool to reach for, start with <code>locate</code> for speed. If it doesn\u2019t cut it, switch to <code>find</code> for more control.</p>"},{"location":"getting_around/finding_help/","title":"Finding Help in Linux","text":"<p>Lost in the terminal? Don't worry \u2014 Linux has your back with tons of built-in help. Whether you're just poking around or knee-deep in shell scripts, there's always a way to get unstuck. Let's walk through some handy ways to find help (and maybe a few hidden gems) right from your command line.</p>"},{"location":"getting_around/finding_help/#1-manual-pages-man","title":"1. Manual Pages (<code>man</code>)","text":"<p>The classic move: check the manual! Linux comes loaded with \"man pages\" \u2014 detailed guides for almost every command and utility. To peek at the manual for a command, just type:</p> <pre><code>man &lt;command&gt;\n</code></pre> <p>Curious about <code>lvcreate</code>? Try:</p> <pre><code>man lvcreate\n</code></pre> <p>Results in: </p> <p>You'll get a full rundown: what the command does, all its options, and some usage notes. It's like having a wise old wizard explain things (with extra beard).</p>"},{"location":"getting_around/finding_help/#navigating-the-manual-pages","title":"Navigating the Manual Pages","text":"<ul> <li>Search: Hit <code>/</code>, type your keyword, and press Enter to jump to what   you need.</li> <li>Quit: Press <code>q</code> when you're done (no need to be polite).</li> <li>Scroll: Use the arrow keys or spacebar to move around.</li> </ul>"},{"location":"getting_around/finding_help/#rebuilding-the-manual-pages","title":"Rebuilding the Manual Pages","text":"<p>Just installed Linux and <code>man</code> seems a bit empty? Sometimes the manual page database needs a refresh. You can rebuild it with:</p> <pre><code>mandb\n</code></pre> <p>This updates the index so you get the latest docs. Handy if you've just added new packages or tools.</p>"},{"location":"getting_around/finding_help/#manual-page-sections-a-quick-map","title":"Manual Page Sections (A Quick Map)","text":"<p>Man pages are split into sections \u2014 think of them as chapters in a choose-your-own-adventure book:</p> <ul> <li>1: User commands (the stuff you'll run most often)</li> <li>2: System calls (how programs talk to the kernel)</li> <li>3: Library calls (functions in libraries)</li> <li>4: Special files (usually in <code>/dev</code>)</li> <li>5: File formats and conventions (like <code>/etc/passwd</code>)</li> <li>6: Games (yes, really)</li> <li>7: Miscellaneous (macros, conventions, and oddities)</li> <li>8: System admin commands (for the brave and root users)</li> <li>9: Kernel routines (advanced stuff)</li> </ul> <p>If you're just starting out, sections 1 and 8 are your best friends. Sections 5 and 7 are great for file formats and conventions.</p> <p>But what if you don\u2019t even know the command\u2019s name yet? That\u2019s where searching comes in.</p>"},{"location":"getting_around/finding_help/#2-fuzzy-searching-for-commands","title":"2. Fuzzy Searching For Commands","text":"<p>Can't remember the exact command? No problem \u2014 Linux lets you search by keyword:</p> <ul> <li><code>man -k &lt;keyword&gt;</code>: Lists all commands related to your keyword.</li> <li><code>apropos &lt;keyword&gt;</code>: Does the same thing, just with a different   name.</li> </ul> <p>For example, to find anything about networking:</p> <pre><code>man -k network\n</code></pre> <p>Or:</p> <pre><code>apropos network\n</code></pre> <p>Want to narrow it down even more? Pipe it through <code>grep</code>:</p> <pre><code>man -k network | grep &lt;subkeyword&gt;\n</code></pre> <p>It's like asking Linux, \"Hey, what do you know about this?\" \u2014 and getting a list of everything it can find.</p> <p>Once you\u2019ve found the right command, though, you don\u2019t always need the full manual. Sometimes you just want a quick hint \u2014 enter <code>--help</code>.</p>"},{"location":"getting_around/finding_help/#3-quick-hints-with-the-help-option","title":"3. Quick Hints with the <code>--help</code> Option","text":"<p>Almost every Linux command has a built-in help option you can summon with <code>--help</code>. Think of it as the command whispering, \u201cHere\u2019s what I can do\u201d \u2014 without dragging you through the whole manual.</p> <p>Try this with <code>ls</code>:</p> <pre><code>ls --help\n</code></pre> <p>You\u2019ll get a concise list of options, their meanings, and sometimes even a few examples. It\u2019s perfect when you just need a quick refresher.</p> <p>A couple of tips:</p> <ul> <li> <p>Single vs double dash: Some older commands use <code>-h</code> instead of <code>--help</code>. If <code>--help</code> doesn\u2019t work, try <code>-h</code>.</p> </li> <li> <p>Too much text? Pipe it into <code>less</code> to make it scrollable:</p> <pre><code>ls --help | less\n</code></pre> </li> <li> <p>Not universal: A few grumpy old commands (looking at you, <code>vi</code>)   don\u2019t play by these rules \u2014 in those cases, man is still your friend.</p> </li> </ul> <p>This is usually the fastest way to jog your memory on a command\u2019s options. For deeper dives or background details, head back to the <code>man</code> pages.</p> <p>With these tricks \u2014 man pages for the deep dives, fuzzy searching when you can\u2019t quite remember the name, and the handy <code>--help</code> flag for a quick refresher \u2014 you\u2019ll never be stuck for long.</p> <p>The Linux help system is deep, but friendly once you know where to look. Keep exploring, keep asking questions, and remember: even the pros check the manual (sometimes twice).</p>"},{"location":"getting_around/generating_the_manual/","title":"Generating the Manual","text":"<p>A listing of the pages in the Manual is stored in a system-generated database. Accessing them is as simple as running <code>man &lt;command&gt;</code>, and you'll usually get a detailed listing of how to use that command. Check out Finding Help in Linux for more info about using <code>man</code>.</p>"},{"location":"getting_around/generating_the_manual/#help-the-manual-is-missing","title":"Help! The Manual is Missing!","text":"<p>On a freshly created Linux system, it's common for the Manual Pages to not be generated yet. Running <code>man &lt;command&gt;</code> might give you an error, even for basic utilities like <code>ls</code>. That's a pain \u2014 especially since new systems often mean running lots of commands with rarely-used options. Sometimes, the Manual can also get outdated after a software update and need a rebuild.</p> <p>Most Linux distributions use a scheduled job to generate the Manual, usually once a day. But if you need it right now, you can update the Manual yourself in a flash. Just run:</p> <pre><code>mandb\n</code></pre> <p></p> <p>Once that's done, your Manual will be fully stocked and ready for exploration. Happy learning!</p>"},{"location":"getting_around/using_the_command_line/","title":"Using The Command Line","text":"<p>In Enterprise Linux, the command line is the tool of choice for most tasks. Getting comfortable with it is key \u2014 most developers and admins SSH into servers and use the command line for their daily work.</p>"},{"location":"getting_around/using_the_command_line/#cli-command-syntax","title":"CLI Command Syntax","text":"<p>Most standard commands have three parts (though the last two are often optional):</p> <ol> <li>Command</li> <li>Option (optional)</li> <li>Argument (optional)</li> </ol> <p>For example:</p> <pre><code>ls -ltr /etc/\n</code></pre> <p>Which breaks down like this:</p> <pre><code>  ls    -ltr    /etc/\n   ^      ^       ^\nCOMMAND OPTION ARGUMENT\n</code></pre>"},{"location":"getting_around/using_the_command_line/#cli-commands-with-irregular-options","title":"CLI Commands with Irregular Options","text":"<p>Not every command follows this neat structure. Many advanced commands mix things up a bit:</p> <pre><code>grep -r 'conf' /etc/ # Recursively search for \"conf\" in all files in /etc\nfind /etc -name \"*journald**\" -exec ls -ltr {} \\; # Find files with \"journald\" in the name and list them\nps aux # List running processes (no hyphen for options here)\n</code></pre>"},{"location":"getting_around/using_the_command_line/#single-vs-double-hyphen-options","title":"Single vs Double Hyphen Options","text":"<p>Some commands accept both single and double hyphens. Single hyphens usually mean each letter is a separate option, while double hyphens spell out full words. For example:</p> <pre><code>lvcreate -h\nlvcreate --help\n</code></pre> <p>Both commands will show the help output.</p>"},{"location":"getting_around/using_the_command_line/#cli-visual-cues","title":"CLI Visual Cues","text":"<p>You can tell if you're running as <code>root</code> or a normal user by looking at the prompt.</p> <p>A normal user's prompt looks like this (note the <code>$</code>):</p> <pre><code>[brad@localhost ~]$ &lt;commandGoesHere&gt;\n</code></pre> <p>The <code>root</code> user gets a hash (<code>#</code>) at the end:</p> <pre><code>[root@localhost ~]# &lt;commandGoesHere&gt;\n</code></pre>"},{"location":"scripting/hello_world/","title":"Scripting <code>Hello World</code>","text":"<p>Writing a Hello World program is a rite of passage in programming. Here\u2019s how to do it in a shell script \u2014 straight from the command line on an enterprise Linux system.</p> Prerequisites <p>This guide assumes you're comfortable with  <code>vim</code>.  If not, maybe start  there first.</p>"},{"location":"scripting/hello_world/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Create the script file</p> <p>Starting from a shell, create and open a new file, \"HelloWorld.sh\", using <code>vim</code>:</p> Create HelloWorld.sh<pre><code>vim HelloWorld.sh\n</code></pre> </li> <li> <p>Write the script</p> <p>Inside \"HelloWorld.sh\", enter Insert mode and type this exactly:</p> Write HelloWorld.sh<pre><code>#!/bin/bash\n\necho \"Hello World!\"\n</code></pre> <p></p> <ul> <li>The first line (<code>#!/bin/bash</code>) is called a shebang. It tells Linux which   interpreter should run the script. In this case, it's the Bash shell.</li> <li>The blank line is optional, but it makes the script easier to read.</li> <li>The next line with the keyword <code>echo</code> just prints Hello World! to the   screen.</li> </ul> </li> <li> <p>Save and exit</p> <p>Go back to Normal mode, save the file, and exit using <code>:wq</code></p> </li> <li> <p>Make the file executable</p> <p>By default, new files aren't executable. Add that permission:</p> Make the file executable<pre><code>chmod 700 HelloWorld.sh # (1)!\n</code></pre> <ol> <li>Using <code>700</code> gives the owner full permissions (read, write, execute) while removing all permissions for group and others. See Basic Permissions for a more thorough explanation.</li> </ol> </li> <li> <p>Run the script</p> <p>Finally, run it:</p> Run the script<pre><code>./HelloWorld.sh\n</code></pre> <p></p> </li> </ol>"},{"location":"scripting/hello_world/#troubleshooting","title":"Troubleshooting","text":"<p>If your script didn\u2019t run the first time, don\u2019t worry \u2014 here are the common gotchas:</p>"},{"location":"scripting/hello_world/#permission-denied-when-running-helloworldsh","title":"Permission denied when running <code>./HelloWorld.sh</code>","text":"<ul> <li> <p>You probably forgot to make it executable. Run:</p> Make the file executable<pre><code>chmod 700 HelloWorld.sh\n</code></pre> </li> </ul>"},{"location":"scripting/hello_world/#command-not-found-or-nothing-happens","title":"<code>command not found</code> or nothing happens","text":"<ul> <li>Make sure you're running it with <code>./HelloWorld.sh</code> and not just <code>HelloWorld.sh</code>. The <code>./</code> tells the shell to look in the current directory for the script.</li> </ul>"},{"location":"scripting/hello_world/#weird-characters-in-the-output","title":"Weird characters in the output","text":"<ul> <li>Make sure you typed the script exactly as shown, especially the quotes around \"Hello World!\".</li> <li>Double-check that the first line is <code>#!/bin/bash</code> with no extra spaces or characters. If you leave out the <code>!</code>, for example, it won't work.</li> </ul>"},{"location":"scripting/hello_world/#using-windows-line-endings","title":"Using Windows line endings","text":"<ul> <li> <p>If you created the script on Windows and then copied it to Linux, it may have Windows-style line endings (CRLF) instead of Unix-style (LF). This can cause issues. To fix it, run:</p> Convert line endings<pre><code>dos2unix HelloWorld.sh\n</code></pre> </li> </ul>"},{"location":"scripting/hello_world/#still-stuck","title":"Still stuck?","text":"<ul> <li> <p>Try running the script with <code>bash -x</code> to see what\u2019s going on behind the     scenes:</p> Run with bash -x<pre><code>bash -x HelloWorld.sh\n</code></pre> </li> </ul>"}]}